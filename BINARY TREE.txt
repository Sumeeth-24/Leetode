COUNT NODES EQUAL TO AVERAGE OF SUBTREE

class Solution {
    
    private int count = 0;
    
    public int averageOfSubtree(TreeNode root) {
        if(root == null){
            return count;
        }
        postOrder(root);
        return count;
    }
    
    private int[] postOrder(TreeNode root){
        if(root == null){
            return new int[]{0,0};
        }
        
        int[] left = postOrder(root.left);
        int[] right = postOrder(root.right);
        
        int totalSum = left[0] + right[0] + root.val;
        int totalNode =  left[1] + right[1] + 1;
        if(totalSum / totalNode == root.val){
            count++;
        }
        
        return new int[]{totalSum, totalNode};
    }
}

FIND DUPLICATE SUBTREE

class Solution {
   
        HashMap<String, Integer> map= new HashMap<>();//String -- frequency//it store the string at every instant when we visit parent after visiting its children //it also calculates the frequency of the String in the tree
    ArrayList<TreeNode> res= new ArrayList<>();//it contain the list of dublicate nodes 
    
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) 
    {
        Mapper(root);
        return res;//returning the list containing a node of dublicate subtree
    }
    
    public String Mapper(TreeNode root)
    {//we are doing postorder traversal because we want to first deal with children and then the parent 
        if(root == null)//when we reach to the null ,we return N to tell that i am null and unique 
            return "N";
        
        String left= Mapper(root.left);//recursing down the left subtree and knowing about the left child //LEFT
        String right= Mapper(root.right);//recursing down the hright subtree and knowing abou the right child //RIGHT
        
        //ROOT
        String curr= root.val +" "+left +" "+ right;//after knowing about the left and right children//parent forms their own string //space is added to disinguish the string of same reapeatating root value ex- 11 N , 1 1N
        
        map.put(curr, map.getOrDefault(curr, 0)+ 1);//counting the frequency of string 
        
        if(map.get(curr) == 2)//only the dublicate string node are added to the ArrayList 
            res.add(root);
    
        return curr;//returning to the parent to that i am present, and here is my string with the informationn of my left and right child 
    }
}

SUM OF ROOT TO LEAF BINARY NUMBER

class Solution {
     int totalSum = 0;
    public int sumRootToLeaf(TreeNode root) {
       
        if(root == null) return 0;
        
        postorder(root, 0);
        return totalSum;
    }
    
    private void postorder(TreeNode node, int tempSum){
        if(node==null) return;
        
        tempSum = tempSum + node.val;
        if(node.left == null && node.right == null){
            totalSum += tempSum;
            return;
        }
        postorder(node.left, 2*tempSum);
        postorder(node.right, 2*tempSum);
    }
}


MINIMUM HEIGHT TREE

class Solution {
    List<Integer> ans = new ArrayList<>();
    List<Integer> [] adj;
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        if (n==1) {
            ans.add(0); return ans;
        }
        adj = new List[n]; int [] inDeg = new int[n]; 
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<>();
        }
        for (int i = 0; i < edges.length; i++) {
            adj[edges[i][0]].add(edges[i][1]);
            adj[edges[i][1]].add(edges[i][0]);
            inDeg[edges[i][0]]++; inDeg[edges[i][1]]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (inDeg[i]==1) {
                queue.add(i);
            }
        }
        while (n>2) {
            n-=queue.size();
            int size = queue.size();
            while (size>0) {
                int cur = queue.poll();
                for (int nxt : adj[cur]) {
                    inDeg[nxt]--;
                    if (inDeg[nxt]==1) {
                        queue.add(nxt);
                    }
                }
                size--;
            }
        }
        ans = new ArrayList<>(queue);
        return ans;
        
    }
}



STEP BY STEP DIRECTION FROM TREE NODE TO ANOTHER

Let p1 = start > root path.
Let p2 = end > root path.
Remove common prefix path between p1 and p2
Replace all the remaining part of p1 to "U"
Reverse the remaining the part of p2
Add p1 and p2
Solution:

class Solution {
    
    private boolean DFS(TreeNode currNode, StringBuilder path, int destVal) {
        if(currNode == null) return false;
        if(currNode.val == destVal) return true;
        if(DFS(currNode.left, path, destVal)){
            path.append("L");
	    }
        else if(DFS(currNode.right, path, destVal)){
            path.append("R");
	   }
        return path.length() > 0;
    }
    
    public String getDirections(TreeNode root, int startValue, int destValue) {
        StringBuilder startToRoot = new StringBuilder();
        StringBuilder endToRoot = new StringBuilder();
        
        DFS(root, startToRoot, startValue);
        DFS(root, endToRoot, destValue);
        
        int i = startToRoot.length(), j = endToRoot.length();
        int cnt = 0;
        while(i > 0 && j > 0 && startToRoot.charAt(i-1) == endToRoot.charAt(j-1)) {
            cnt++; i--; j--;
        }
        
        String sPath = "U".repeat(startToRoot.length() - cnt);
        String ePath = endToRoot.reverse().toString().substring(cnt, endToRoot.length());
        
        return sPath + ePath;
    }
}

LCA

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
         if (root == null || root == p || root == q)
    // found p or q or touch the ground
    return root;
        
  // search p and q from left and right
  TreeNode left = lowestCommonAncestor(root.left, p, q);
  TreeNode right = lowestCommonAncestor(root.right, p, q);
  
  if (left != null && right != null)
    // from root's left & right we found both p and q, so root is the LCA
    return root;
  else
    // left is not null means from left's left & right we found both p and q
    // so left is the LCA, otherwise, right is the answer
    return left != null ? left : right;
    }
}

SMALLEST STRING FROM LEAF TO ROOT

class Solution {
    
        String res = "";

public String smallestFromLeaf(TreeNode root) {
    dfs(root , new StringBuilder());
    return res;
}

public void dfs(TreeNode root , StringBuilder currStr) {
    if(root == null) return;
    
    currStr.insert(0,(char)(root.val + 'a'));
    
    if(root.left == null && root.right == null){
        
		if(res.equals(""))
            res = currStr.toString();
        else 
            res = res.compareTo(currStr.toString()) > 0 ? currStr.toString() : res;
    
    } else {
    
        dfs(root.left , currStr);
        dfs(root.right , currStr);
    
	}
    
    currStr.deleteCharAt(0);
    }
}

NODE TO ROOTPATH

 class Tree{
    public ArrayList<ArrayList<Integer>> nodetorootpath(Node node, int data){
        if(node == null) return null;
        
        if(node.val == data){
            ArrayList<TreeNode> list = new ArrayList<>();
            list.add(node);
            return list;
        }
        
        ArrayList<TreeNode> left = nodetorootpath(node.left, data);
        if(left != null){
            left.add(node);
            return left;
        }
        
        ArrayList<TreeNode> right = nodetorootpath(node.right, data);
        if(right != null){
            right.add(node);
            return right;
        }
        
        return null;
        
    }
    
}

  public static ArrayList<TreeNode> nodeToRootPath(TreeNode root, int data) {
    ArrayList<TreeNode> path = new ArrayList<>();
    nodeToRootPath(root, data);
    return path;
  }



ALL NODES AT K DISTANCE IN BINARY TREE

class Solution {
    public static void kdown(TreeNode root, int k, TreeNode block, List<Integer> ans) {
    if (root == null || k < 0 || root == block)
      return;

    if (k == 0) {
      ans.add(root.val);
      return;
    }

    kdown(root.left, k - 1, block, ans);
    kdown(root.right, k - 1, block, ans);
  }

  public static int distanceK(TreeNode root, TreeNode target, int k, List<Integer> ans) {
    if (root == null)
      return -1;

    if (root.val == target.val) {
      kdown(root, k, null, ans);
      return 1;
    }

    int ld = distanceK(root.left, target, k, ans);
    if (ld != -1) {
      kdown(root, k - ld, root.left, ans);
      return ld + 1;
    }

    int rd = distanceK(root.right, target, k, ans);
    if (rd != -1) {
      kdown(root, k - rd, root.right, ans);
      return rd + 1;
    }

    return -1;
  }
    
    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        List<Integer> ans = new ArrayList<>();
    distanceK(root, target, k, ans);

    return ans;
    }
}



BURNING TREE

  public static int totalTime = 0;

  public static void burningTreeNode(TreeNode root, int time, TreeNode blockNode) {
    if (root == null || root == blockNode)
      return;
    totalTime = Math.max(totalTime, time);
    burningTreeNode(root.left, time + 1, blockNode);
    burningTreeNode(root.right, time + 1, blockNode);

  }

  public static int burningTree_(TreeNode root, int fireNode) {
    if (root == null)
      return -1;
    if (root.val == fireNode) {
      burningTreeNode(root, 0, null);
      return 1;
    }

    int lt = burningTree_(root.left, fireNode);
    if (lt != -1) {
      burningTreeNode(root, lt, root.left);
      return lt + 1;
    }

    int rt = burningTree_(root.right, fireNode);
    if (rt != -1) {
      burningTreeNode(root, rt, root.right);
      return rt + 1;
    }

    return -1;
  }

  public static int burningTree(TreeNode root, int fireNode) {
    totalTime = 0;
    burningTree_(root, fireNode);
    return totalTime;
  }



BURNING TREE II

 public static void burningTreeNode(TreeNode root, int time, TreeNode blockNode, ArrayList<ArrayList<Integer>> ans) {
    if (root == null || root == blockNode)
      return;
    if (time == ans.size()) // if(time == ans.size()) ans.push_back({});
      ans.add(new ArrayList<>());
    ans.get(time).add(root.val);

    burningTreeNode(root.left, time + 1, blockNode, ans);
    burningTreeNode(root.right, time + 1, blockNode, ans);

  }

  public static int burningTree(TreeNode root, int fireNode, ArrayList<ArrayList<Integer>> ans) {
    if (root == null)
      return -1;
    if (root.val == fireNode) {
      burningTreeNode(root, 0, null, ans);
      return 1;
    }

    int lt = burningTree(root.left, fireNode, ans);
    if (lt != -1) {
      burningTreeNode(root, lt, root.left, ans);
      return lt + 1;
    }

    int rt = burningTree(root.right, fireNode, ans);
    if (rt != -1) {
      burningTreeNode(root, rt, root.right, ans);
      return rt + 1;
    }

    return -1;
  }

  public static ArrayList<ArrayList<Integer>> burningTree(TreeNode root, int data) {
    ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
    burningTree(root, data, ans);
    return ans;
  }



TREE TO DLL

class Solution
{
    public Node getrightmostnode(Node node, Node curr){
        while(node.right != null && node.right != curr){
        node = node.right;
        }
        return node;
    }
    
    Node bToDLL(Node root)
    {
	   Node dummy = new Node(-1);
	   Node prev = dummy, curr = root;
	   
	   while(curr != null){
	       Node left = curr.left;
	       if(left == null){
	           
	           // created links
	           prev.right = curr;
	           curr.left = prev;
	           prev = curr;
	           
	           //move
	           curr = curr.right;
	       } else {
	           Node rightMostNode = getrightmostnode(left, curr);
	           
	           if(rightMostNode.right == null){
	               rightMostNode.right = curr;  // thread creation
	               curr = curr.left;
	           } else {
	               rightMostNode.right = null;
	               
	               //created links
	               prev.right = curr;
	               curr.left = prev;
	               prev = curr;
	               
	               //move
	               curr = curr.right;
	           }
	       }
	   }
	   
	   Node head = dummy.right;
	   
	   dummy.right = head.left = null;
	   
	   prev.right = head;
	   head.left = prev;
	   
	   return head;
	   
    }
}



MAXIMUM PATH SUM BETWEEN TWO LEAF NODES

class Solution
{
    public class pair{
        int LTLMaxSum = -(int)1e9 ;
        int NTLMaxSum = -(int)1e9;
    }
    
    public pair maxPathSum_(Node root){
        pair myAns = new pair();
        
        if(root == null) return myAns;
        
        if(root.left == null && root.right == null){
            myAns.NTLMaxSum = root.data;
            return myAns;
        }
        
        pair lp = maxPathSum_(root.left);
        pair rp = maxPathSum_(root.right);
        
        
        
        myAns.LTLMaxSum = Math.max(lp.LTLMaxSum, rp.LTLMaxSum);
        
        if(root.left != null && root.right != null){
            myAns.LTLMaxSum = Math.max(myAns.LTLMaxSum, lp.NTLMaxSum + root.data + rp.NTLMaxSum);
        }
        
        myAns.NTLMaxSum = Math.max(lp.NTLMaxSum, rp.NTLMaxSum) + root.data;
        return myAns;
    }
    public int maxPathSum(Node root)
    { 
        return maxPathSum_(root).LTLMaxSum;
    } 
}



BINARY TREE MAXIMUM PATH SUM

class Solution {
    int maxSum;
    public int maxPathSum(TreeNode root) {
        int maxValue[] = new int[1];
        maxValue[0] = Integer.MIN_VALUE;
        maxPathDown(root, maxValue);
        return maxValue[0];
    }
    
    
    private int maxPathDown(TreeNode node, int maxValue[]){
        if (node == null) {
		      return 0;
		    }
        
        int left = Math.max(0, maxPathDown(node.left, maxValue)); // if negative no comes then return 0
         int right = Math.max(0, maxPathDown(node.right, maxValue));//same
        maxValue[0] = Math.max(maxValue[0], left+right+node.val);
        return Math.max(left,right) + node.val;
    }
         
}


DIAMETER OF BINARY TREE

class Solution {
    int maxSum;
    public int maxPathSum(TreeNode root) {
        int maxValue[] = new int[1];
        maxValue[0] = Integer.MIN_VALUE;
        maxPathDown(root, maxValue);
        return maxValue[0];
    }
    
    
    private int maxPathDown(TreeNode node, int maxValue[]){
        if (node == null) {
		      return 0;
		    }
        
        int left =  maxPathDown(node.left, maxValue); // if negative no comes then return 0
         int right =  maxPathDown(node.right, maxValue);//same
        maxValue[0] = Math.max(maxValue[0], left+right);
        return Math.max(left,right) + 1;
    }
         
}


SERIALIZE AND DESIARLIZE TREE

public class Codec {
    
    public void serialize_(TreeNode root, StringBuilder sb){
        if(root == null){
            sb.append("null,");
            return;
        }
        
        sb.append(root.val+",");
        serialize_(root.left, sb);
        serialize_(root.right, sb);
    }

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize_(root, sb);
        return sb.toString();
    }

    int idx = 0;
    public TreeNode deserialize_(String[] arr){
        if(idx >= arr.length || arr[idx].equals("null")){
            idx++;
            return null;
        }
        
        TreeNode node = new TreeNode(Integer.parseInt(arr[idx++]));
        node.left = deserialize_(arr);
        node.right = deserialize_(arr);
        
        return node;
    }
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] arr = data.split(",");
       return deserialize_(arr);
    }
}


VERTICAL ORDER TRVAERSAL

class Solution
{
    public static class vPair{
        Node node = null;
        int hl = 0;
        
        vPair(Node node, int hl){
            this.node = node;
            this.hl = hl;
        }
    }
    
    public static void width(Node root, int hl, int[] ans){
        if(root == null) return;
        
        ans[0] = Math.min(ans[0], hl);
        ans[1] = Math.max(ans[1], hl);
        
        width(root.left, hl-1, ans);
        width(root.right, hl+1, ans);
    }
    
    static ArrayList <Integer> verticalOrder(Node root)
    {
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        if(root == null) return ans;
        
        int[] minMax = new int[2];
        width(root,0,minMax);
        int len = minMax[1] - minMax[0] + 1;
        
        for(int i=0; i<len; i++) ans.add(new ArrayList<>());
        
        LinkedList<vPair> q = new LinkedList<>();
        q.add(new vPair(root, Math.abs(minMax[0])));
        
        while(q.size() != 0){
            int size = q.size();
            while(size-- > 0){
                vPair rp = q.removeFirst();
                
                int hl = rp.hl;
                Node node = rp.node;
                
                ans.set(hl, ans.get(hl) + node.val);  // VERTICAL ORDER SUM
                ans.get(hl).add(node.data);
                
                if(node.left != null) q.addLast(new vPair(node.left, hl-1));
                if(node.right != null) q.addLast(new vPair(node.right, hl+1));
            }
        }
        
        return ans;
    }
}



VERTICAL ORDER SUM USING RECURSION

class Solution{
    public static void width(Node root, int hl, int[] ans){
        if(root == null) return;
        
        ans[0] = Math.min(ans[0], hl);
        ans[1] = Math.max(ans[1], hl);
        
        width(root.left, hl-1, ans);
        width(root.right, hl+1, ans);
    }
    
    public static void dfs(Node root, int hl, ArrayList<Integer> ans){
        if(root == null) return;
        
        ans.set(hl, ans.get(hl) + root.data);
        
        dfs(root.left, hl-1, ans);
        dfs(root.right, hl+1, ans);
    }
    public static ArrayList <Integer> verticalSum(Node root) {
        int[] minMax = new int[2];
        width(root, 0, minMax);
        
        int len = minMax[1] - minMax[0] + 1;
        ArrayList<Integer> ans = new ArrayList<>();
        for(int i=0; i< len; i++) ans.add(0);
        
        dfs(root, Math.abs(minMax[0]), ans);
        return ans;
    }
}


MAXIMUM LEVEL SUM IN BINARY TREE

class Solution {
    public int maxLevelSum(TreeNode root) {
         if (root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        
        int level = 0;
        int minLevel = 0, maxSum = Integer.MIN_VALUE;
        while (!queue.isEmpty()) {
            int size = queue.size();
            level++;
            int levelSum = 0;
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                levelSum += node.val;
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            if (levelSum > maxSum) {
                maxSum = levelSum;
                minLevel = level;
            }
        }
        return minLevel;
    }
}



DIAGONAL TRAVERSAL

public class Solution {
    public ArrayList<Integer> solve(TreeNode root) {
        LinkedList<TreeNode> q = new LinkedList<>();
        ArrayList<Integer> ans = new ArrayList<>();

        q.addLast(root);
        while(q.size() != 0){
            int size = q.size();

            while(size-- > 0){
                TreeNode rn = q.removeFirst();
                 while(rn != null){
                     ans.add(rn.val);

                     if(rn.left != null) q.addLast(rn.left);

                     rn = rn.right;
                 }
            }
        }
        return ans;
    }


DIAGONAL ORDER SUM

class Tree {
    public static ArrayList <Integer> diagonalSum(Node root) 
    {
         LinkedList<Node> q = new LinkedList<>();
        ArrayList<Integer> ans = new ArrayList<>();

        q.addLast(root);
        
        while(q.size() != 0){
            int size = q.size();
            int sum = 0;
            while(size-- > 0){
                Node rn = q.removeFirst();
                 while(rn != null){
                     sum += rn.data;

                     if(rn.left != null) q.addLast(rn.left);

                     rn = rn.right;
                 }
            }
            ans.add(sum);
        }
        return ans;
    }
}



    

LONGEST ZIGZAG PATH IN TREE

class Solution {
    public static class pair {
        int forwardslope = -1;
        int backwardslope = -1;
        int maxLen = 0;
    }
    
    public static pair longestZigZag_(TreeNode root){
        if(root == null) return new pair();
        
        pair left = longestZigZag_(root.left);
        pair right = longestZigZag_(root.right);
        
        pair myans = new pair();
        myans.maxLen = Math.max(Math.max(left.maxLen, right.maxLen), Math.max(left.backwardslope, right.forwardslope) + 1);
        
        myans.forwardslope = left.backwardslope + 1;
        myans.backwardslope = right.forwardslope + 1;
        
        return myans;
    }
    public static int longestZigZag(TreeNode root) {
        pair ans = longestZigZag_(root);
        return ans.maxLen;
    }
}


VALIDATE BST

class Solution {
    public TreeNode prev = null;
    
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        
        if(!isValidBST(root.left)) return false;
        
        if(prev != null && prev.val >= root.val) return false;
        
        prev = root;
        
        if(!isValidBST(root.right)) return false;
        
        return true;
    }
}


MORRIS TRAVERSAL VALIDATE BST

class Solution {
    
    
    public TreeNode getRightMostNode(TreeNode rmn, TreeNode curr){
        while(rmn.right != null && rmn.right != curr){
            rmn = rmn.right;
        }
        return rmn;
    }
    
    public boolean isValidBST(TreeNode root) {
        TreeNode prev = null, curr = root;
        
        while(curr != null){
            TreeNode leftNode = curr.left;
            
            if(leftNode == null){
                if(prev != null && prev.val >= curr.val)
                    return false;
                
                prev = curr;
                curr = curr.right;
            } else {
                TreeNode rightmostnode = getRightMostNode(leftNode, curr);
                
                if(rightmostnode.right == null){
                    rightmostnode.right = curr;
                    curr = curr.left;
                } else {
                    if(prev.val >= curr.val)
                        return false;
                    rightmostnode.right = null;
                    prev = curr;
                    curr = curr.right;
                }
            }
        }
        return true;
    }
}


RECOVER BST

class Solution {
    public TreeNode getRightMostNode(TreeNode rmn, TreeNode curr){
        while(rmn.right != null && rmn.right != curr){
            rmn = rmn.right;
        }
        return rmn;
    }
    
    public void recoverTree(TreeNode root) {
        TreeNode curr = root, a = null, b = null, prev = null;
        
        while(curr != null){
            TreeNode leftNode = curr.left;
            if(leftNode == null){
                if(prev != null && prev.val > curr.val){
                    if(a == null)
                        a = prev;
                        b = curr;
                }
                prev = curr;
                curr = curr.right;
            } else {
                TreeNode rmn = getRightMostNode(leftNode, curr);
                if(rmn.right == null){
                    rmn.right = curr;
                    curr = curr.left;
                } else {
                    rmn.right = null;
                    if(prev.val > curr.val){
                        if(a == null){
                            a = prev;
                        }
                        b = curr;
                        
                    }
                    prev = curr;
                        
                    curr = curr.right;
                }
            }
        }
        
        if(a != null){
            int temp = a.val;
            a.val = b.val;
            b.val = temp;
        }
        
        
    }
}

COMPLETE BINARY TREE INSERTER

class CBTInserter {

    TreeNode head = null;
    TreeNode nip = null;
    Queue<TreeNode> q = new LinkedList<>();
    public CBTInserter(TreeNode root) {
        head = root;
        
        q.add(root);
        
        while(true){
            TreeNode top = q.peek();
            
            if(top.left != null){
                q.add(top.left);
            }
            else {
                nip = top;
                break;
            }
            
            if(top.right != null){
                q.add(top.right);
            }
            else {
                nip = top;
                break;
            }
            q.poll();
            
            
        }
    }
    
    public int insert(int val) {
        int treturn = nip.val;
        
        if(nip.left == null){
            TreeNode node = new TreeNode(val);
            nip.left = node;
            q.add(node);
           
        }
        else{
            TreeNode node = new TreeNode(val);
            nip.right = node;
            q.add(node);
            q.poll();
            nip = q.peek();
        }
        return treturn;
    }
    
    public TreeNode get_root() {
        return head;
    }
}


LONGEST UNIVALUE PATH

class Solution {
    static int max;
    public int longestUnivaluePath(TreeNode root) {
        max = 0;
        longestUniValuedPath2(root);
        return max;
    }
    
    public int longestUniValuedPath2(TreeNode root){
        if(root == null) return -1;
        
        if(root.left == null && root.right == null) return 0;
        
        int lc = longestUniValuedPath2(root.left);
        int rc = longestUniValuedPath2(root.right);
        
        int lans = 0, rans = 0;
        
        if(root.left != null && root.left.val == root.val) lans = lc + 1;
        
        if(root.right != null && root.right.val == root.val) rans = rc + 1;
        
        int ans = Math.max(lans, rans);
        max = Math.max(max, lans+rans);
        
        return ans;
    }
}


BINARY TREE COLORING GAME

class Solution {
    int lchild, rchild;
    public boolean btreeGameWinningMove(TreeNode root, int n, int x) {
        lchild = 0;
        rchild = 0;
        
        count(root, x);
        int noofnodesofparentexcludingself = n - (lchild+rchild+1);
        int max = Math.max(noofnodesofparentexcludingself, Math.max(lchild,rchild));
        return max >(n/2);
    }
    
    private int count(TreeNode root, int x){
        if(root == null){
            return 0;
        } 
        
        int left = count(root.left, x);
        int right = count(root.right, x);
        
        if(root.val == x){
            lchild = left;
            rchild = right;
        }
        
        return left+right + 1;
    }
}

SECOND MINIMUM NODE IN TREE

class Solution {
    public int findSecondMinimumValue(TreeNode root) {
       if(root==null || root.right==null || root.left==null) return -1;
	Queue<TreeNode> q = new LinkedList<>();
	q.offer(root);
	Integer secondMin = null;
	while(!q.isEmpty()) {
		TreeNode curr = q.poll();
		if(curr.right!=null) q.offer(curr.right);
		if(curr.left!=null) q.offer(curr.left);
		if(curr.val!=root.val) {
			if(secondMin==null) secondMin = curr.val;
			else secondMin = Math.min(secondMin, curr.val);
		}
	}
	return secondMin==null? -1 : secondMin;
    }
}


PATH IN ZIGZAG LABELLED BINARY TREE

class Solution {
    public List<Integer> pathInZigZagTree(int n) {
        int llv = 1;
        int ctval=0;
        while(ctval < n){
            ctval += llv;
            llv *= 2;
        }
        llv /= 2;
        List<Integer> ans = new ArrayList<>();
        
        while(n != 1){
            ans.add(0, n);
            int compl = (3*llv - n - 1);
            int parent = (compl/2);
            n = parent;
            llv /= 2;
        }
        ans.add(0, 1);
        return ans;
    }
}


ADD ONE ROW TO TREE

class Solution {
    public TreeNode addOneRow(TreeNode root, int val, int depth) {
        int currdepth = 1;
         if (depth == 1) {
            TreeNode newroot = new TreeNode(val);
            newroot.left = root;
            return newroot;
        }
        
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(currdepth < depth - 1) {
            int size = queue.size();
            for (int j = 0; j < size; j++) {
                TreeNode t = queue.poll();
                if (t.left != null) queue.add(t.left);
                if (t.right != null) queue.add(t.right);
            }
            currdepth++;
        }
        while (!queue.isEmpty()) {
            TreeNode t = queue.poll();
            TreeNode tmp = t.left;
            t.left = new TreeNode(val);
            t.left.left = tmp;
            tmp = t.right;
            t.right = new TreeNode(val);
            t.right.right = tmp;
        }
        return root;
    }
}


ALL POSSIBLE FULL BINARY TREE

class Solution {
    public List<TreeNode> allPossibleFBT(int N) {
         List<TreeNode> list = new ArrayList<>();
        if (N % 2 == 0) return list;
        if (N == 1) { 
            list.add(new TreeNode(0));
            return list;
        }
        for (int leftNum = 1; leftNum < N; leftNum += 2) {
            List<TreeNode> fLeft = allPossibleFBT(leftNum);
            List<TreeNode> fRight = allPossibleFBT(N-leftNum-1);
            for (TreeNode left: fLeft) {
                for (TreeNode right: fRight) {
                    TreeNode node = new TreeNode(0);
                    node.left = left;
                    node.right = right;
                    list.add(node);
                }
            }
        }
        
        return list;
    }
}

 


EVEN OOD TREE

class Solution {
    public boolean isEvenOddTree(TreeNode root) {
         if(root==null)
            return false;
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.add(root);
        int level = 0, prev = 0;
        while(!q.isEmpty()){
            int size = q.size();
            for(int i=0;i<size;i++){
                TreeNode curr=q.poll();
                if(level%2==0 && (curr.val%2==0 || (i>0 && curr.val<=prev))) //even 
                    return false;
                if(level%2!=0 && (curr.val%2!=0 || (i>0 && curr.val>=prev))) //odd
                    return false;
                prev=curr.val;
                if(curr.left!=null)
                    q.add(curr.left);
                if(curr.right!=null)
                    q.add(curr.right);
            }
            level++;
        }        
        return true;
    }
}




POPULATING NEXT RIGHT POINTER II

class Solution {
    public Node connect(Node root) {
      if(root == null) return null;
        
        Node head = root;
        
        while(head != null){
            Node dummy = new Node(0);
            Node temp = dummy;
            
            while(head != null){
                if(head.left != null){
                    temp.next=head.left;
                    temp=temp.next;
                }
                
                if(head.right != null){
                    temp.next = head.right;
                    temp=temp.next;
                }
                head=head.next;
            }
            head =dummy.next;
        }
        return root;
    }
}


DELETE NODE AND RETURN FOREST

class Solution {
    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
      List<TreeNode> forest = new ArrayList<>();
        if (root == null) return forest;
        Set<Integer> set = new HashSet<>();
        for(int i : to_delete) {
            set.add(i);
        }
        deleteNodes(root, set, forest);
        if (!set.contains(root.val)) {
            forest.add(root);
        }
        return forest;
    }

    private TreeNode deleteNodes(TreeNode node, Set<Integer> set, List<TreeNode> forest) {
        if (node == null) return null;

        node.left = deleteNodes(node.left, set, forest);
        node.right = deleteNodes(node.right, set, forest);

        if (set.contains(node.val)) {
            if (node.left != null) forest.add(node.left);
            if (node.right != null) forest.add(node.right);
            return null;
        }

        return node;
    }
}


COUNT NODES WITH HIGHEST SCORE

class Solution {

	class TreeNode {
		private TreeNode left;
		private TreeNode right;
		private long score = 0L;
		private int nodeCount = 0;

	}

	private int countNodes (TreeNode root) {
		if (root == null) {
			return 0;
		}
		root.nodeCount = countNodes(root.left) + countNodes(root.right) + 1;

		return root.nodeCount;
	}


	public int countHighestScoreNodes(int[] parents) {
		long max = 0l;

		int n = parents.length;
		int ans = 0;
		TreeNode[] tree = new TreeNode[n];

		for (int i = 0; i < parents.length; i++) {
			tree[i] = new TreeNode();
		}

		for (int i = 1; i < parents.length; i++) {
			int parentId = parents[i];
			if (tree[parentId].left == null) {
				tree[parentId].left = tree[i];
			} else {
				tree[parentId].right = tree[i];
			}
		}

		countNodes(tree[0]);


		for (int i = 0; i < parents.length; i++) {
			long product = 1;
			int leftCnt = tree[i].left == null ? 0 : tree[i].left.nodeCount;
			int rightCnt = tree[i].right == null ? 0 : tree[i].right.nodeCount;
			int parentCnt = n - 1 - leftCnt - rightCnt;

			if (leftCnt > 0) {
				product *= leftCnt;
			}
			if (rightCnt > 0) {
				product *= rightCnt;
			}
			if (parentCnt > 0) {
				product *= parentCnt;
			}
			tree[i].score = product;
			max = Math.max(max, product);
		}

		//count nodes
		for (int i = 0; i < parents.length; i++) {
			if (tree[i].score == max) {
				ans++;
			}
		}
		return ans;
	}


}

DISTRIBUTE COINS IN TREE

class Solution {
   private int steps = 0; 

public int distributeCoins(TreeNode root) {
    postorder(root);
    return steps;
}

// return coins of this level
private int postorder(TreeNode node) {
    if(node == null) return 0;
    
    // coin from children -- post-order traversal
    int left = postorder(node.left);
    steps += Math.abs(left);
    int right = postorder(node.right);
    steps += Math.abs(right);
    
    return left + right + node.val - 1;
	
}
}

COUNT GOOD NODES

class Solution {
    
    private int goodCount = 0;
    public int goodNodes(TreeNode root) {
        
        cal(root, Integer.MIN_VALUE);
        return goodCount;
    }
    
   private void cal(TreeNode root, Integer max){
        if(root == null){
            return;
        }
       
        if(root.val >= max){
            goodCount++;
        } 
        
        cal(root.left,Math.max(root.val, max));
        cal(root.right,Math.max(root.val, max));
       return;
     
      }
 }

CAMERAS IN BINARY TREE

class Solution {
      static int camera = 0;

    public static int MinCamerasInBT_(TreeNode root) {
        if (root == null) {
            return 1;  // i am covered
        }

        int lres = MinCamerasInBT_(root.left);
        int rres = MinCamerasInBT_(root.right);

        if (lres == -1 || rres == -1) {  // i need camera
            camera++;
            return 0;
        }

        if (lres == 0 || rres == 0) {  // i have camera
            return 1;
        }

        return -1;
    }
    
    public int minCameraCover(TreeNode root) {
        if (MinCamerasInBT_(root) == -1)
            camera++;
        return camera;
    }
}

HOUSE ROBBER III

class Solution {
    public static class housePair{
        int withrobbery = 0;
        int withoutrobbery = 0;
    }
    
    public static housePair HouseRobber(TreeNode root){
        if(root == null) return new housePair();
        
        housePair left = HouseRobber(root.left);
        housePair right = HouseRobber(root.right);
        
        housePair myAns = new housePair();
        
        myAns.withrobbery = left.withoutrobbery + root.val + right.withoutrobbery;
        
        myAns.withoutrobbery = Math.max(left.withrobbery, left.withoutrobbery)+ Math.max(right.withrobbery, right.withoutrobbery);
            
            return myAns;
    }
    
    public int rob(TreeNode root) {
        housePair res = HouseRobber(root);
        
        return Math.max(res.withoutrobbery, res.withrobbery);
    }
}


PATH SUM II

class Solution {
     public static void pathSum(TreeNode root, int tar, List<List<Integer>> res, List<Integer> smallAns) {
    if (root == null)
      return;

    if (root.left == null && root.right == null) {
      if (tar - root.val == 0) {
        List<Integer> base = new ArrayList<>(smallAns);
        base.add(root.val);
        res.add(base);
      }

      return;
    }

    smallAns.add(root.val);
    pathSum(root.left, tar - root.val, res, smallAns);
    pathSum(root.right, tar - root.val, res, smallAns);
         
    smallAns.remove(smallAns.size() - 1);
  }
    
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> res = new ArrayList<>();
    pathSum(root, targetSum, res, new ArrayList<>());
    return res;
    }
}


BINARY TREE PATH

class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
      List<String> answer = new ArrayList<String>();
    if (root == null){
        return answer;
    } 
    searchBT(root, "", answer);
    return answer;
}
private void searchBT(TreeNode root, String path, List<String> answer) {
    path += root.val;
    if (root.left == null && root.right == null){
        answer.add(path);
        return;
    }
    
    if (root.left != null){
        searchBT(root.left, path  + "->", answer);
    } 
    if (root.right != null){
        searchBT(root.right, path  + "->", answer);
    }
}
}

POST ORDER TRAVERSAL

class Solution {

    public List<Integer> postorderTraversal(TreeNode root) {
        Stack<TreeNode> st1 = new Stack<TreeNode>(); 
        Stack<TreeNode> st2 = new Stack<TreeNode>();
        List<Integer> postOrder = new ArrayList<Integer>();
        
        if(root == null) return postOrder; 
        
        st1.push(root); 
        while(!st1.isEmpty()) {
            root = st1.pop(); 
            st2.add(root); 
            if(root.left != null) st1.push(root.left); 
            if(root.right != null) st1.push(root.right); 
        }
        while(!st2.isEmpty()) {
            postOrder.add(st2.pop().val); 
        }
        return postOrder; 
    }
}

RECURSION

class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
         List<Integer> ans = new ArrayList<>();
        dfs(root, ans);
        return ans;
    }
     private void dfs(TreeNode node, List<Integer> inorder){
        if(node == null) return;
        
        dfs(node.left, inorder);
       
        dfs(node.right, inorder);
          inorder.add(node.val);
    }
   
}

1 STACK

class Solution {

    public List<Integer> postorderTraversal(TreeNode root) {
        Stack<TreeNode> st1 = new Stack<TreeNode>(); 
        List<Integer> postOrder = new ArrayList<Integer>();
        
        if(root == null) return postOrder; 
        
        TreeNode current = root;  
        while(current != null || !st1.isEmpty()) {
            if(current != null){
                st1.push(current);
                current = current.left;
            }else{
                TreeNode temp = st1.peek().right;
                if (temp == null) {
                    temp = st1.pop();
                    postOrder.add(temp.val);
                    while (!st1.isEmpty() && temp == st1.peek().right) {
                        temp = st1.pop();
                        postOrder.add(temp.val);
                    }
                } else {
                    current = temp;
                }
            }
        }
      
        return postOrder; 
    }
}


PREORDER TRAVERSAL

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> preorder = new ArrayList<Integer>();
        if(root == null) return preorder; 
        Stack<TreeNode> q = new Stack<TreeNode>(); 
        q.push(root);
        while(!q.isEmpty()){
            root = q.pop();
            preorder.add(root.val); 
            if(root.right != null){
                q.push(root.right);
            }
            if(root.left!= null){
                q.push(root.left);
            }
        }
        return preorder; 
    }
}

PREORDER MORRIS

 public static TreeNode rightMostNode(TreeNode node, TreeNode curr) {
    while (node.right != null && node.right != curr) {
      node = node.right;
    }
    return node;
  }

  public static ArrayList<Integer> morrisPreTraversal(TreeNode Treenode) {
    ArrayList<Integer> ans = new ArrayList<>();
    TreeNode curr = Treenode;
    while (curr != null) {
      TreeNode leftTreeNode = curr.left;
      if (leftTreeNode == null) { // left null
        ans.add(curr.val);
        curr = curr.right;
      } else {
        TreeNode rmost = rightMostNode(leftTreeNode, curr);
        if (rmost.right == null) { // thread Creation
          rmost.right = curr;
          ans.add(curr.val);
          curr = curr.left;
        } else { // thread Break
          rmost.right = null;
          curr = curr.right;
        }
      }
    }

    return ans;
  }


INORDER MORRIS

public static TreeNode rightMostNode(TreeNode node, TreeNode curr) {
    while (node.right != null && node.right != curr) {
      node = node.right;
    }
    return node;
  }

  public static ArrayList<Integer> morrisInTraversal(TreeNode Treenode) {
    ArrayList<Integer> ans = new ArrayList<>();
    TreeNode curr = Treenode;
    while (curr != null) {
      TreeNode leftTreeNode = curr.left;
      if (leftTreeNode == null) { // left null
        ans.add(curr.val);
        curr = curr.right;
      } else {
        TreeNode rmost = rightMostNode(leftTreeNode, curr);
        if (rmost.right == null) { // thread Creation
          rmost.right = curr;
          curr = curr.left;
        } else { // thread Break
          rmost.right = null;
          ans.add(curr.val);
          curr = curr.right;
        }
      }
    }

    return ans;
  }


INORDER TRAVERSAL

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> inorder = new ArrayList<Integer>(); 
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode node = root;
        while(true){
            if(node != null){
                stack.push(node);
                node = node.left;
            }
            else{
                if(stack.isEmpty()){
                    break;
                }
                node = stack.pop();
                inorder.add(node.val);
                node = node.right;
            }
        }
        return inorder; 
    }
}

BOUNDARY TRAVERSAL OF BINARY TREE

lass Solution
{
    Boolean isLeaf(Node root){
        return (root.left == null) && (root.right == null);
    }
    
    void addLeftBoundary(Node root, ArrayList<Integer> res){
        Node curr = root.left;
        while(curr != null){
            if(isLeaf(curr) == false) res.add(curr.data);
            if(curr.left != null) curr = curr.left;
            else curr = curr.right;
        }
    }
    
    void addRightBoundary(Node root, ArrayList<Integer> res){
        Node curr = root.right;
        ArrayList<Integer> temp = new ArrayList<>();
        while(curr != null){
            if(isLeaf(curr) == false) temp.add(curr.data);
            if(curr.right != null) curr = curr.right;
            else curr = curr.left;
        }
        int i;
        for( i=temp.size() - 1; i >= 0; i--){
            res.add(temp.get(i));
        }
    }
    
    void addLeaves(Node root, ArrayList<Integer> res){
        if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        if(root.left != null) addLeaves(root.left, res);
        if(root.right != null) addLeaves(root.right, res);
    }
    
	ArrayList <Integer> boundary(Node node)
	{
	    ArrayList<Integer> ans = new ArrayList<>();
	    if(isLeaf(node) == false) ans.add(node.data);
	    addLeftBoundary(node, ans);
	    addLeaves(node, ans);
	    addRightBoundary(node, ans);
	    return ans;
	}
}

SYMMETRICAL TREE

class Solution {
    public boolean isSymmetric(TreeNode root) {
         return root==null || isSymmetricHelp(root.left, root.right);
}

private boolean isSymmetricHelp(TreeNode left, TreeNode right){
    if(left==null || right==null)
        return left==right;
    if(left.val!=right.val)
        return false;
    return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);
    }
}



DIAMETER OF BINARY TREE


class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        int[] diameter = new int[1];
        height(root, diameter);
        return diameter[0];
    }
    
    private int height(TreeNode node, int[] diameter){
        if(node == null){
            return 0;
        }
        int lh = height(node.left, diameter);
        int rh = height(node.right, diameter);
        diameter[0] = Math.max(diameter[0], lh+rh);
        return 1+Math.max(lh,rh);
    }
}

SAME TREE

class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
    if(p == null || q == null) return false;
   
        return  p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    
    }
}


ZIGZAG LEVEL ORDER TRAVERSAL


class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
         List<List<Integer>> result = new ArrayList<>();
        if(root==null) return result;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        Boolean flag = true;   // true = left to right;  false = right to left
        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> temp = new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode node = q.poll();
                if(flag == true)
                    temp.add(node.val);
                else
                    temp.add(0,node.val); // 0th index
                if(node.left!=null) q.add(node.left);
                if(node.right!= null) q.add(node.right);
            }
            result.add(temp);
            flag=!flag;
        }
        
        return result;
    }
}

BINARY TREE LEVEL ORDER TRAVERSAL

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
          List<List<Integer>> result = new ArrayList<List<Integer>>();
       
       if(root == null){
          return result;
       }
       
       Queue<TreeNode> queue = new LinkedList<TreeNode>();
       queue.offer(root);
       
       int curL = 0;
       while(!queue.isEmpty()){
           List<Integer> levelRs = new ArrayList<Integer>(); 
           curL = queue.size();
           for(int i=0;i<curL;i++){
               TreeNode peek = queue.poll();
               levelRs.add(peek.val);
               if(peek.left!=null){
                   queue.offer(peek.left);
               }
               if(peek.right!=null){
                   queue.offer(peek.right);
               }
           }
           result.add(levelRs);  // result.add(0, levelRs) <- bottom to up
       }
       
       return result;
    }
}

MAXIMUM WIDTH OF BINARY TREE


class Solution {
    class Pair{
        TreeNode node;
        int index;
        
        Pair(TreeNode node, int index){
            this.node = node;
            this.index = index;
        }
    }
    
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        int ans = 0;
        Queue<Pair> q = new LinkedList<>();
        q.offer(new Pair(root,0));
        while(!q.isEmpty()){
            int size = q.size();
            int mmin = q.peek().index;
            int first = 0, last = 0;
            
            for(int i=0; i<size; i++){
                int curr_id = q.peek().index-mmin;
                TreeNode node = q.peek().node;
                q.poll();
                if(i==0) first = curr_id;
                if(i==size-1) last = curr_id;
                if(node.left != null)
                    q.offer(new Pair(node.left, curr_id*2+1));
                if(node.right != null)
                    q.offer(new Pair(node.right, curr_id*2+2));
            }
            ans=Math.max(ans, last-first+1);
        }
        return ans;
    }
}




SUM OF LEFT LEAF


class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
         if (root == null) {
            return 0;
        }
		
		// Checking if left Node is a leaf node
        if (root.left != null && root.left.left == null && root.left.right == null) {
            return root.left.val + sumOfLeftLeaves(root.right);
        }

		// Exploring the tree further.
        return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
    }
}



SUM ROOT TO LEAF NUMBER

Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.

class Solution {
    public int sumNumbers(TreeNode root) {
        return helper(root, 0);
    }
    
    int helper(TreeNode node, int tempSum){
        if(node==null) return 0;
        
        if(node.left == null && node.right == null){
            return tempSum*10+node.val;
        }
        return helper(node.left, tempSum*10+node.val) + helper(node.right, tempSum*10+node.val);
    }
}


SUM ROOT TO LEAF BINARY NUMBER

class Solution {
    public int sumRootToLeaf(TreeNode root) {
        return helper(root, 0);
    }
    
    int helper(TreeNode node, int tempSum){
        if(node==null) return 0;
        
        if(node.left == null && node.right == null){
            return 2*tempSum+node.val;
        }
        return helper(node.left, 2*tempSum+node.val) + helper(node.right, 2*tempSum+node.val);
    }
}

INVERT BINARY TREE


class Solution {
    public TreeNode invertTree(TreeNode root) {

        
        if(root == null){
            return root;
        }
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()){
            TreeNode temp = q.poll();
            
            //Logic to swap
            TreeNode tempNode = temp.left;
            temp.left = temp.right;
            temp.right = tempNode;
            
            if(temp.left != null)
                q.add(temp.left);
            
            if(temp.right != null)
                q.add(temp.right);
        }
        
        return root;
        
    }
}


COMPLETE TREE NODE


class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) return 0;
        
        int left = leftDepth(root);
	    int right = rightDepth(root);

	if (left == right)
		return ((2 << (left)) - 1);
	else
		return 1+countNodes(root.left) + countNodes(root.right);

}

private int rightDepth(TreeNode root) {
	// TODO Auto-generated method stub
	int dep = 0;
	while (root.right != null) {
        dep++;
		root = root.right;
		
	}
	return dep;
}

private int leftDepth(TreeNode root) {
	// TODO Auto-generated method stub
	int dep = 0;
	while (root.left != null) {
        dep++;
		root = root.left;
		
	}
	return dep;
    }
}






COUSINS IN BINARY TREE

class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        if(root == null) return false;
        Queue<TreeNode> q = new LinkedList<>();
        TreeNode xParent = null, yParent = null;
        q.offer(root);
        
        while(!q.isEmpty()){
            int size = q.size();
            while(size-- > 0){
                TreeNode head = q.poll();
                if(head.left != null){
                    q.offer(head.left);
                    if(head.left.val == x){
                        xParent = head;
                    }
                     if(head.left.val == y){
                        yParent = head;
                    }
                }
                if(head.right != null){
                    q.offer(head.right);
                    if(head.right.val == x){
                        xParent = head;
                    }
                     if(head.right.val == y){
                        yParent = head;
                    }
                }
                
                if(xParent != null && yParent != null){
                    return xParent != yParent;
                }
            }
            
            if((xParent == null && yParent != null) || (xParent != null && yParent == null)){
              return false;  
            } 
        }
        
        return false;
    }
}

PATH SUM 3


class Solution {
   private int ans = 0;
    public int pathSum(TreeNode root, int targetSum) {
        if(root == null) return 0;
        helper(root, targetSum);
        pathSum(root.left, targetSum);
        pathSum(root.right, targetSum);
        return ans;
    }
    
    public void helper(TreeNode root, int sum){
        if(root == null) return;
        if(sum == root.val) ans++;
        sum = sum - root.val;
        helper(root.left, sum);
        helper(root.right, sum);
    }
}



CONSTRUCT TREE FROM PREODER AND INORDER TRAVERSAL


class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        HashMap<Integer, Integer> map = new HashMap<>();
        
        for(int i=0; i< inorder.length; i++){
            map.put(inorder[i], i);
        }
        
        
        TreeNode root =  helper(preorder, 0, preorder.length-1, inorder, 0, inorder.length - 1, map );
        return root;
}

public TreeNode helper( int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, HashMap<Integer, Integer> map  ) {
    
    if (preStart > preEnd || inStart > inEnd) {
        return null;
    }
    
    TreeNode root = new TreeNode(preorder[preStart]);
    int inRoot = map.get(root.val);
    int numsLeft = inRoot - inStart;
    
    
    root.left = helper(preorder, preStart + 1, preStart + numsLeft, inorder,  inStart, inRoot - 1, map);
    root.right = helper(preorder, preStart + numsLeft  + 1, preEnd, inorder,  inRoot + 1, inEnd, map);
    return root;
    }
}


CONSTRUCT TREE FROM INORDER AND POSTORDER TRAVERSAL


class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder == null || postorder == null || inorder.length != postorder.length) return null;
        
        HashMap<Integer, Integer> map = new HashMap<>();
        
        for(int i=0; i< inorder.length; i++){
            map.put(inorder[i], i);
        }
        
        
        TreeNode root =  helper(inorder, 0, inorder.length-1, postorder, 0, postorder.length - 1, map );
        return root;
}

public TreeNode helper( int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd, HashMap<Integer, Integer> map  ) {
    
    if (inStart > inEnd || postStart > postEnd) {
        return null;
    }
    
    TreeNode root = new TreeNode(postorder[postEnd]);
    
    int inRoot = map.get(root.val);
    int numsLeft = inRoot - inStart;
    
    
    root.left = helper(inorder, inStart, inRoot - 1, postorder, postStart, postStart + numsLeft -1, map);
    root.right = helper(inorder, inRoot + 1, inEnd, postorder,  postStart + numsLeft, postEnd - 1, map);
    return root;
    }
}


CONSTRUCT TREE FROM INORDER AND LEVELORDER

class GfG
{
    public Node buildtree(int[] inorder, int isi, int iei, int[] level){
        int mod = 100000000;
        if(isi > iei) return null;
        
        Node root = new Node(level[0]);
        if(level.length == 1) return root;
        
        int idx = isi;
        while(inorder[idx] != root.data) idx++;
        
        HashSet<Integer> set = new HashSet<>();
        for(int i= isi; i < idx; i++) set.add(inorder[i]);
        
        int[] lofls = new int[idx - isi];  // level order for left subtree
        int[] lofrs = new int[iei - idx];
        int ls=0, rs=0;
        
        for(int i= 1; i< level.length; i++){
            int ele = level[i];
            if(set.size() != 0 && set.contains(ele)){
                lofls[ls++] =ele;
                set.remove(ele);
            } else {
                lofrs[rs++] = ele;
            }
        }
        
        root.left = buildtree(inorder, isi, idx-1, lofls);
        root.right = buildtree(inorder, idx+1, iei, lofrs);
        
        return root;
    }
    Node buildTree(int inord[], int level[])
    {
        int n = inord.length;
        return buildtree(inord, 0, n-1, level);
    }
    
   
}



CONSTRUCT TREE FROM PREORDER AND POSTORDER TRAVERSAL

class Solution {
    public TreeNode constructFromPrePost_(int[] pre, int psi, int pei, int[] post, int ppsi, int ppei){
        if(psi > pei)
            return null;
        
        TreeNode root = new TreeNode(pre[psi]);
        if(psi == pei) return root;
        
        int idx = ppsi;
        while(post[idx] != pre[psi + 1]) idx++;
        
        int tnel = idx - ppsi + 1;
        
        root.left = constructFromPrePost_(pre, psi + 1, psi + tnel, post, ppsi, idx);
        root.right = constructFromPrePost_(pre, psi + tnel + 1, pei, post, idx + 1, ppei - 1);
        
        return root;
    }
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        int n = preorder.length;
        return constructFromPrePost_(preorder, 0, n-1, postorder, 0, n-1);
    }
}






 

2. GET SUM OF ALL NODES

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    System.out.print("Total Sum: " + a.getSumOfNodes(root));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
	  
		public int getSumOfNodes(Node node) {
		    if (node == null) {
		      return 0;
		    }

		    return node.data + getSumOfNodes(node.left) + getSumOfNodes(node.right);
		  }

		
    public Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

3. GET NO. OF NODES

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    System.out.print("Total Nodes: " + a.getNumberOfNodes(root));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
	  
		public int getNumberOfNodes(Node node) {
		    if (node == null) {
		      return 0;
		    }

		    return 1 + getNumberOfNodes(node.left) + getNumberOfNodes(node.right);
		  }
		
		
		Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

4. GET NUMBER OF LEAF NODES 

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    System.out.print("Total Number of LeafNodes: " + a.getNumberOfLeafNodes(root));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
	  
		public int getNumberOfLeafNodes(Node node) {
		    if (node == null) {
		      return 0;
		    }
		    
		    if (node.left == null && node.right == null) {
			      return 1;
			    }

		    return  getNumberOfLeafNodes(node.left) + getNumberOfLeafNodes(node.right);
		  }
		
		
		Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 
5. GET HEIGHT OF A TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    System.out.print("Total Height of tree: " + a.getHeightOfTree(root));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
	  
		 public int getHeightOfTree(Node node) {
			    if (node == null) {
			      return -1;
			    }
			    
			    return Math.max(getHeightOfTree(node.left), getHeightOfTree(node.right)) + 1;
			  }
		
		
		Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

6. PRINT ELEMENTS AT GIVEN LEVEL

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    a.printAtGivenLevel(root, 4);
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
	  
		public void printAtGivenLevel(Node node, int level) {
		    if (node == null) {
		      return;
		    }
		    
		    if(level == 1) {
		      System.out.print(node.data + " ");
		      return;
		    }
		    
		    printAtGivenLevel(node.left, level - 1);
		    printAtGivenLevel(node.right, level - 1);
		  }
		
		
		Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

7. PRINT ELEMENTS IN LEVEL ORDER USING RECURSION

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    a.levelOrderTraversalUsingRecursion(root);
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
	  
		public void levelOrderTraversalUsingRecursion(Node node) {
		    if (node == null) {
		      return;
		    }
		    
		    int height = getHeightOfTree(node);
		    
		    for(int i = 0; i <= height; i++) {
		      printAtGivenLevel(node, i + 1);
		      System.out.println();
		    }
		  }
		  
		  public int getHeightOfTree(Node node) {
		    if(node == null){
		      return -1;
		    }
		    
		    return Math.max(getHeightOfTree(node.left), getHeightOfTree(node.right)) + 1;
		  }
		  
		  public void printAtGivenLevel(Node node, int level) {
		    if(node == null) {
		      return;
		    }
		    
		    if(level == 1) {
		      System.out.print(node.data + " ");
		      return;
		    }
		    
		    printAtGivenLevel(node.left, level - 1);
		    printAtGivenLevel(node.right, level - 1);
		  }
		  
		
		
		Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

8. PRINT ELEMENTS IN LEVEL ORDER USING QUEUE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    a.levelOrderTraversalUsingQueueLineByLine(root);
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
	  
		public void levelOrderTraversalUsingQueueLineByLine(Node node) {
		    if(node == null) {
		      return;
		    }
		    
		    Queue<Node> a = new LinkedList<Node>();
		    a.add(node);
		    
		    while(true) {
		      
		      int queueSize = a.size();
		      if(queueSize == 0) {
		        break;
		      }
		      
		      while(queueSize > 0) {
		        
		        Node temp = a.peek();
		        System.out.print(temp.data + " ");
		        
		        a.remove();

		        if(temp.left != null) {
		          a.add(temp.left);
		        }
		        
		        if(temp.right != null) {
		          a.add(temp.right);
		        }
		        
		        queueSize--;
		      }
		      
		      System.out.println();
		    }
		  }
		
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 




 

9. REVERSE LEVEL ORDER TRAVERSAL USING QUEUE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    a.reverselevelOrderTraversalUsingQueue(root);
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
	  
		 public void reverselevelOrderTraversalUsingQueue(Node node) {
			    if (node == null) {
			      return;
			    }

			    Queue<Node> q = new LinkedList<Node>();
			    q.add(node);
			    
			    Stack<Node> s = new Stack<Node>();

			    while (!q.isEmpty()) {

			      Node top = q.remove();
			  

			      if (top.left != null) {
			        q.add(top.left);
			      }

			      if (top.right != null) {
			        q.add(top.right);
			      }
			      s.push(top);
			    }
			    
			    while(s.size() > 0) {
			    	System.out.print(s.pop().data + " ");
			    }
			  }
		
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

9. LEFT VIEW OF BINARY TREE


RECURSIVE LEVEL

   List<Integer> result = new ArrayList<>();
   leftView(root, result, 0);
   return result;

 
    public void leftView(Node node, List<Integer> result, int level) {
      if(node == null) return;

           if(level == result.size()) result.add(node.val);

             leftView(node.left, result, level + 1);
              leftView(node.right, result, level + 1);


// RIGHT VIEW
 rightView(node.right, result, level + 1);
              rightView(node.left, result, level + 1);
}



	 
11. TOP VIEW OF BINARY TREE

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	 public static void main(String[] args) {

		    BinaryTree a = new BinaryTree();

		    Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(5);
		    root.left.right = a.createNewNode(6);
		    root.left.right.left = a.createNewNode(5);
		    root.left.right.left.left = a.createNewNode(10);
		    root.left.right.right = a.createNewNode(11);
		    root.right.right = a.createNewNode(9);
		    
		    a.topView(root);
		  }
}

	class Node {
		  Node left;
		  Node right;
		  int data;
		  int height;
		}

		class Solution
{
   static class Pair{
        Node node;
        int hd;
       
        
        Pair( Node node,int hd){
            this.node = node;
            this.hd = hd;
            
        }
    }
    
    static ArrayList<Integer> topView(Node node)
    {
                ArrayList<Integer> res = new ArrayList<>();
         if (node == null) {
				      return res;
				    }
          
				    TreeMap<Integer, Integer> m = new TreeMap<Integer, Integer>();  // line, node.val


				    Queue<Pair> q = new LinkedList<>();
                    
				    q.add(new Pair(node, 0));

				    while (!q.isEmpty()) {
				      Pair it = q.remove();
				      int hd = it.hd;
				      Node temp = it.node;
				      
				 
				      if(m.get(hd) == null)  m.put(hd, temp.data);
				      

				      if (temp.left != null) {
				       
				        q.add(new Pair(temp.left, hd -1));
				      }

				      if (temp.right != null) {
				         q.add(new Pair(temp.right, hd  + 1));
				      }
				    }
				   for(Map.Entry<Integer, Integer> entry: m.entrySet()) {
				        res.add(entry.getValue());
				    }
				  
				    return res;
        
    }
}

		 
	  }
		          	                    
	  
	    
	 
	   
12. BOTTOM VIEW OF BINARY TREE



		class Solution
{
    class Pair{
        Node node;
        int hd;
       
        
        Pair( Node node,int hd){
            this.node = node;
            this.hd = hd;
            
        }
    }
    public ArrayList <Integer> bottomView(Node node)
    {
        ArrayList<Integer> res = new ArrayList<>();
         if (node == null) {
				      return res;
				    }
          
				    TreeMap<Integer, Integer> m = new TreeMap<Integer, Integer>();  // line, node.val


				    Queue<Pair> q = new LinkedList<>();
                    
				    q.add(new Pair(node, 0));

				    while (!q.isEmpty()) {
				      Pair it = q.remove();
				      int hd = it.hd;
				      Node temp = it.node;
				      
				 
				       m.put(hd, temp.data);
				      

				      if (temp.left != null) {
				       
				        q.add(new Pair(temp.left, hd -1));
				      }

				      if (temp.right != null) {
				         q.add(new Pair(temp.right, hd  + 1));
				      }
				    }
				   for(Map.Entry<Integer, Integer> entry: m.entrySet()) {
				        res.add(entry.getValue());
				    }
				  
				    return res;
    }
}
			

FLATTEN A BINARY TREE TO LINKED LIST


class Solution {
    public void flatten(TreeNode root) {
        TreeNode cur = root;
        
        while(cur != null){
            
            if(cur.left != null){
                TreeNode pre = cur.left;
                
                while(pre.right != null){
                    pre = pre.right;
                }
                
                pre.right = cur.right;
                cur.right = cur.left;
                cur.left = null;
            }
            cur = cur.right;
        }
    }
}	 






 15. MIRROR/ INVERT BINARY TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    

	   System.out.println(a.invertbinarytree(root));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
	
	  
		public Node invertbinarytree(Node node) {
			
		
		if(node == null) 
		      return node;
		    
		
		    
		    Queue<Node> a = new LinkedList<Node>();
		    a.add(node);
		    
		  
		      
		      while(!a.isEmpty()) {
		        
		       Node temp = a.poll();
		       
		       Node tempnode = temp.left;
		       temp.left = temp.right;
		       temp.right = tempnode;

		        if(temp.left != null) {
		          a.add(temp.left);
		        }
		        
		        if(temp.right != null) {
		          a.add(temp.right);
		        }
		        
		      } 
		      return node;
		}
		      
		
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

2ND APPROACH

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    

	 Node mirror =  a.invertbinarytree(root);
	 a.inorderUsingStack(mirror);
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public void inorderUsingStack(Node node) {
			    if(node == null) {
			      return;
			    }
			    
			    Stack<Node> s = new Stack<Node>();
			    while(node != null) {
			      s.push(node);
			      node = node.left;
			    }
			    
			    while(s.size() > 0) {
			      Node t = s.pop();
			      System.out.print(t.data + " ");
			      if(t.right != null) {
			        Node tmp = t.right;
			        while(tmp != null) {
			          s.push(tmp);
			          tmp = tmp.left;
			        }
			      }
			    }
			  }
		
	  
		public Node invertbinarytree(Node node) {
			
		
		if(node == null) 
		      return null;
		    
		
		    
		  Node t = node.left;
		  node.left = node.right;
		  node.right = t;
		  
		  invertbinarytree(node.left);
		  invertbinarytree(node.right);
		  
		  return node;
		}
		      
		
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 
3RD APPROACH

public void postOrderItrOneStack(Node root){
        Node current = root;
        Deque<Node> stack = new LinkedList<>();
        while(current != null || !stack.isEmpty()){
            if(current != null){
                stack.addFirst(current);
                current = current.left;
            }else{
                Node temp = stack.peek().right;
                if (temp == null) {
                    temp = stack.poll();
                    System.out.print(temp.data + " ");
                    while (!stack.isEmpty() && temp == stack.peek().right) {
                        temp = stack.poll();
                        System.out.print(temp.data + " ");
                    }
                } else {
                    current = temp;
                }
            }
        }
    }



 

17. CHECK IF TWO BINARY TREE ARE IDENTICAL

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    Node root1 = a.createNewNode(2);
	    root1.left = a.createNewNode(7);
	    root1.right = a.createNewNode(5);
	    root1.left.left = a.createNewNode(2);
	    root1.left.right = a.createNewNode(6);
	    root1.left.right.left = a.createNewNode(5);
	    root1.left.right.right = a.createNewNode(11);
	    root1.right.right = a.createNewNode(9);
	    root1.right.right.left = a.createNewNode(4);
	    

	System.out.println(a.isSame(root, root1));
	
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public static boolean isSame(Node p, Node q) {
			 
		       //If both the trees are empty, then return true
		       if(p == null && q == null) {
		           return true;
		 
		       } else if(p == null || q == null) {
		           return false;
		 
		       }
		 
		       //Declare two queues
		       Queue<Node> qu1 = new LinkedList<>();
		       Queue<Node> qu2 = new LinkedList<>();
		 
		       qu1.add(p);
		       qu2.add(q);
		 
		      while(!qu1.isEmpty() && !qu2.isEmpty()) {
		 
		          Node temp1 = qu1.poll();
		          Node temp2 = qu2.poll();
		 
		          //If node value is not same
		         if(temp1.data != temp2.data) {
		             return false;
		         }
		 
		          //Add left children
		         if(temp1.left != null && temp2.left != null) {
		              qu1.add(temp1.left);
		              qu2.add(temp2.left);
		 
		          } else if(temp1.left != null || temp2.left != null) {
		               return false;
		 
		           }
		 
		            //Add right children
		           if(temp1.right != null && temp2.right != null) {
		                 qu1.add(temp1.right);
		                 qu2.add(temp2.right);
		 
		           } else if(temp1.right != null || temp2.right != null){
		                  return false;
		 
		            } 
		 
		        }
		 
		        return true;
		   }
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

   2ND APPROACH ( RECURSIVE )

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    Node root1 = a.createNewNode(2);
	    root1.left = a.createNewNode(7);
	    root1.right = a.createNewNode(5);
	    root1.left.left = a.createNewNode(2);
	    root1.left.right = a.createNewNode(6);
	    root1.left.right.left = a.createNewNode(5);
	    root1.left.right.right = a.createNewNode(11);
	    root1.right.right = a.createNewNode(9);
	    root1.right.right.left = a.createNewNode(4);
	    

	System.out.println(a.isSame(root, root1));
	
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public static boolean isSame(Node p, Node q) {
			 
		       //If both the trees are empty, then return true
		       if(p == null && q == null) {
		           return true;
		 
		       } else if(p == null || q == null) {
		           return false;
		 
		       } else if(p.data != q.data) {
		    	   return false;
		       } else {
		    	   return isSame(p.left, q.left) && isSame(p.right, q.right);
		       }
		 
		   }
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }


 

18. GET LEVEL OF A GIVEN NODE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    

	    System.out.println(a.getLevelOfNode(root, 7, 1));
	
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public int getLevelOfNode(Node node, int val, int level) {
			    if(node == null) {
			      return 0;
			    }
			    
			    int l;
			    
			    if(node.data == val) {
			      return level;
			    }
			    
			    l = getLevelOfNode(node.left, val, level + 1);
			    
			    if(l != 0) {
			      return l;
			    }
			    
			    l = getLevelOfNode(node.right, val, level + 1);
			    
			    return l;
			  }
			  
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
 }





 




 

22. GET SUM OF ELEMENTS LEVEL WISE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    a.SumlevelOrderTraversalUsingQueueLineByLine(root);
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public void SumlevelOrderTraversalUsingQueueLineByLine(Node node) {
		    if(node == null) {
		      return;
		    }
		    
		    Queue<Node> a = new LinkedList<Node>();
		    a.add(node);
		    
		    while(true) {
		      
		      int queueSize = a.size();
		      if(queueSize == 0) {
		        break;
		      }
		      
		      int sum = 0;
		      while(queueSize > 0) {
		        
		        Node temp = a.remove();
		        sum = sum + temp.data;

		        if(temp.left != null) {
		          a.add(temp.left);
		        }
		        
		        if(temp.right != null) {
		          a.add(temp.right);
		        }
		        
		        queueSize--;
		      }
		      
		      System.out.println(sum);
		    }
		  
		
	}
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }

	 



24. SEARCH ELEMENT IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    System.out.println(a.recursiveSearch(root, 100));
	    System.out.println(a.iterativeSearch(root, 11));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public boolean recursiveSearch(Node node, int key) {
		    if(node == null) {
		      return false;
		    }
		    
		    if(node.data == key) {
		      return true;
		    }
		    
		    return recursiveSearch(node.left, key) || recursiveSearch(node.right, key);
		  }
		  
		  public boolean iterativeSearch(Node node, int key) {
		    if (node == null) {
		      return false;
		    }

		    Queue<Node> q = new LinkedList<Node>();
		    q.add(node);

		    while (!q.isEmpty()) {
		      Node t = q.remove();
		      if (t.data == key) {
		        return true;
		      }

		      if (t.left != null) {
		        q.add(t.left);
		      }

		      if (t.right != null) {
		        q.add(t.right);
		      }
		    }

		    return false;
		  }
		  
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 



 

26. PRINT ELEMENTS BETWEEN ANY 2 GIVEN LEVELS

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    
	    a.printBetweenTwoLevels(root, 2, 3);
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public void printBetweenTwoLevels(Node node, int min, int max) {
		    if (node == null) {
		      return;
		    }

		    Queue<Node> q = new LinkedList<Node>();
		    q.add(node);
		    int l = 1;

		    while (true) {
		      int size = q.size();
		      if (size == 0 || l > max) {
		        break;
		      }
		      while (size > 0) {
		        Node t = q.remove();
		        if (l >= min && l <= max) {
		          System.out.print(t.data + " ");
		        }
		        if (t.left != null) {
		          q.add(t.left);
		        }

		        if (t.right != null) {
		          q.add(t.right);
		        }

		        size--;
		      }
		      l++;
		    }
		  }
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

27. CHECK IF TWO TREES ARE MIRROR TO EACH OTHER

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root1 = a.createNewNode(2);
	    root1.left = a.createNewNode(7);
	    root1.right = a.createNewNode(8);
	    root1.left.left = a.createNewNode(5);

	    Node root2 = a.createNewNode(2);
	    root2.left = a.createNewNode(8);
	    root2.right = a.createNewNode(7);
	    root2.right.right = a.createNewNode(5);

	    System.out.println(a.ifMirrorTree(root1, root2));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public boolean ifMirrorTree(Node node1, Node node2) {
			    if (node1 == null && node2 == null) {
			      return true;
			    }

			    if (node1 == null || node2 == null) {
			      return false;
			    }

			    return node1.data == node2.data 
			        && ifMirrorTree(node1.left, node2.right) 
			        && ifMirrorTree(node1.right, node2.left);
			  }
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

27. CHECK IF TWO TREES ARE MIRROR STRUCTURE TO EACH OTHER  && FOLDABLE OR NOT

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root1 = a.createNewNode(2);
	    root1.left = a.createNewNode(7);
	    root1.right = a.createNewNode(8);
	    root1.left.left = a.createNewNode(5);

	    Node root2 = a.createNewNode(2);
	    root2.left = a.createNewNode(8);
	    root2.right = a.createNewNode(7);
	    root2.right.right = a.createNewNode(5);

	    System.out.println(a.ifMirrorStructureTree(root1, root2));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public boolean ifMirrorStructureTree(Node node1, Node node2) {
			    if (node1 == null && node2 == null) {
			      return true;
			    }

			    if (node1 == null || node2 == null) {
			      return false;
			    }

			    return  
			         ifMirrorStructureTree(node1.left, node2.right) 
			        && ifMirrorStructureTree(node1.right, node2.left);
			  }
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

28. CHECK IF TWO BINARY TREE HAVE SAME STRUCTURE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root1 = a.createNewNode(2);
	    root1.left = a.createNewNode(7);
	    root1.right = a.createNewNode(8);
	    root1.left.left = a.createNewNode(5);

	    Node root2 = a.createNewNode(2);
	    root2.left = a.createNewNode(8);
	    root2.right = a.createNewNode(7);
	    root2.right.right = a.createNewNode(5);

	    System.out.println(a.ifsameStructureTree(root1, root2));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public boolean ifsameStructureTree(Node node1, Node node2) {
			    if (node1 == null && node2 == null) {
			      return true;
			    }

			    if (node1 == null || node2 == null) {
			      return false;
			    }

			    return  
			    		ifsameStructureTree(node1.left, node2.left) 
			        && ifsameStructureTree(node1.right, node2.right);
			  }
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

29. FOLDABLE OR NOT

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root1 = a.createNewNode(2);
	    root1.left = a.createNewNode(7);
	    root1.right = a.createNewNode(8);
	    root1.left.left = a.createNewNode(5);



	    System.out.println(a.ifFoldableTree(root1));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public boolean ifFoldableTree(Node node) {
		    if (node == null) {
		      return true;
		    }

		    return ifMirrorStructure(node.left, node.right);
		  }

		  public boolean ifMirrorStructure(Node node1, Node node2) {
		    if (node1 == null && node2 == null) {
		      return true;
		    }

		    if (node1 == null || node2 == null) {
		      return false;
		    }

		    return ifMirrorStructure(node1.left, node2.right) && ifMirrorStructure(node1.right, node2.left);
		  }

		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

30. CHECK IF TWO TREE ARE ISOMORPHIC

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root1 = a.createNewNode(2);
	    root1.left = a.createNewNode(7);
	    root1.left.left = a.createNewNode(5);
	    root1.right = a.createNewNode(8);
	    
	    Node root2 = a.createNewNode(2);
	    root2.left = a.createNewNode(7);
	    root2.left.right = a.createNewNode(5);
	    root2.right = a.createNewNode(8);
	    
	    System.out.println(a.ifIsomorphic(root1, root2));
	  }
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public boolean ifIsomorphic(Node node1, Node node2) {  
			    if (node1 == null && node2 == null) {
			      return true;
			    }

			    if (node1 == null || node2 == null) {
			      return false;
			    }

			    if (node1.data != node2.data) {
			      return false;
			    }

			    return (ifIsomorphic(node1.left, node2.left) && ifIsomorphic(node1.right, node2.right))
			        || (ifIsomorphic(node1.left, node2.right) && ifIsomorphic(node1.right, node2.left));
			  }

		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

31. GET WIDTH OF A LEVEL IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(12);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    root.right.right.right = a.createNewNode(40);
	    
	    System.out.println(a.getWidthOfLevel(root, 3));
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public int getWidthOfLevel(Node node, int level) {
		    if (node == null) {
		      return 0;
		    }

		    if (level == 1) {
		      return 1;
		    }

		    return getWidthOfLevel(node.left, level - 1) + getWidthOfLevel(node.right, level - 1);
		  }
		    
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

32. CREATE DOUBLE TREE OF GIVEN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
	    BinaryTree a = new BinaryTree();
	    
	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    
	    a.doubleTree(root);
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public void doubleTree(Node node) {
			    if (node == null) {
			      return;
			    }

			    doubleTree(node.left);
			    doubleTree(node.right);

			    Node newNode = createNewNode(node.data);
			    newNode.left = node.left;
			    node.left = newNode;
			  }
			  
			
			
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 



 

34. GET HEIGHT OF A BINARY TREE USING ITERATIVE MANNER

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(12);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.right.right = a.createNewNode(9);
	    root.right.right.left = a.createNewNode(4);
	    root.right.right.right = a.createNewNode(40);
	    
	    System.out.println(a.heightIteratively(root));
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public int heightIteratively(Node node) {
			    if (node == null) {
			      return 0;
			    }

			    Queue<Node> q = new LinkedList<Node>();
			    q.add(node);
			    int height = 0;      // root to leaf node

			    while (true) {
			      int size = q.size();
			      if (size == 0) {
			        break;
			      }

			      while (size > 0) {
			        Node t = q.remove();
			        if (t.left != null) {
			          q.add(t.left);
			        }

			        if (t.right != null) {
			          q.add(t.right);
			        }
			        
			        size--;
			      }
			      
			      height = height + 1;
			    }
			    return height;
			  }
		 
		 
		 
		 // 2nd approach

			  public int height(Node node) {
			    if(node == null) {
			      return -1;
			    }
			    
			    return Math.max(height(node.left), height(node.right)) + 1;
			  }
			
			
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }



 

36. CHECK IF A GIVEN TREE IS HEIGHT BALANCED

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(5);
	    root.left.left = a.createNewNode(12);
	    root.left.left.left = a.createNewNode(1);
	    root.left.left.left.right = a.createNewNode(10);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);
	    root.left.right.right.right = a.createNewNode(13);
	    
	    System.out.println(a.ifHeightBalancedTree(root) != -1);
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public int ifHeightBalancedTree(Node node) {
		    if (node == null) {
		      return 0;
		    }
		    
		    if(node.left == null && node.right == null) {
		      return 1;
		    }

		    int lH = ifHeightBalancedTree(node.left);
		    int rH = ifHeightBalancedTree(node.right);
		    
		    if(lH == -1 || rH == -1 || Math.abs(lH - rH) > 1) {
		      return -1;
		    }

		    return Math.max(lH, rH) + 1;
		  }
		  
			
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

37. CHECK IF ROOT- TO - LEAF SUM MATCHES FOR GIVEN VALUE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(5);
		    root.left.left = a.createNewNode(12);
		    
		    System.out.println(a.ifRootToLeafPathSumMatches(root, 21));
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public boolean ifRootToLeafPathSumMatches(Node node, int total) {
		    if (node == null) {
		      return false;
		    }

		    if (node.left == null && node.right == null && total == node.data)
		      return true;

		    return ifRootToLeafPathSumMatches(node.left, total - node.data)
		        || ifRootToLeafPathSumMatches(node.right, total - node.data);
		  }
		  
		
		  
			
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 


 

39. GET MAX SUM FROM ROOT-TO-LEAF IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(5);
		    root.left.left = a.createNewNode(2);
		    root.left.right = a.createNewNode(6);
		    root.left.right.left = a.createNewNode(5);
		    root.left.right.right = a.createNewNode(11);
		    root.right.right = a.createNewNode(9);
		    root.right.right.left = a.createNewNode(4);

		    a.maxSumFromRootToLeaf(root, 0);
		    System.out.println(a.maxSum);
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		int maxSum;

		  public void maxSumFromRootToLeaf(Node node, int sum) {
		    if (node == null) {
		      return;
		    }

		    if (node.left == null && node.right == null && sum + node.data > maxSum) {
		      maxSum = sum + node.data;
		      return;
		    }

		    maxSumFromRootToLeaf(node.left, sum + node.data);
		    maxSumFromRootToLeaf(node.right, sum + node.data);
		  }
			
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 




 




 

42. FIND MIN HEIGHT OF TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(9);
		    root.left.left = a.createNewNode(2);
		    root.left.right = a.createNewNode(6);
		    root.left.right.left = a.createNewNode(5);
		    root.left.right.right = a.createNewNode(11);
		    
		    System.out.println(a.findMinHeightLevelwise(root));
		    
		    a.findMinHeightRecursive(root, 1);
		    System.out.println(a.minHeight);
		    
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public int findMinHeightLevelwise(Node node) {
		    if (node == null) {
		      return 0;
		    }
		    
		    int height = 1;
		    
		    Queue<Node> queue = new LinkedList<>();
		    queue.add(node);
		    
		    while(true) {
		      int size = queue.size();
		      
		      if(queue.isEmpty() || size == 0) {
		        break;
		      }
		      
		      while(size > 0) {
		        Node temp = queue.remove();
		        
		        if(temp.left == null && temp.right == null) {
		          return height;
		        }
		        
		        if(temp.left != null) {
		          queue.add(temp.left);
		        } 
		        
		        if(temp.right != null) {
		          queue.add(temp.right);
		        } 
		        
		        size--;
		      }
		      
		      height++;
		    }
		    
		    return height;
		  }
		  
		
		// 2nd APPROACH
		  
		  int minHeight = Integer.MAX_VALUE;
		  public void findMinHeightRecursive(Node node, int height) {
		    if(node == null) {
		      return;
		    }
		    
		    if(node.left == null && node.right == null && height < minHeight) {
		      minHeight = height;
		    }
		    
		    findMinHeightRecursive(node.left, height + 1);
		    findMinHeightRecursive(node.right, height + 1);
		  }

		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

43. GET SUM OF ALL LEAF NODES IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();


	    Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(9);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);

	    System.out.println(a.sumOfLeafNodes(root));
		    
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public int sumOfLeafNodes(Node node) {
		    if (node == null) {
		      return 0;
		    }

		    if (node.left == null && node.right == null) {
		      return node.data;
		    }

		    return sumOfLeafNodes(node.left) + sumOfLeafNodes(node.right);
		  }


		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

44. GET SUM OF ALL LEFT LEAF NODE IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();


		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(9);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);

	    System.out.println(a.sumOfLeftLeafNodes(root, false));

	    a.sumOfLeftLeafNodesAnother(root, false);
	    System.out.println(a.sumOfLeftLeafNode);
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public int sumOfLeftLeafNodes(Node node, boolean ifLeftLeaf) {
		    if (node == null) {
		      return 0;
		    }

		    if (node.left == null && node.right == null && ifLeftLeaf) {
		      return node.data;
		    }

		    return sumOfLeftLeafNodes(node.left, true) + sumOfLeftLeafNodes(node.right, false);
		  }

		  int sumOfLeftLeafNode;

		  public void sumOfLeftLeafNodesAnother(Node node, boolean ifLeftLeaf) {
		    if (node == null) {
		      return;
		    }

		    if (node.left == null && node.right == null && ifLeftLeaf) {
		      sumOfLeftLeafNode = sumOfLeftLeafNode + node.data;
		    }

		    sumOfLeftLeafNodesAnother(node.left, true);
		    sumOfLeftLeafNodesAnother(node.right, false);
		  }


		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

45. CHECK IF ALL LEAF NODE ARE AT SAME LEVEL

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();


		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(9);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);

	    System.out.println(a.ifLeavesAtSameLevel(root, 1));
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		int levelOfLeaf;

		  public boolean ifLeavesAtSameLevel(Node node, int level) {
		    if (node == null) {
		      return true;
		    }

		    if (node.left == null && node.right == null) {
		      if (levelOfLeaf == 0) {
		        levelOfLeaf = level;
		        return true;
		      }

		      return levelOfLeaf == level;
		    }

		    return ifLeavesAtSameLevel(node.left, level + 1) && ifLeavesAtSameLevel(node.right, level + 1);
		  }

		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

46. DEEPEST LEFT LEAF NODE IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();


		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(9);
	    root.left.left = a.createNewNode(2);
	    root.left.right = a.createNewNode(6);
	    root.left.right.right = a.createNewNode(11);

	    a.deepestLeftLeafNode(root, 1, false);
	    
	    if(a.deepestLeftLeafNode != null) {
	      System.out.println(a.deepestLeftLeafNode.data);
	    } else {
	      System.out.println("Deepest Left Leaf Node is Null");
	    }
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 Node deepestLeftLeafNode;
		  int currentLevel;

		  public void deepestLeftLeafNode(Node node, int level, boolean ifLeft) {
		    if (node == null) {
		      return;
		    }

		    if ( node.left == null && node.right == null && ifLeft  && level > currentLevel) {
		      deepestLeftLeafNode = node;
		      currentLevel = level;
		    }

		    deepestLeftLeafNode(node.left, level + 1, true);
		    deepestLeftLeafNode(node.right, level + 1, false);
		  }
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

47. Find deepest Odd level which contains Leaf node in Binary Tree

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();


		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(9);
		    root.left.left = a.createNewNode(2);
		    root.left.right = a.createNewNode(6);
		    root.left.right.right = a.createNewNode(11);

		    a.depthDeepestOddLevelNodeSecond(root, 1);
		    
		    System.out.println(a.depthDeepestOldLevelNode);
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		int depthDeepestOldLevelNode;

		  public void depthDeepestOddLevelNodeSecond(Node node, int level) {
		    if (node == null) {
		      return;
		    }

		    if (node.left == null && node.right == null && (level % 2 != 0) && (level > depthDeepestOldLevelNode)) {
		      depthDeepestOldLevelNode = level;
		    }

		    depthDeepestOddLevelNodeSecond(node.left, level + 1);
		    depthDeepestOddLevelNodeSecond(node.right, level + 1);
		  }
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

48. REMOVE ALL NODES WHICH LIE ON PATH WITH LESS THAN K-LENGTH FROM ROOT-TO-LEAF

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();


		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(9);
		    root.left.left = a.createNewNode(2);
		    root.left.right = a.createNewNode(6);
		    root.left.right.right = a.createNewNode(11);

		    root = a.removeNodesLessThanKLength(root, 3, 1);
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public Node removeNodesLessThanKLength(Node node, int k, int level) {
			    if (node == null) {
			      return null;
			    }

			    node.left = removeNodesLessThanKLength(node.left, k, level + 1);
			    node.right = removeNodesLessThanKLength(node.right, k, level + 1);

			    if (node.left == null && node.right == null && level < k) {
			      return null;
			    }

			    return node;
			  }
		 
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

49. REMOVE NODES WHICH DON'T LIE IN ANY PATH FROM ROOT-TO-LEAF WITH SUM GREATER THAN K

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();


		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(9);
		    root.left.left = a.createNewNode(2);
		    root.left.right = a.createNewNode(6);
		    root.left.right.right = a.createNewNode(11);

		    root = a.removeAllNodesIfSumGreaterThanK(root, 13, 0);
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public Node removeAllNodesIfSumGreaterThanK(Node node, int k, int s) {
			    if (node == null) {
			      return null;
			    }

			    node.left = removeAllNodesIfSumGreaterThanK(node.left, k, s + node.data);
			    node.right = removeAllNodesIfSumGreaterThanK(node.right, k, s + node.data);

			    if (node.left == null && node.right == null && (s + node.data) < k) {
			      return null;
			    }

			    return node;
			  }
		 
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

50. FIND IF GIVEN SEQUENCE IS PRESENT AS A ROOT-TO-LEAF PATH IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();


		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(9);
	    root.right.right = a.createNewNode(3);
	    root.left.left = a.createNewNode(6);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(1);
	    root.left.right.left.left = a.createNewNode(4);
	    root.left.right.right = a.createNewNode(1);

	    int[] sequence = { 2, 7, 6, 1 };

	    System.out.println(a.checkIfSequenceMatchedFromRootToLeaf(root, sequence, 0));
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public boolean checkIfSequenceMatchedFromRootToLeaf(Node node, int[] sequence, int index) {
		    if (node == null) {
		      return false;
		    }

		    if (index >= sequence.length || node.data != sequence[index]) {
		      return false;
		    }

		    if (node.left == null && node.right == null && index == sequence.length - 1) {
		      return true;
		    }

		    return checkIfSequenceMatchedFromRootToLeaf(node.left, sequence, index + 1)
		        || checkIfSequenceMatchedFromRootToLeaf(node.right, sequence, index + 1);
		  }
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

51. PRINT ANCESTOR OF A GIVEN VALUE IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(9);
		    root.right.right = a.createNewNode(3);
		    root.left.left = a.createNewNode(10);
		    root.left.right = a.createNewNode(6);
		    root.left.right.left = a.createNewNode(5);
		    root.left.right.right = a.createNewNode(11);

		    a.printAncestors(root, 11);    
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public boolean printAncestors(Node node, int val) {
		    if (node == null) {
		      return false;
		    }

		    if (node.data == val) {
		      System.out.println(node.data);
		      return true;
		    }

		    if (printAncestors(node.left, val) || printAncestors(node.right, val)) {
		      System.out.println(node.data);
		      return true;
		    }

		    return false;
		  }
		
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

52. GET PARENT OF A GIVEN VALUE IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(9);
	    root.right.right = a.createNewNode(3);
	    root.left.left = a.createNewNode(10);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);

	    Node parent = a.getParent(root, 6);
	    if(parent != null) {
	      System.out.println(parent.data);
	    } else {
	      System.out.println("Parent is null");
	    }
	    
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		public Node getParent(Node node, int key) {
		    if (node == null || node.data == key) {
		      return null;
		    }

		    if ((node.left != null && node.left.data == key) || (node.right != null && node.right.data == key)) {
		      return node;
		    }

		    Node l = getParent(node.left, key);

		    if (l != null) {
		      return l;
		    }

		    l = getParent(node.right, key);
		    return l;
		  }
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

53. GET SIBLING NODE OF GIVEN VALUE IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(7);
	    root.right = a.createNewNode(9);
	    root.right.right = a.createNewNode(3);
	    root.left.left = a.createNewNode(10);
	    root.left.right = a.createNewNode(6);
	    root.left.right.left = a.createNewNode(5);
	    root.left.right.right = a.createNewNode(11);

	    Node sibling = a.getSibling(root, 7);
	    if(sibling != null) {
	      System.out.println(sibling.data);
	    } else {
	      System.out.println("Sibling is null");
	    }
	    
		  
	    
	}
}

class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public Node getSibling(Node node, int key) {
			    if (node == null || node.data == key) {
			      return null;
			    }

			    if (node.left != null && node.left.data == key) {
			      return node.right;
			    }
			    
			    if (node.right != null && node.right.data == key) {
			      return node.left;
			    }

			    Node l = getSibling(node.left, key);

			    if (l != null) {
			      return l;
			    }

			    l = getSibling(node.right, key);
			    return l;
			  }
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

53. CHECK IF GIVEN TWO NODES ARE SIBLINGS TO EACH OTHER IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.right = a.createNewNode(9);
		    root.right.right = a.createNewNode(3);
		    root.left.left = a.createNewNode(10);
		    root.left.right = a.createNewNode(6);
		    root.left.right.left = a.createNewNode(5);
		    root.left.right.right = a.createNewNode(11);

		    System.out.println(a.isSiblings(root, root.left.right.left, root.left.right.right));
	    }
	    
		  
	    
	}


class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public boolean isSiblings(Node node, Node a, Node b) {
			    if (node == null) {
			      return false;
			    }

			    return (node.left == a && node.right == b) 
			        || (node.left == b && node.right == a)
			        || isSiblings(node.left, a, b)
			        || isSiblings(node.right, a, b);
			  }
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 





 

60. GET CLOSEST LEAF NODE DISTANCE FROM A GIVEN VALUE IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(2);
		    root.left = a.createNewNode(7);
		    root.left.left = a.createNewNode(10);
		    root.left.right = a.createNewNode(6);
		    root.left.right.left = a.createNewNode(5);
		    root.left.right.left.left = a.createNewNode(4);
		    root.left.right.left.left.left = a.createNewNode(3);
		    root.right = a.createNewNode(9);
		    
		    System.out.println(a.closestLeafNode(root, 6));
	  }
	} 
	  
	    


class Node {
	  Node left;
	  Node right;
	  int data;
	}

	class BinaryTree {
		
		 public int closestLeafNode(Node node, int val) {
			    if (node == null) {
			      return Integer.MAX_VALUE;
			    }

			    Node arr[] = new Node[10];
			    return closestLeafNodeUtil(node, arr, val, 0);
			  }
			  
			  public int closestLeafNodeUtil(Node node, Node arr[], int val, int level) {
			    if (node == null) {
			      return Integer.MAX_VALUE;
			    }

			    int minDistFromLeaf = Integer.MAX_VALUE;

			    if (node.data == val) {
			      minDistFromLeaf = getMinDistanceToLeaf(node);

			      for (int i = level - 1; i >= 0; i--) {
			        minDistFromLeaf = Math.min(minDistFromLeaf, level - i + getMinDistanceToLeaf(arr[i]));
			      }

			      return minDistFromLeaf;
			    }

			    arr[level] = node;
			    
			    minDistFromLeaf = Math.min(minDistFromLeaf, closestLeafNodeUtil(node.left, arr, val, level + 1));
			    
			    if(minDistFromLeaf != Integer.MAX_VALUE) {
			      return minDistFromLeaf;
			    }

			    return Math.min(minDistFromLeaf, closestLeafNodeUtil(node.right, arr, val, level + 1));
			  }

			  public int getMinDistanceToLeaf(Node node) {
			    if (node == null) {
			      return Integer.MAX_VALUE;
			    }

			    if (node.left == null && node.right == null) {
			      return 0;
			    }

			    return 1 + Math.min(getMinDistanceToLeaf(node.left), getMinDistanceToLeaf(node.right));
			  }


		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 



 



65. GET RIGHT NODE OF A GIVEN VALUE IN TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(12);
		    root.left = a.createNewNode(7);
		    root.left.left = a.createNewNode(6);
		    root.left.right = a.createNewNode(9);
		    root.right = a.createNewNode(24);
		    
		    a.getRightNodeRecursive(root, 5);
		    System.out.println(a.rightNode);

		    Node rightNode = a.getRightNodeIterative(root, 5);
		    if(rightNode != null) {
		      System.out.println(rightNode.data);
		    }
	  }
	} 
	  
	    


class Node {
	Node left;
	  Node right;
	  Node next;
	  int data;
	}

	class BinaryTree {
		
		public void getRightNodeRecursive(Node node, int key) {
		    if (node == null || node.data == key) {
		      return;
		    }
		    
		    int levelOfKey = getLevelOfNode(node, key, 1);
		    storeRightNode(node, key, levelOfKey);
		  }
		  
		  public int getLevelOfNode(Node node, int val, int level) {
		    if (node == null) {
		      return 0;
		    }

		    if (node.data == val) {
		      return level;
		    }

		    int l = getLevelOfNode(node.left, val, level + 1);
		    if (l != 0) {
		      return l;
		    }

		    l = getLevelOfNode(node.right, val, level + 1);
		    return l;
		  }
		  
		  Node rightNode;
		  boolean flag;
		  
		  public void storeRightNode(Node node, int key, int level) {
		    if(node == null) {
		      return;
		    }
		    
		    if(level == 1 & node.data == key) {
		      if(flag) {
		        rightNode = node;
		        return;
		      } else {
		        flag = true;
		      }
		    }
		    
		    storeRightNode(node.left, key, level - 1);
		    storeRightNode(node.right, key, level - 1);
		  }

		  public Node getRightNodeIterative(Node node, int key) {
		    if (node == null || node.data == key) {
		      return null;
		    }

		    Queue<Node> q = new LinkedList<Node>();
		    q.add(node);
		    
		    boolean flag = false;

		    while (true) {
		      int size = q.size();
		      
		      if (size == 0 || flag) {
		        break;
		      }

		      while (size > 0) {
		        Node t = q.remove();
		        if (flag) {
		          return t;
		        }
		        
		        if (t.data == key) {
		          flag = true;
		        }
		        
		        if (t.left != null) {
		          q.add(t.left);
		        }

		        if (t.right != null) {
		          q.add(t.right);
		        }
		        
		        size--;
		      }
		    }
		    
		    return null;
		  }
		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

66. CHECK IF PARENT CONTAINS SUM OF BOTH CHILDREN

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(12);
		    root.left = a.createNewNode(4);
		    root.left.left = a.createNewNode(3);
		    root.left.right = a.createNewNode(1);
		    root.right = a.createNewNode(8);
		    root.right.right = a.createNewNode(8);
		    
		    System.out.println(a.ifParentContainSumofChildren(root));
		    }
	  }
	
	  
	    


class Node {
	Node left;
	  Node right;
	  Node next;
	  int data;
	}

	class BinaryTree {
		
		public boolean ifParentContainSumofChildren(Node node) {
		    if (node == null || (node.left == null && node.right == null)) {
		      return true;
		    }

		    int a = node.left != null ? node.left.data : 0;
		    int b = node.right != null ? node.right.data : 0;

		    return (a + b == node.data) && ifParentContainSumofChildren(node.left) && ifParentContainSumofChildren(node.right);
		  }

		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 
67. CHECK IF EACH NODE CONTAINS THE SUM OF LEFT AND RIGHT SUBTREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(120);
		    root.left = a.createNewNode(40);
		    root.left.left = a.createNewNode(15);
		    root.left.right = a.createNewNode(25);
		    root.right = a.createNewNode(20);
		    root.right.right = a.createNewNode(20);

		    System.out.println(a.ifSumTree(root));
		    }
	  }
	
	  
	    


class Node {
	Node left;
	  Node right;
	  Node next;
	  int data;
	}

	class BinaryTree {
		
		public boolean ifSumTree(Node node) {
		    int leftSum;
		    int rightSum;

		    if (node == null || ifLeafNode(node))
		      return true;

		    if (ifSumTree(node.left) && ifSumTree(node.right)) {
		      if (node.left == null)
		        leftSum = 0;
		      else if (ifLeafNode(node.left))
		        leftSum = node.left.data;
		      else
		        leftSum = 2 * (node.left.data);

		      if (node.right == null)
		        rightSum = 0;
		      else if (ifLeafNode(node.right))
		        rightSum = node.right.data;
		      else
		        rightSum = 2 * (node.right.data);

		      if ((node.data == rightSum + leftSum))
		        return true;
		      else
		        return false;
		    }

		    return false;
		  }

		  public boolean ifLeafNode(Node node) {
		    if (node == null) {
		      return false;
		    }

		    if (node.left == null && node.right == null) {
		      return true;
		    }

		    return false;
		  }

		
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 




 

69. CHECK IF GIVEN TREE IS SUB-TREE OF MAIN TREE IN BT	    


class Solution {
   
    public boolean isSubtree(TreeNode s, TreeNode t) {
          if (s == null) return false;
        if (isSame(s, t)) return true;
        return isSubtree(s.left, t) || isSubtree(s.right, t);
    }
    
    private boolean isSame(TreeNode s, TreeNode t) {
        if (s == null && t == null) return true;
        if (s == null || t == null) return false;
        
        if (s.val != t.val) return false;
        
        return isSame(s.left, t.left) && isSame(s.right, t.right);
        
    }
}
		 


 

70. GET MAX SUM BETWEEN TWO LEAVES IN BINARY TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(4);
	    root.left.left = a.createNewNode(1);
	    root.left.right = a.createNewNode(6);
	    root.right = a.createNewNode(5);
	    root.right.right = a.createNewNode(7);
	    
	    a.getMaxSumPathBetweenTwoLeaves(root);
	    System.out.println(a.maxSumBetweenTwoLeaves);
	    
		    }
	  }
	
	  
	    


class Node {
	Node left;
	  Node right;
	  Node next;
	  int data;
	}

	class BinaryTree {
		
	
		int maxSumBetweenTwoLeaves = 0;
		  
		  public int getMaxSumPathBetweenTwoLeaves(Node node) {
		    if (node == null) {
		      return 0;
		    }

		    if (node.left == null && node.right == null) {
		      return node.data;
		    }

		    int l = getMaxSumPathBetweenTwoLeaves(node.left);
		    int r = getMaxSumPathBetweenTwoLeaves(node.right);
		    
		    if(node.left != null && node.right != null) {
		      if (l + r + node.data > maxSumBetweenTwoLeaves) {
		        maxSumBetweenTwoLeaves = l + r + node.data;
		      }
		      
		      return Math.max(l, r) + node.data;
		    }

		    return node.left != null ? l + node.data : r + node.data; 
		  }
		  
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 


 

72. PRINT ALL PATHS WHERE SUM OF ALL NODE VALUES OF EACH PATH EQUALS GIVEN VALUE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		Node root = a.createNewNode(2);
	    root.left = a.createNewNode(4);
	    root.left.left = a.createNewNode(1);
	    root.left.right = a.createNewNode(6);
	    root.right = a.createNewNode(5);
	    root.right.right = a.createNewNode(7);

	    a.printKPathEqualToSum(root, 6);
	    
		    }
	  }
	
	  
	    


class Node {
	Node left;
	  Node right;
	  Node next;
	  int data;
	}

	class BinaryTree {
		
	
		List<Integer> elements = new ArrayList<Integer>();

		  public void printKPathEqualToSum(Node node, int val) {
		    if (node == null) {
		      return;
		    }

		    elements.add(node.data);

		    printKPathEqualToSum(node.left, val);
		    printKPathEqualToSum(node.right, val);

		    int sum = 0;
		    
		    for (int i = elements.size() - 1; i >= 0; i--) {
		      
		      sum = sum + elements.get(i);
		      
		      if (sum == val) {
		        
		        for (int j = i; j < elements.size(); j++) {
		          System.out.print(elements.get(j) + " ");
		        }
		        
		        System.out.println();
		      }
		    }
		    
		    elements.remove(elements.size() - 1);
		  }
		  
		  
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 

73. FIND AVERAGE OF EACH LEVEL IN BINARY TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		Node root = a.createNewNode(1);
	    root.left = a.createNewNode(2);
	    root.right = a.createNewNode(4);
	    root.left.left = a.createNewNode(10);
	    root.left.right = a.createNewNode(20);
	    root.right.right = a.createNewNode(30);
	    
	    
	    System.out.println(a.levelOrderAverage(root));
	    
		    }
	  }
	
	  

class Node {
	Node left;
	  Node right;
	  Node next;
	  int data;
	}

	class BinaryTree {
		
	
		public List<Integer> levelOrderAverage(Node node) {
		    if (node == null) {
		      return new ArrayList<Integer>();
		    }

		    List<Integer> avgList = new ArrayList<Integer>();
		    
		    Queue<Node> q = new LinkedList<Node>();
		    q.add(node);

		    while (true) {
		      int queueSize = q.size();
		      if (queueSize == 0) {
		        break;
		      }

		      int sum = 0;
		      int count = 0;
		      
		      
		      while (queueSize > 0) {
		        Node headNode = q.remove();
		        
		        sum = sum + headNode.data;
		        count++;
		        
		        if (headNode.left != null) {
		          q.add(headNode.left);
		        }

		        if (headNode.right != null) {
		          q.add(headNode.right);
		        }

		        queueSize--;
		      }
		      
		      avgList.add(sum / count);
		    }
		    
		    return avgList;
		  }
		
		  
		  
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 


 

75. CHECK IF THERE EXISTS A PAIR FOR GIVEN SUM IN BINARY TREE

package automate;
import java.io.*;
import java.util.*;


public class MyClass { 
	
	public static void main(String[] args) {
		  
		BinaryTree a = new BinaryTree();

		 Node root = a.createNewNode(7);
		    root.left = a.createNewNode(2);
		    root.right = a.createNewNode(6);
		    root.left.left = a.createNewNode(3);
		    root.left.right = a.createNewNode(5);
		    root.right.right = a.createNewNode(10);
		    
		    System.out.println(a.ifPairExists(root, 14));
	    
		    }
	  }
	
	  

class Node {
	Node left;
	  Node right;
	  Node next;
	  int data;
	}

	class BinaryTree {
		
	
		 public boolean ifPairExists(Node node, int sum) {
			    HashSet<Integer> set = new HashSet<>();
			    
			    return ifPairExistsUtil(node, sum, set); 
			  }
			  
			  public boolean ifPairExistsUtil(Node node, int sum, HashSet<Integer> set) {
			    if(node == null) {
			      return false;
			    }
			    
			    if(set.contains(sum - node.data)) {
			      return true;
			    }
			    
			    set.add(node.data);
			    
			    if(ifPairExistsUtil(node.left, sum, set)) {
			      return true;
			    }
			    
			    return ifPairExistsUtil(node.right, sum, set); 
			  }
			  
		  
		  
	public	Node createNewNode(int val) {
    Node newNode = new Node();
    newNode.data = val;
    newNode.left = null;
    newNode.right = null;
    return newNode;
  }
	
 }


 






	   