SMALLEST INTEGER DIVISBLE BY K
// contains only 1  n%k == 0
class Solution {
    public int smallestRepunitDivByK(int k) {
        if(k%2 == 0 ) return -1;
        int remainder = 0;
        for(int counter = 1; counter <= k; counter++){  // 1 , 11, 111 k = 3  1 2 0
            remainder = (remainder*10+1)%k;
            if(remainder==0) return counter;
        }
        return -1;
    }
}


BACKSPACE STRING COMPARE
S = ab#c,  T = ad#c  o/p = true  both S and T become ac
class Solution {
   private String getString(String str) {
        int n=str.length(), count=0;
        String result="";
        for(int i=n-1; i>=0; i--) {
            char ch=str.charAt(i);
            if(ch=='#') 
                count++;
            else {
                if(count>0)
                    count--;
                else {
                    result+=ch;
                }                     
            }
        }
        return result;
    }
    
    public boolean backspaceCompare(String S, String T) {
        return getString(S).equals(getString(T));
    }
}


COUNT NO OF HOMOGENOUS SUBSTRING

class Solution {
    
    // a b b c c c a a
    // 1 1 2 1 2 3 1 2
    public int countHomogenous(String s) {
        int res = 1;
        int carry = 1;
        int mod = 1000000007;
        for(int i =1;i<s.length();i++){
            if(s.charAt(i) == s.charAt(i-1)) carry++;
            else carry = 1;
            res = (res + carry) % mod;
        }
        
        return res;
    }
}

ELIMINATION GAME

example:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

Let us start with head = 1, left = true, step = 1 (times 2 each turn), remaining = n(24)

we first move from left, we definitely need to move head to next position. (head = head + step)
So after first loop we will have:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 - > 2 4 6 8 10 12 14 16 18 20 22 24
head = 2, left = false, step = 1 * 2 = 2, remaining = remaining / 2 = 12

second loop, we move from right, in what situation we need to move head?
only if the remaining % 2 == 1, in this case we have 12 % 2 == 0, we don't touch head.
so after this second loop we will have:
2 4 6 8 10 12 14 16 18 20 22 24 - > 2 6 10 14 18 22
head = 2, left = true, step = 2 * 2 = 4, remaining = remaining / 2 = 6

third loop, we move from left, move head to next position
after third loop we will have:
2 6 10 14 18 22 - > 6 14 22
head = 6, left = false, step = 4 * 2 = 8, remaining = remaining / 2 = 3

fourth loop, we move from right, NOTICE HERE:
we have remaining(3) % 2 == 1, so we know we need to move head to next position
after this loop, we will have
6 14 22 - > 14
head = 14, left = true, step = 8 * 2 = 16, remaining = remaining / 2 = 1

while loop end, return head


class Solution {
    public int lastRemaining(int n) {
        boolean left = true;
        int remaining = n;
        int step = 1;
        int head = 1;
        while (remaining > 1) {
            if (left || remaining % 2 ==1) {
                head = head + step;
            }
            remaining = remaining / 2;
            step = step * 2;
            left = !left;
        }
        return head;
    }
}



NO OF SUBSTRINGS WITH ONLY 1'S

class Solution {
    public int numSub(String s) {
        int count = 0;
        int result = 0;
        int mod = 1_000_000_007;
        
        for (char ch : s.toCharArray()) {
            count = ch == '1' ? count + 1 : 0;
            result = (result + count) % mod;
        }
        return ( result );
    }
}


K STRONGEST VALUE
Input: arr = [1,2,3,4,5], k = 2
Output: [5,1]
Explanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.
Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.

class Solution {
    public int[] getStrongest(int[] arr, int k) {
        int first=0;
		int last=arr.length-1;
		
		int retStrongest[]=new int[k];
		int index=0;
		
		Arrays.sort(arr);
		
	   int median=arr[(arr.length-1)/2];
	   
	   
	   
	   for(int i=1;i<=k;i++)
	   {
		   if(Math.abs(arr[first]-median) > Math.abs(arr[last]-median) )
		   {
			   retStrongest[index]=arr[first];
			   first++;
			   index++;
		   }
		   
		   else if(Math.abs(arr[first]-median) < Math.abs(arr[last]-median) )
		   {
			   retStrongest[index]=arr[last];
			   last--;
			   index++;
		   }
		   
		   else if (Math.abs(arr[first]-median) == Math.abs(arr[last]-median) )
		   {
			   if(arr[first]>arr[last])
			   {
				   retStrongest[index]=arr[first];
				   first++;
				   index++;
			   }
			   else
			   {
				   retStrongest[index]=arr[last];
				   last--;
				   index++;
			   }
		   }
		   
		   
		   
	   }
	   
	   
		
		return retStrongest;
    }
}


FIND PRICES WITH SPECIAL DISCOUNT
Input: prices = [8,4,6,2,3]
Output: [4,2,4,2,3]
Explanation: 
For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. 
For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. 
For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. 
For items 3 and 4 you will not receive any discount at all

class Solution {
    public int[] finalPrices(int[] prices) {
         int[] res = prices.clone();
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < prices.length; ++i) {
            while (!stack.isEmpty() && prices[stack.peek()] >= prices[i]) {
                res[stack.pop()] -= prices[i];
            }
            stack.push(i);
        }
        return res;   
    }
}


MIN BUCKET TO COLLECT RAINWATER FROM HOUSES

class Solution {
    public int minimumBuckets(String street) {
        int count=0;
        for(int i=0;i<street.length();i++){
            
       if(street.charAt(i)=='H'){
                if(i+1<street.length() && street.charAt(i+1)=='.'){
                    count++;
                     i+=2;
                    continue;
                }
                if(i-1>=0 && street.charAt(i-1)=='.'){
                    count++;
                    continue;
                }
                return -1;
            }
        }
        return count;
    }
}

K RADIUS SUBARRAY AVERAGE
Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
Output: [-1,-1,-1,5,4,4,-1,-1,-1]
Explanation:
- avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.
- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
  Using integer division, avg[3] = 37 / 7 = 5.
- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.

class Solution {
    public int[] getAverages(int[] nums, int k) {
        int n = nums.length;
        int ans[] = new int[n];
          Arrays.fill(ans, -1);
        
        long sum = 0;
        int len = 2*k + 1;
        
        for(int i=0; i< n; i++){
            sum += nums[i];
            
            if(i >= len) sum -= nums[i - len];
            
            if(i >= len - 1) ans[i - k] = (int)(sum / len);
        }
        
        return ans;    
        
    }
}


UNCOMMON WORDS FROM TWO STRINGS
Input: s1 = "this apple is sweet", s2 = "this apple is sour"
Output: ["sweet","sour"]

class Solution {
    public String[] uncommonFromSentences(String A, String B) {
        String str = A+" "+B;
        
        String[] words = str.split(" ");
        
        HashMap<String, Integer> hash = new HashMap<>();
        
        for(int i=0; i<words.length; i++){
          if(!hash.containsKey(words[i]))
                hash.put(words[i], 1);
            else
                hash.put(words[i], hash.get(words[i])+1);  
        }
        
        List<String> result = new ArrayList<>();
          
        for(String key:hash.keySet())
            if(hash.get(key) == 1)
                result.add(key);
        
        return result.toArray(new String[result.size()]);
    }
}



MINIMUM INDEX SUM OF TWO LISTS
Input: list1 = ["Shogun","Tapioca Express","Burger King","KFC"], list2 = ["KFC","Shogun","Burger King"]
Output: ["Shogun"]
Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).

class Solution {
    public String[] findRestaurant(String[] list1, String[] list2) {
        Map<String, Integer> map = new HashMap<>();
    List<String> res = new LinkedList<>();
    int minSum = Integer.MAX_VALUE;
    for (int i=0;i<list1.length;i++) map.put(list1[i], i);
    for (int i=0;i<list2.length;i++) {
        Integer j = map.get(list2[i]);
        if (j != null && i + j <= minSum) {
            if (i + j < minSum) {
                res.clear();
                minSum = i+j;
            }
            res.add(list2[i]);
        }
    }
    return res.toArray(new String[res.size()]);
    }
}

ADD TO ARRAY FORM OF INTEGER

Input: num = [2,7,4], k = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455

class Solution {
    public List<Integer> addToArrayForm(int[] A, int K) {
       List<Integer> list = new LinkedList<>();
        
        int i = A.length - 1;
        int carry = 0;
        while(i >= 0 || K != 0 || carry == 1){
            int sum = carry;
            if(i >= 0){
                sum += A[i];
                i--;
            }
            if(K != 0){
                sum += K % 10;
                K = K / 10;
            }
            list.add(0,sum % 10);
            carry = sum / 10;   
        }
        
        return list;
    }
}

COUNT VOWEL SUBSTRING OF A STRING

class Solution {
   

    public int countVowelSubstrings(String word) {
            boolean[] vowel = new boolean[256];
            vowel['a'] = true;
            vowel['e'] = true;
            vowel['i'] = true;
            vowel['o'] = true;
            vowel['u'] = true;
        
        int ans = 0;
        char[] a = word.toCharArray();
        for (int i = 0; i < word.length(); i++) {
            HashSet<Character> hash = new HashSet<>();
            for (int j = i; j < word.length(); j++) {
                if (vowel[a[j]] == false) break;
                hash.add(a[j]);
                if (hash.size() == 5) ans++;
            }
        }
        return ans;
    }
}

4 SUM

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
      List<List<Integer>> result=new ArrayList<>();
if(nums==null || nums.length<4){
return result;
}
Arrays.sort(nums);
int n=nums.length;

    for(int i=0;i<n-3;i++){
        for(int j=i+1;j<n-2;j++){
            int low=j+1;
            int high=n-1;
            
            while(low<high){
                int sum=nums[i]+nums[j]+nums[low]+nums[high];
                if(sum==target){
                    List<Integer>list=new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[low]);
                    list.add(nums[high]);
            
            
            if(result.contains(list)==false){
                result.add(list);
            }
            low++;
            high--;
                }
         else if(sum<target){
                low++;
            }
            else{
                high--;
            }
            }
        }
    }
    return result;
		 
    }
}

3SUM

class Solution {

    public List<List<Integer>> threeSum(int[] nums) {
         Arrays.sort(nums);
		 
		 List<List<Integer>> allTriplets = new ArrayList<>();
		 
        
		 for(int i = 0; i < nums.length - 2; i++) {
            
			if(i == 0 || (i > 0 && nums[i] != nums[i - 1])){
                
                int lo = i+1, hi = nums.length - 1, sum = 0 - nums[i];
                
                while(lo < hi) {
                    if(nums[lo] + nums[hi] == sum){
                         allTriplets.add(Arrays.asList( nums[i], nums[lo], nums[hi]));
                        
                        while(lo < hi && nums[lo] == nums[lo+1]) lo++;
                          while(lo < hi && nums[hi] == nums[hi-1]) hi--;
                        
                        lo++;
                        hi--;
                    }
                    else if(nums[lo] + nums[hi] < sum) lo++;
                    
                    else hi--;
                }
            }
             
			 
			
		 }
		 return allTriplets;
    }
}

FIND VALUE OF VARIABLE AFTER PERFORMING OPERATION

Input: operations = ["--X","X++","X++"]
Output: 1
Explanation: The operations are performed as follows:
Initially, X = 0.
--X: X is decremented by 1, X =  0 - 1 = -1.
X++: X is incremented by 1, X = -1 + 1 =  0.
X++: X is incremented by 1, X =  0 + 1 =  1.

class Solution {
    public int finalValueAfterOperations(String[] operations) {
        int val = 0;
    	for(int i=0;i<operations.length;i++) {
    		if(operations[i].charAt(1)=='+') val++;
    		else val--;
    	}
    	return val; 
    }
}


MAXIMUM DIFFERENCE BETWEEN INCREASING ELEMENT

class Solution {
    public int maximumDifference(int[] nums) {
       int maxDiff = -1;
        int minEle = nums[0];
        
        for(int i=1; i< nums.length; i++){
            if((nums[i] - minEle) > maxDiff) {
                maxDiff = nums[i] - minEle;
            }
            
            if(nums[i] < minEle){
                minEle = nums[i];
            }
        }
        
        return maxDiff;
    }
}


CONVERT 1D TO 2D ARRAY

class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        if(original.length != m*n) return new int[0][0];
	int[][] result = new int[m][n];
	for(int i=0;i<original.length;i++)
		result[i/n][i%n] = original[i];
	return result;
    }
}


TWO BEST NON OVERLAPPING EVENT
events[i] = [startTimei, endTimei, valuei]
You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.
Input: events = [[1,5,3],[1,5,1],[6,6,5]]
Output: 8
Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.

class Solution {
    public int maxTwoEvents(int[][] events) {
        int n = events.length;
        Arrays.sort(events, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
        PriorityQueue<int[]> queue = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]); // sort according to ending time
        
        int maxVal = 0, ans = 0;
        for(int[] e : events){            
            int start = e[0];
            while(!queue.isEmpty()){
                if(queue.peek()[0] >= start)
                    break;
                
                int[] eve = queue.remove();
                maxVal = Math.max(maxVal, eve[1]);
            }
            ans = Math.max(ans, e[2] + maxVal);
            queue.add(new int[]{ e[1], e[2]});
        }
        
        return ans;
    }
}


LONGEST DUPLICATE SUBSTRING

class Solution {
     public  String findAns(String s, int len) {
    int n = s.length();
    int sp = 0, ep = len;
    Map<Long, List<Integer>> hs = new HashMap<Long, List<Integer>>();
    long p = 31;
    long pow = 1;
    long chash = 0;
    long mod = 1000000007;
    for (int i = len - 1; i >= 0; i--) {
      char c = s.charAt(i);
      chash = (chash + ((c - 'a' + 1) * pow) % mod + mod) % mod;
      if (i > 0)pow = (pow * p) % mod;
    }
    List<Integer> empList = new LinkedList<Integer>();
    hs.put(chash, empList);
    hs.get(chash).add(0);

    while (ep < n) {
      char sc = s.charAt(sp);
      char ec = s.charAt(ep);

      chash = (chash - ((sc - 'a' + 1) * pow) % mod + mod) % mod;
      chash = (chash * p) % mod;
      chash = (chash + (ec - 'a' + 1)) % mod;

      if (hs.containsKey(chash)) {
        String curr = s.substring(sp + 1, ep + 1);
        for (int sx : hs.get(chash)) {
          if (curr.equals(s.substring(sx, sx + len))) {
            return curr;
          }
        }
        hs.get(chash).add(sp + 1);
      } else {
        hs.put(chash, empList);
        hs.get(chash).add(sp + 1);
      }
      sp++;
      ep++;
    }
    return "";
  }
    public String longestDupSubstring(String s) {
         int n = s.length();
    int l = 0;
    int r = n;
    String ans = "";

    // insights-
    // why binary search? to find the length of longest possible efficiently, if not found anything in curr mid, this means nothing in right and visa-viss
    // why make hashMap<Long,List<String>>? Collisions are very much possible in this question
    while (l <= r) {
      int mid = (l + r) / 2;
      String currAns = findAns(s, mid);

      if (currAns != "") {
        ans = currAns;
        l = mid + 1;
      } else r = mid - 1;
    }
    return ans;
    }
}





FIND CLOSEST PAIR OF 2 SORTED ARRAY

// Java program to find closest pair in an array
class ClosestPair
{
    // ar1[0..m-1] and ar2[0..n-1] are two given sorted
    // arrays/ and x is given number. This function prints
    // the pair from both arrays such that the sum of the
    // pair is closest to x.
    void printClosest(int ar1[], int ar2[], int m, int n, int x)
    {
        // Initialize the diff between pair sum and x.
        int diff = Integer.MAX_VALUE;
 
        // res_l and res_r are result indexes from ar1[] and ar2[]
        // respectively
        int res_l = 0, res_r = 0;
 
        // Start from left side of ar1[] and right side of ar2[]
        int l = 0, r = n-1;
        while (l<m && r>=0)
        {
           // If this pair is closer to x than the previously
           // found closest, then update res_l, res_r and diff
           if (Math.abs(ar1[l] + ar2[r] - x) < diff)
           {
               res_l = l;
               res_r = r;
               diff = Math.abs(ar1[l] + ar2[r] - x);
           }
 
           // If sum of this pair is more than x, move to smaller
           // side
           if (ar1[l] + ar2[r] > x)
               r--;
           else  // move to the greater side
               l++;
        }
 
        // Print the result
        System.out.print("The closest pair is [" + ar1[res_l] +
                         ", " + ar2[res_r] + "]");
    }
 
    // Driver program to test above functions
    public static void main(String args[])
    {
        ClosestPair ob = new ClosestPair();
        int ar1[] = {1, 4, 5, 7};
        int ar2[] = {10, 20, 30, 40};
        int m = ar1.length;
        int n = ar2.length;
        int x = 38;
        ob.printClosest(ar1, ar2, m, n, x);
    }
}





ISSUBSEQUENCE

class Solution {
    public boolean isSubsequence(String s, String t) {
        if (s.length() == 0) return true;
        int indexS = 0, indexT = 0;
        while (indexT < t.length()) {
            if (t.charAt(indexT) == s.charAt(indexS)) {
                indexS++;
                if (indexS == s.length()) return true;
            }
            indexT++;
        }
        return false;
    }
}




KTH MISSING POSITIVE NUMBER


// difference give u the count of missing element

1 2 4 5 6 7 8 9;  k = 5
class Solution {
    public int findKthPositive(int[] arr, int k) {
         int l = 0, r = arr.length;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] - (mid + 1) >= k) r = mid;  //missed more or equal than k numbers, left side;
            else l = mid + 1;   // missed less than k numbers, must be in the right side;
        }
        return l + k;
    }
}


// brute force
// loop while(k > 0)  if u find iterator ele in set then ++ else if it not there then reduce k and search for next



STRING COMPRESSION

Input: chars = ["a","a","b","b","c","c","c"]
Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".

class Solution {
    public int compress(char[] chars) {
        int index = 0;
        int i = 0;
        while(i < chars.length) {
            int j = i;
            while(j < chars.length && chars[j] == chars[i]) {
                j++;
            }
            
            chars[index++] = chars[i];
            if(j - i > 1){
                String count = j - i + "";
                for(char c : count.toCharArray()){
                    chars[index++] = c;
                }
            }
            
            i = j;
        }
        
        return index;
    }
}



LARGEST PERIMETER IN TRIANGLE

class Solution {
    public int largestPerimeter(int[] nums) {
        
        Arrays.sort(nums);
        
        int peri = 0;
        for(int i = nums.length - 1; i >= 2; i--){
            if(nums[i-1] + nums[i-2] > nums[i]){
                peri = nums[i-1] + nums[i-2] + nums[i];
                break;
            }
        }
        return peri;
    }
} 


MAXIMUM PRODUCT OF WORD LENGTH

class Solution {
    public int maxProduct(String[] words) {
        if (words == null || words.length == 0)
		return 0;
        
	int len = words.length;
	int[] state = new int[len];
        
	for (int i = 0; i < len; i++) {
        state[i] = getSateFromString(words[i]);
    }
        
   
		
	int maxProduct = 0;
	for (int i = 0; i < len; i++)
		for (int j = i + 1; j < len; j++) {
			if ((state[i] & state[j]) == 0 && (words[i].length() * words[j].length() > maxProduct))
				maxProduct = words[i].length() * words[j].length();
		}
	return maxProduct;
    }
    
     private int getSateFromString(String s){
        int state = 0;
        for(char c: s.toCharArray()){
            int index = c - 'a';
            state |= 1 << (index);
        }
        return state;
    }
}
                                                                                                            ARRAYS AND STRINGS
 
MAXIMUM XOR OF TWO NUMBERS

class Solution {
    public int findMaximumXOR(int[] arr) {
         int ans = 0, mask = 0;
        
        for(int i=31; i>=0; i--){
            mask = mask | (1<<i);
            Set<Integer> set = new HashSet();
            
            for(int nums : arr){
                set.add(nums & mask);
            }
            
            int target = ans | (1 << i);
            
            for(int z : set){
                if(set.contains(target ^ z)){
                    ans = target;
                    break;
                }
            }
        }
        return ans;
    }
}



2.  COUNT OF SUBARRAY WHOSE PRODUCT LESS THAN K


// SLIDING WINDOW

Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.

class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if(k <= 1) return 0;
        
        int prod = 1;
        int result = 0;
        
        int left = 0;
        int right = 0;
        
        while(right < nums.length){
            prod *= nums[right];
            
            while(prod >= k){
                prod /= nums[left];
                left++;
            }
            
            result += right - left + 1;
            
            right++;
        }
        
        return result;
    }
}

MAX PRODUCT SUBARRAY

Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.

class Solution {
    public int maxProduct(int[] nums) {
        int ans = Integer.MIN_VALUE;
        int cprd = 1;
        for(int i=0; i< nums.length; i++){
            cprd *= nums[i];
            ans = Math.max(ans, cprd);
            if(cprd == 0){
                cprd = 1;
            }
        }
        cprd = 1;
        for(int i=nums.length - 1; i>= 0; i--){
            cprd *= nums[i];
            ans = Math.max(ans, cprd);
            if(cprd == 0){
                cprd = 1;
            }
        }
        return ans;
    }
}



3. MINIMUM SIZE SUBARRAY WITH SUM GREATER OR EQUAL TO TARGET

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.

class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        
        int start = 0;
        int sum = 0;
        int minLength = Integer.MAX_VALUE;
        
        for(int end = 0; end < nums.length; end++){
            sum = sum + nums[end];
            
            while(sum >= target && start <= end){
                minLength = Math.min(minLength, (end - start) + 1);
                sum = sum - nums[start];
                start++;
            }
        }
        return (minLength == Integer.MAX_VALUE ) ? 0 : minLength;
    }
}



4. MAXIMUM LENGTH OF SUBARRAY WITH POSITIVE PRODUCT

Input: nums = [0,1,-2,-3,-4]
Output: 3
Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.
Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.

class Solution {
    public int getMaxLen(int[] nums) {
        
        //countnegative is used to count the number of neg number from zerposition to current index
        
        int firstnegative = -1, zeroposition = -1, countnegative = 0, max = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] < 0){
                countnegative++;
                //we only need to know index of first negative number
                if(firstnegative == -1) firstnegative = i;
            }
            
            //if current number is 0, we can't use any element from index 0 to i anymore,so update zerposition, and reset countnegative and firstnegative
            
            if(nums[i] == 0){
                countnegative = 0;
                firstnegative = -1;
                zeroposition = i;
            }
            else {
                
                if(countnegative % 2 == 0) max = Math.max(i - zeroposition, max);
                
                else max = Math.max(i - firstnegative, max);
            }
        }
       return max; 
    }
}


/*
Every time we see a zero, we have to start another sub arr

The product of an even number of negative number is even and if its an odd number of negative number then its negative.
*/



5. MAXIMUM UNIT ON TRUCK

Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
Output: 8
Explanation: There are:
- 1 box of the first type that contains 3 units.
- 2 boxes of the second type that contain 2 units each.
- 3 boxes of the third type that contain 1 unit each.
You can take all the boxes of the first and second types, and one box of the third type.
The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.

class Solution {
    public int maximumUnits(int[][] boxTypes, int truckSize) {
        Arrays.sort(boxTypes, (a, b) -> Integer.compare(b[1], a[1]));
        
        int maxUnits = 0;
        
        for(int[] box: boxTypes){
            if(truckSize < box[0]){
                return maxUnits + truckSize * box[1];
            }
            
            maxUnits += box[0]*box[1];
            truckSize -= box[0];
        }
        
        return maxUnits;
    }
}


1. NEXT GREATER ELEMENT III
Input: nums = [1,2,3]
Output: [1,3,2]

class Solution {
    public int nextGreaterElement(int n) {
        char[] nums = Integer.toString(n).toCharArray();
        
        int lastIdx = nums.length - 1;
        
        // step 1
        while(lastIdx > 0) {
            if(nums[lastIdx - 1] < nums[lastIdx]) {
                break;
            }
            lastIdx--;
        }
        
        if(lastIdx == 0) { // if decresing digits, then return -1
            return -1;
        } else { // step 2
            int firstGreaterNumIdx = lastIdx - 1;
            int firstGreaterNum = nums[lastIdx - 1];
            
            int lIdx = nums.length - 1;
            while(lIdx > firstGreaterNumIdx) {
                if(nums[lIdx] > firstGreaterNum) {
                    break;
                }
                lIdx--;
            }
            swap(nums, firstGreaterNumIdx, lIdx);
            
            reverse(nums, lastIdx); // step 3
        }
        
        // we need to have the number fit in 32-bit integer so if the number is greater than Integer.MAX_VALUE, return -1
        return Long.parseLong(new String(nums)) > Integer.MAX_VALUE ? -1 : (int) Long.parseLong(new String(nums));
    }
    
    private void swap(char[] nums, int firstIdx, int secondIdx) {
        char temp = nums[firstIdx];
        nums[firstIdx] = nums[secondIdx];
        nums[secondIdx] = temp;
    }
    
    private void reverse(char[] nums, int startIdx) {
        int endIdx = nums.length - 1;
        while(startIdx < endIdx) {
            swap(nums, startIdx, endIdx);
            startIdx++;
            endIdx--;
        }
    }
}

                 
                        

3. MAX CHUNK TO MAKE ARRAY SORTED
Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible

class Solution {
    public int maxChunksToSorted(int[] arr) {
        
    int count = 0;
        int max = 0;
        for(int i = 0; i < arr.length; i++) {
            max = Math.max(arr[i], max);
            
            if(i == max) 
                count++;
        }
        return count;    
    }
}


4. MAX CHUNK TO MAKE ARRAY SORTED 2
nput: arr = [2,1,3,4,4]
Output: 4
Explanation:
We can split into two chunks, such as [2, 1], [3, 4, 4].
However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~
    public static int maxChunksToSorted2(int[] arr) {
        int[] rmin = new int[arr.length + 1];
        
        int val = Integer.MAX_VALUE;
        rmin[arr.length] = val;
        for(int i = arr.length - 1; i>= 0; i--) {
            val = Math.min(val, arr[i]);
            rmin[i] = val;
        }
        
        int lmax = arr[0];
        int count = 0;
        for(int i = 0; i < arr.length; i++) {
            lmax = Math.max(lmax, arr[i]);
            
            if(lmax <= rmin[i + 1])
                count++;
        }
        
        return count;
    }

    // ~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        int res = maxChunksToSorted2(arr);
        System.out.println(res);
    }
}


PARTITION ARRAY INTO DISJOINT INTERVAL O(N) SPACE

 int n = nums.length;
        int[] rmin = new int[n + 1];
        
        int val = Integer.MAX_VALUE;
        rmin[n] = val;
        for(int i = n - 1; i>= 0; i--) {
            rmin[i] = Math.min(rmin[i + 1], nums[i]);
        }
        
        int lmax = Integer.MIN_VALUE;
        int ans = 0;
        for(int i = 0; i < n; i++) {
            lmax = Math.max(lmax, nums[i]);
            
            if(lmax < rmin[i + 1]) {
                ans = i;
            break;
        }
        }
        return ans + 1;


Input: nums = [5,0,3,8,6]
Output: 3
Explanation: left = [5,0,3], right = [8,6]

Given an integer array nums, partition it into two (contiguous) subarrays left and right so that:

Every element in left is less than or equal to every element in right.
left and right are non-empty.
left has the smallest possible size.

O(1) SPACE

class Solution {
    public int partitionDisjoint(int[] nums) {
        
     int leftmax = nums[0];
     int greater = nums[0];
     int ans = 0;
        
        for(int i = 1; i < nums.length; i++){
            if(nums[i] > greater){
                greater = nums[i];
            } else if(nums[i] < leftmax){
                leftmax = greater;
                ans = i;
            }
        }
        return ans + 1;
    }
}


PUSH DOMINOS

class Solution {
    
    public static void solve(char[] arr, int i, int j){
        if(arr[i] == 'L' && arr[j] == 'L'){
             // make all dots as L
            for(int k = i+1; k < j; k++)
                arr[k] = 'L';
        } else if(arr[i] == 'R' && arr[j] == 'R'){
            for(int k = i+1; k < j; k++)
                arr[k] = 'R';
        } else if(arr[i] == 'L' && arr[j] == 'R') {
            
        } else {
            int diff = j - i;
            int mid = (i+j)/2;
            
            if(diff % 2 == 0){
                // odd dots
                for(int k = i + 1; k < mid; k++){
                    arr[k] = 'R';
                }
                for(int k = mid + 1; k < j; k++){
                    arr[k] = 'L';
                }
            } else {
                 for(int k = i + 1; k <= mid; k++){
                    arr[k] = 'R';
                }
                for(int k = mid + 1; k < j; k++){
                    arr[k] = 'L';
                }
            }
        }
    }
    
    public String pushDominoes(String dominoes) {
        int n = dominoes.length();
        char[] arr = new char[n+2];
        arr[0] = 'L';
        arr[n + 1] = 'R';
        
        for(int i = 1; i < arr.length - 1; i++){
            arr[i] = dominoes.charAt(i - 1);
        }
        
        int j = 0;
        int k = 1;
        
        while(k < arr.length){
            while(arr[k] == '.')
                k++;
            
            if(k - j > 1)
            solve(arr, j, k);
            j = k;
            k++;
        }
        
        StringBuilder res = new StringBuilder();
        for(int i = 1; i < arr.length - 1; i++){
            res.append(arr[i]);
        }
        
        return res.toString();
    }
}


5. MINIMUM JUMP WITH +i -i MOVE
Input: target = 2
Output: 3
Explanation:
On the 1st move, we step from 0 to 1 (1 step).
On the 2nd move, we step from 1 to -1 (2 steps).
On the 3rd move, we step from -1 to 2 (3 steps).
import java.util.*;

public class Main {
    // ~~~~~~~~~~~~User Section~~~~~~~~~~~
    public static int minJumps(int x) {
        int sum = 0;
        int jump = 1;
        while(sum < x) {
            sum += jump;
            jump++;
        }

        if(sum == x) {
            return jump - 1;
        } else if((sum - x) % 2 == 0) {
            return jump - 1;
        } else if((sum + jump - x) % 2 == 0) {
                return jump;
        } else {
            return jump + 1;
        }
    }

    //~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int x = scn.nextInt();

        int jumps = minJumps(x);
        System.out.println(jumps);
    }
}



6. MAXIMUM PRODUCT OF 3 NUMBER

import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~
    public static int maximumProduct(int[] arr) {
        int min = (int)1e9;
        int smin = (int)1e9;
        
        int max = -(int)1e9;
        int smax = max;
        int tmax = max;
        
        for(int i = 0; i < arr.length; i++) {
            if(arr[i] > max) {
                tmax = smax;
                smax = max;
                max = arr[i];
            } else if(arr[i] > smax) {
                tmax = smax;
                smax = arr[i];
            } else if(arr[i] > tmax) {
                tmax = arr[i];
            }
            
            
            if(arr[i] < min) {
                smin = min;
                min = arr[i];
            } else if(arr[i] < smin) {
                smin = arr[i];
            }
        }
        
        return Math.max(max * smax * tmax, max * min * smin);
    }

    // ~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        int prod = maximumProduct(arr);
        System.out.println(prod);
    }
}
                        


7. SORT ARRAY BY PARITY

import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void sortArrayByParity(int[] nums) {
        int i = 0;
        int j = 0;
        
        while(i < nums.length) {
            if(nums[i] % 2 == 0) {
                swap(nums, i, j);
                i++;
                j++;
            } else {
                i++;
            }
        }
    }

    //// ~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        sortArrayByParity(arr);

        for(int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}



8. BEST MEETING POINT

import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~
    public static int minTotalDistance(int[][] grid) {
        // Write your code here
        ArrayList<Integer> xcord = new ArrayList<>();
        ArrayList<Integer> ycord = new ArrayList<>();

        // for row coordinates
        for(int r = 0; r < grid.length; r++) {
            for(int c = 0; c < grid[0].length; c++) {
                if(grid[r][c] == 1) {
                    xcord.add(r);
                }
            }
        }

        // for col coordinates
        for(int c = 0; c < grid[0].length; c++) {
            for(int r = 0; r < grid.length; r++) {
                if(grid[r][c] == 1) {
                    ycord.add(c);
                }
            }
        }

        int x = xcord.get(xcord.size() / 2);
        int y = ycord.get(ycord.size() / 2);
        
        // calculate distance
        int dist = 0;
        for(int i = 0; i < xcord.size(); i++) {
            dist += Math.abs(xcord.get(i) - x) + Math.abs(ycord.get(i) - y);
        }
        return dist;
    }

    // ~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int m = scn.nextInt();


        int[][] grid = new int[n][m];

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                grid[i][j] = scn.nextInt();
            }
        }

        int dist = minTotalDistance(grid);
        System.out.println(dist);
    }
}





      


9. MINIMUM OPERATION REQUIRE TO MAKE ARRAY PALINDROME

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	 public static void main(String[] arg){
		   Scanner t = new Scanner(System.in);
		   System.out.println("Enter the value");
		   int n = t.nextInt();
		 int[] arr = new int[n];
		 for(int i = 0; i < n; i++) {
			 arr[i] = t.nextInt();
		 }
		System.out.println(minOperation(arr, n));
  }
	 
	 public static int minOperation(int[] arr, int n) {
		int ans = 0;
		int i = 0, j = n - 1;
		while(i <= j) {
			if(arr[i] == arr[j]) {
				i++;
				j--;
			} else if (arr[i] < arr[j]) {
				i++;
				arr[i] += arr[i - 1];
				ans++;
			} else {
				j--;
				arr[j] += arr[j + 1];
				ans++; 
			}
		}
		return ans;
	 }
}


MINIMUM OPERATION TO MAKE ARRAY EQUAL

class Solution {
  //  Scanner t = new Scanner(System.in);
    
    public int minOperations(int n) {
        
       int mid = n/2;
        return n%2 == 0 ? (mid*mid) : mid*(mid+1);
    }
}


10. MINIMUM SWAPS REQUIRED TO BRING ELEMENTS LESS EQUAL K TOGETHER

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	 public static void main(String[] arg){
		   Scanner t = new Scanner(System.in);
		   System.out.println("Enter the value");
		   int n = t.nextInt();
		 int[] arr = new int[n];
		 for(int i = 0; i < n; i++) {
			 arr[i] = t.nextInt();
		 }
		   int k = t.nextInt();
		System.out.println(minSwap(arr, n, k));
  }
	 
	 public static int minSwap(int[] arr, int n, int k) {
		int good = 0;
		int bad = 0;
		
		//counting good values
		for(int i = 0; i < n; i++) {
			if(arr[i] <= k) {
				good++;
			}
		}
		
		//counting bad values in the current window
		for(int i = 0; i < good; i++) {
			if(arr[i] > k) {
				bad++;
			}
		}
		
		int i = 0, j = good, ans = bad;
		while(j < n) {
			// if the start of window was the bad value reduce bad count by 1
			if(arr[i] > k) {
				bad--;
			}
			// if the end of window was the bad value increase bad count by 1
						if(arr[j] > k) {
							bad++;
						}
			// update ans
						ans = Math.min(ans, bad);
						i++;
						j++;  // move window by 1
			
		}
		return ans;
	 }
}



11. MOVE ALL NEGATIVE ELEMENT TO END OF AN ARRAY
package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	 public static void moveallnegativeelementtoend(int[] arr) {
	        // 0 to j-1  ->  All positive
	        // j to i-1  ->  All negative
	        // i to arr.length-1  ->  All unknowns

	        int i = 0, j = 0;
	        while (i < arr.length) {
	            if (arr[i] >= 0) {
	                swap(arr, i, j);
	                i++;
	                j++;
	            } else {
	                i++;
	            }
	        }
	    }

	    // used for swapping ith and jth elements of array
	    public static void swap(int[] arr, int i, int j) {
	        System.out.println("Swapping index " + i + " and index " + j);
	        int temp = arr[i];
	        arr[i] = arr[j];
	        arr[j] = temp;
	    }

	    public static void print(int[] arr) {
	        for (int i = 0; i < arr.length; i++) {
	            System.out.println(arr[i]);
	        }
	    }
	    public static void main(String[] args) throws Exception {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the number");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        System.out.println("Enter the number");
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        moveallnegativeelementtoend(arr);
	        print(arr);
	    }

	}


2nd method

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	 public static void moveallnegativeelementtoend(int[] arr) {
	       List<Integer> allNumbers = new ArrayList<>();
	       List<Integer> negativeNumbers = new ArrayList<>();
	       
	       for(Integer data : arr) {
	    	   if(data >= 0) {
	    		   allNumbers.add(data);
	    	   } else {
	    		   negativeNumbers.add(data);
	    	   }
	       }
	       allNumbers.addAll(negativeNumbers);
	 
	 
	    
	            System.out.println(allNumbers);
	        
	    }
	    public static void main(String[] args) throws Exception {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the number");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        System.out.println("Enter the number");
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        moveallnegativeelementtoend(arr);
	        
	    }

	}


12. 3 WAY PARTITIONING OF AN ARRAY AROUND A GIVEN VALUE

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	 public static void partition(int[] arr, int pivot, int pivot2) {
	        // 0 to j-1  ->  all elements  smaller than pivot 
	        // j to i-1  ->  all elements are greater or equal pivot and smaller or less then pivot2
	        // i to arr.length-1  ->  unknown elements

		 int i = 0, j = 0, k = arr.length - 1;
	        while (i <= k) {
	            if (arr[i] < pivot) {
	                swap(arr, i, j);
	                i++;
	                j++;
	            } else if (arr[i] >= pivot && arr[i] <= pivot2) {
	                i++;
	            } else {
	                swap(arr, i, k);
	                k--;
	            }
	        }
	    }

	    // used for swapping ith and jth elements of array
	    public static void swap(int[] arr, int i, int j) {
	        System.out.println("Swapping index " + i + " and index " + j);
	        int temp = arr[i];
	        arr[i] = arr[j];
	        arr[j] = temp;
	    }
	    public static void print(int[] arr) {
	        for (int i = 0; i < arr.length; i++) {
	            System.out.print(arr[i] + " ");
	        }
	        System.out.println();
	    }

	    public static void main(String[] args) throws Exception {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        System.out.println("Enter the value");
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        System.out.println("Enter the value");
	        int pivot = scn.nextInt();
	        int pivot2 = scn.nextInt();
	        partition(arr, pivot, pivot2);
	        print(arr);
	    }

	}


13. FIND ALL TRIPLETS FOR GIVEN SUM

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        int target = scn.nextInt();
	        System.out.println(findTriplets(arr, target));
	    }
	 public static List<List<Integer>> findTriplets(int[] arr, int targetSum) {
		 Arrays.parallelSort(arr);
		 
		 List<List<Integer>> allTriplets = new ArrayList<>();
		 
		 for(int i = 0; i < arr.length - 2; i++) {
			 int sum = targetSum - arr[i];
			 
			 int start = i + 1;
			 int end = arr.length - 1;
			 
			 while(start < end) {
				 int t = arr[start] + arr[end];
				 if(t == sum) {
					 allTriplets.add(Arrays.asList(arr[start], arr[end], arr[i]));
					 start++;
					 end--;
				 } else if(t < sum) {
					 start++;
				 } else {
					 end--;
				 }
			 }
		 }
		 return allTriplets;
	 }
}






15. FIND IF THERE IS ANY SUBARRAY WITH SUM EQUAL TO 0

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int[] arr = new int[scn.nextInt()];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	public static boolean solution(int[] arr) {
		HashMap<Integer, Integer> map = new HashMap<>();
		int mlen = 0;
		
		int i = -1;
		int sum = 0;
		map.put(sum,  i);
		while(i < arr.length - 1) {
			i++;
			sum += arr[i];
			
			if(map.containsKey(sum) == false) {
				map.put(sum, i);
			} else {
				int len = i - map.get(sum);
				if(len > mlen) {
					return true;
					
				}
			}
		}
		
		return false;
	}

}


16. SMALLEST SUBARRAY WITH SUM MORE THAN GIVEN VALUE

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        int k = scn.nextInt();
	        System.out.println(solution(arr, k, n));
	    }

	  public static long solution(int[] arr, int k, int n) {
		  
			int start = 0, end = 0;
			int ans = n + 1;
			int sum = 0;
			
			
			while(end < n) {
				while(sum <= k && end < n) {
					sum += arr[end];  
					end++;
				}
				while(sum > k && start < n) {
					ans = Math.min(ans, end - start + 1);
					sum -= arr[start];
					start++;
				}
			}
			
			return ans;
		}

	}



17. FIND WHETHER AN ARRAY IS A SUBSET OF ANOTHER ARRAY

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        
	        int m = scn.nextInt();
	        int[] arr2 = new int[m];
	        for (int i = 0; i < m; i++) {
	            arr2[i] = scn.nextInt();
	        }
	       
	        System.out.println(solution(arr, arr2 ));
	    }

	  public static boolean solution(int[] arr, int[] arr2) {
		  
		 HashSet<Integer> hset = new HashSet<>();
		 for (int i = 0; i < arr.length; i++) {
			 if(!hset.contains(arr[i])) {
				 hset.add(arr[i]);
			 }
		 }
			 for (int j = 0; j < arr2.length; j++) {
				 if(!hset.contains(arr2[j])) {
					return false;
				 } 
		 }	
	  
		 return true;

	  }
}


18. REARRANGE POSITIVE AND NEGATIVE ELEMENT ALTERNATIVELY

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        rearrange(arr, n);
	        printArray(arr, n);
	    }

	 
		public static void rearrange(int[] arr, int n) {
			int wrongIndex = -1;
			for(int i = 0; i < n; i++) {
				if(wrongIndex != -1) {
					if((arr[wrongIndex] >= 0 && arr[i] < 0) || (arr[wrongIndex] < 0 && arr[i] >= 0)) {
						rightRotate(arr, wrongIndex, i);
						
						if(i - wrongIndex >= 2) {
							wrongIndex += 2;
						} else {
							wrongIndex = -1;
						}
					}
				}
					
					else {
						if((arr[i] < 0 && i%2 == 1) || (arr[i] >= 0 && i%2 == 0)) {
							wrongIndex = i;
						}
					}
				
				public static void rightRotate(int[] arr, int from, int to) {
					int temp = arr[to];
					for(int j = to; j > from; j--) {
						arr[j] = arr[j - 1];
						arr[from] = temp;
					}
				}	
			}
		}
		  
	public	static void printArray(int arr[], int n)
		    {
		        for (int i = 0; i < n; i++)
		            System.out.print(arr[i] + " ");
		        System.out.println("");
		    }

	  
}


 







19. TRANSPOSE OF MATRIX OF N * M

import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~User Section~~~~~~~~~~~~~
  public static int[][] transpose(int[][] matrix) {
    // write your code here
    int n = matrix.length;
    int m = matrix[0].length;

    int[][] res = new int[m][n];

    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        res[i][j] = matrix[j][i];
      }
    }
    return res;
  }


  // ~~~~~~~~~~~Input Management~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();

    int[][] matrix = new int[n][m];

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = scn.nextInt();
      }
    }

    int[][] res = transpose(matrix);

    for (int i = 0; i < res.length; i++) {
      for (int j = 0; j < res[0].length; j++) {
        System.out.print(res[i][j] + " ");
      }
      System.out.println();
    }
  }
}


20. TRANSPOSE OF MATRIX OF N * N

import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~User Section~~~~~~~~~~~~~
  public static void transpose(int[][] matrix) {
    // write your code here
    int n = matrix.length;
    for (int i = 0; i < n; i++) {
      for (int j = 0; j <= i; j++) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[j][i];
        matrix[j][i] = temp;
      }
    }
  }

  // ~~~~~~~~~~~Input Management~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[][] matrix = new int[n][n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        matrix[i][j] = scn.nextInt();
      }
    }
    transpose(matrix);
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        System.out.print(matrix[i][j] + " ");
      }
      System.out.println();
    }
  }
}



                                                                                                               



22. KTH SMALLEST ELEMENT IN A SORTED MATRIX

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 



	 public static void main(String[] args) throws Exception {
			Scanner t = new Scanner(System.in);
			      System.out.println("Enter the value");
			      int n = t.nextInt();
			      System.out.println("Enter a value");
			      int[][] arr = new int[n][n];

			      for (int i = 0; i < n; i++) {
			          for (int j = 0; j < n; j++) {
			             arr[i][j] = t.nextInt();
			          }
			       }
			      System.out.println("Enter the value");
			      int k = t.nextInt();

			      PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());                 	       // max heap for smallest
			      
			      for (int i = 0; i < n; i++) {
				         for (int j = 0; j < n; j++) {
				        	  if(pq.size() < k){
						            pq.add(arr[i][j]);
						         } else {
						            if(arr[i][j] < pq.peek()){
						               pq.remove();
						               pq.add(arr[i][j]);
						            }
						         }
				         }
				      }
			      
			     
			   
			         System.out.println(pq.peek());
			      
			   }

			}


23. COMMON ELEMENTS IN ALL ROWS

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 



	 public static void main(String[] args) throws Exception {
			Scanner t = new Scanner(System.in);
			      System.out.println("Enter the value");
			      int n = t.nextInt();
			      int m = t.nextInt();
			      System.out.println("Enter a value");
			      int[][] arr = new int[n][m];

			      for (int i = 0; i < n; i++) {
			          for (int j = 0; j < m; j++) {
			             arr[i][j] = t.nextInt();
			          }
			       }
			    
			      HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
					
			   // insert elements of the first row into the map and
	                // initialize them with a value of 1
			      for (int i = 0; i < n; i++) {
			          for (int j = 0; j < m; j++) {
			        	  
			        	  map.put(arr[i][j] , 1);
			          
			       
			      
			      // from the second row onwards, check if the current element
	                // exists in the map and first in the current row
			        	  for (int i = 1; i < n; i++)
			        	    {
			        	        for (int j = 0; j < m; j++)
			        	        {
	                if (i > 0 && map.containsKey(arr[i][j]) && map.get(arr[i][j]) == i)
	                {
	                    // increment the count of the element by 1
	                    map.put(arr[i][j], i + 1);
	 
	                    // if `i` represent the last row, print the element
	                    if (i == n - 1) {
	                        System.out.print(arr[i][j] + " ");
	                    }
	                }
	            }
		   }
    }
			      }
	 }
}





                                                                                                               

24. REVERSE A STRING

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 


	public static void solution(String str){
		   int len = str.length();
	        String rev = "";
	        
	        for(int i = len - 1; i >= 0; i--){
	            rev = rev + str.charAt(i);
	        }
	        
	        System.out.println(rev);
	}

	
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String str = scn.next();
		solution(str);
	}

}
                   OR

StringBuffer sf = new StringBuffer(str);
 System.out.println(sf.reverse());


25. CHECK WHETHER STRING IS PALINDROME OR NOT

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 


	public static void solution(String str, String org_str){
		   int len = str.length();
	        String rev = "";
	        
	        for(int i = len - 1; i >= 0; i--){
	            rev = rev + str.charAt(i);
	        }
	        
	      if(org_str.equals(rev)) {
	    	  System.out.println(org_str+"  is Palindrome String");
	      }
	      else {
	    	  System.out.println(org_str+"  is not a Palindrome String"); 
	      }
	}

	
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String str = scn.next();
		String org_str = str;
		solution(str, org_str);
	}

}


class Solution {
    public boolean isPalindrome(String s) {
          int start = 0; 
        int end = s.length() - 1;
        while(start <= end) {
            while(start <= end && !Character.isLetterOrDigit(s.charAt(start))) {
                start++;
            }
            while(start <= end && !Character.isLetterOrDigit(s.charAt(end))) {
                end--;
            }
            if(start <= end && Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end))) {
                return false;
            }
            start++;
            end--;
        }
        return true;
    }
}


26. FIND DUPLICATES IN A STRING

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 


	public static void solution(String str){
		  
		HashMap<Character, Integer> fmap = new HashMap<>();
		
		for(int i = 0; i < str.length(); i++) {
			Character ch = str.charAt(i);
			
			if(fmap.containsKey(ch)) {
				fmap.put(ch, fmap.get(ch) + 1);
			} else {
				fmap.put(ch, 1);
			}
		}
		
		fmap.forEach((k, v) -> {
			if(v > 1) {
				System.out.println(k);
			}
		});
		

	}
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String str = scn.next();
		solution(str);
	}

}
                 OR


package automate;
import java.io.*;
import java.util.*;
public class MyClass { 


	public static void solution(String str){
		  
		HashSet<Character> set = new HashSet<>();
		
		for(int i = 0; i < str.length(); i++) {
			Character ch = str.charAt(i);
			
			if(set.contains(ch)) {
				System.out.println(ch);
			} else {
				set.add(ch);
			}
		}	
		

	}
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String str = scn.next();
		solution(str);
	}

}



27. KMP SUBSTRING MATCH

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 


    /**
     * Compute temporary array to maintain size of suffix which is same as prefix
     * Time/space complexity is O(size of pattern)
     */
    private int[] computeTemporaryArray(char pattern[]){
        int [] lps = new int[pattern.length];
        int index =0;
        for(int i=1; i < pattern.length;){
            if(pattern[i] == pattern[index]){
                lps[i] = index + 1;
                index++;
                i++;
            }else{
                if(index != 0){
                    index = lps[index-1];
                }else{
                    lps[i] =0;
                    i++;
                }
            }
        }
        return lps;
    }
    
    /**
     * KMP algorithm of pattern matching.
     */
    public void KMP(char []text, char []pattern){
        
        int lps[] = computeTemporaryArray(pattern);
        int i=0;
        int j=0;
        while(i < text.length && j < pattern.length){
            if(text[i] == pattern[j]){
                i++;
                j++;
            }else{
                if(j!=0){
                    j = lps[j-1];
                }else{
                    i++;
                }
            }
        }
        if(j == pattern.length){
        	 System.out.println("Found pattern "
                     + "at index " + (i - j));
  j = lps[j - 1];
        }
        
    }
        
    public static void main(String args[]){
        
        String str = "THIS IS A TEST TEXT";
        String subString = "TEST";
        MyClass ss = new MyClass();
        ss.KMP(str.toCharArray(), subString.toCharArray());
     
        
    }
}




28. LONGEST COMMON PREFIX
[cat, cable, camera] o/p = ca
class Solution {
    public String longestCommonPrefix(String[] strs) {
        
        if(strs == null || strs.length == 0){
            return "";
        }

        String lcp = strs[0];
        
        
        for(int i=1; i < strs.length; i++){
          String currWord = strs[i];
          int j = 0;
            while(j < currWord.length() && j < lcp.length() && currWord.charAt(j) == lcp.charAt(j)){
       
            j++;
        }

        if(j == 0) return "";

        lcp = currWord.substring(0, j);
        
    }
return lcp;
}


29. SPLIT STRING INTO SUBSTRINGS WITH EQUAL 0S AND 1S

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 

	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	      String str = scn.nextLine();
	        System.out.println(solution(str));
	    }

	    public static int solution(String str) {
	      
			int n = str.length();
			int x = 0, y = 0;
			int c = 0;
			
			for(int i = 0; i < n; i++) {
				if(str.charAt(i) == '0') {
					x++;
				} else {
					y++;
				}
				
				if(x == y) {
					c++;
				}
			}
				if(x != y) 
					return -1;
				
			
			return c;
	    }

	}


30. ROMAN TO INTEGER

// I can be placed before V (5) and X(10) to make 4 and 9

// X can be placed before L (50) and C(100) to make 40 and 90

// C can be placed before D (500) and X(1000) to make 400 and 900

class Solution {
    public int romanToInt(String s) {
        if(s == null || s.length() == 0){
            return 0;
        }
        
        HashMap<Character, Integer> charMap = new HashMap<>();
        
        charMap.put('I', 1);
        charMap.put('V', 5);
        charMap.put('X', 10);
        charMap.put('L', 50);
        charMap.put('C', 100);
        charMap.put('D', 500);
        charMap.put('M', 1000);
        
        int result = 0;
        for(int i = 0; i < s.length() - 1; i++) {
            
            if(charMap.get(s.charAt(i)) >= charMap.get(s.charAt(i + 1))){
                result = result + charMap.get(s.charAt(i));
            } else {
                   result = result - charMap.get(s.charAt(i));
            }
    }
    result =  result + charMap.get(s.charAt(s.length() - 1));
    
    return result;
}
}


31. INTGER TO ROMAN
class Solution {
    public String intToRoman(int num) {
        
          HashMap<String, Integer> mp = new LinkedHashMap<>();
        
        mp.put("M", 1000);
        mp.put("CM", 900);
        mp.put("D", 500);
        mp.put("CD", 400);
        mp.put("C", 100);
        mp.put("XC", 90);
        mp.put("L", 50);
           mp.put("XL", 40);
           mp.put("X", 10);
           mp.put("IX", 9);
           mp.put("V", 5);
           mp.put("IV", 4);
           mp.put("I", 1);
        
        StringBuilder sb = new StringBuilder();
        
        //Traverse a Map
        for(Map.Entry<String, Integer> entry: mp.entrySet()){
            
            while(num >= entry.getValue()){
                num = num - entry.getValue();
                sb.append(entry.getKey());
            }
        }
        return sb.toString();
    }
    
}

32. CHECK ONE STRING IS ROTATION OF ANOTHER
class Solution {
    public boolean rotateString(String A, String B) {
        
        if(A == null || B == null){
            return false;
        } else if(A.length() != B.length()){
            return false;
        }
        
        String newString = A.concat(A);
        
        if(newString.contains(B)){
            return true;
        } else {
            return false;
        }
    }
}

33. COUNT AND SAY
class Solution {
    public String countAndSay(int n) {
        if(n <= 0){
            return null;
        }
        String result = "1";
        int i = 1;
        while(i++ < n){
            StringBuilder sb = new StringBuilder();
            int count = 1;
            for(int j = 1; j <result.length(); j++){
                if(result.charAt(j) == result.charAt(j - 1)){
                    count++;
                } else {
                    sb.append(count);
                    sb.append(result.charAt(j-1));
                    count = 1;
                }
            }
              sb.append(count);
              sb.append(result.charAt(result.length()-1));
              result = sb.toString();
        }
        return result;
    }
}






35. SEARCH WORD IN A 2D GRID
TC O(N*M) SC=O(N)
class Solution {
    boolean[][] visited;
    public boolean exist(char[][] board, String word) {
      visited = new boolean[board.length][board[0].length];
        
        for(int i = 0; i < board.length; i++)
            for(int j = 0; j < board[0].length; j++)
                if(word.charAt(0) == board[i][j] && exist(board, i, j, word, 0))
                    return true;
        
        return false;
    }
    
    private boolean exist(char[][] board, int i, int j, String word, int pos){
        if(pos == word.length()) return true;
        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j]) return false;
        if(word.charAt(pos) != board[i][j]) return false;
        
        visited[i][j] = true;
        
        boolean found = exist(board, i + 1, j, word, pos + 1) ||
          exist(board, i - 1, j, word, pos + 1) ||
           exist(board, i, j + 1, word, pos + 1) ||
           exist(board, i, j - 1, word, pos + 1);
        
            
    
          
        visited[i][j] = false;
        return found;
    }
}

36. COUNT NO.OF GIVEN STRINGS IN 2D CHARACTER ARRAY
class Solution {
    
    public static void main(String[] args) {
     
int ans = 0;
int size = 5;  // GEEKS
        for(int i = 0; i < board.length; i++)
            for(int j = 0; j < board[0].length; j++)
                 solve( i, j, word, boardsize, 0)
                    
        
      
    }
    
    private int solve( int i, int j, String word, board[][], int size, int pos){
        int found = 0;
if(i >= 0 && j >= 0 && i < board.length && j < board[0].length && word[idx] == board[i][j]){
chartemp = word[idx];
board[i][j] = 0;
pos += 1;
if(pos == size){
found = 1;
} else {
        
        found += solve(board, i + 1, j, word, pos) ||
          found += solve(board, i - 1, j, word, pos + 1) ||
           found += solve(board, i, j + 1, word, pos + 1) ||
           found += solve(board, i, j - 1, word, pos + 1))
} 
board[i][j] = temp;  // backtrack
}
return found;
	}

}


37. CONVERT SENTENCE INTO ITS EQUIVALENT MOBILE NUMERIC KEYPAD
import java.util.*;
  
class GFG
{
  
    // Function which computes the sequence
    static String printSequence(String arr[],
                               String input)
    {
        String output = "";
      
        // length of input string
        int n = input.length();
        for (int i = 0; i < n; i++)
        {
            // Checking for space
            if (input.charAt(i) == ' ')
                output = output + "0";
      
            else
            {
                // Calculating index for each 
                // character
                int position = input.charAt(i) - 'A';
                output = output + arr[position];
            }
        }
      
        // Output sequence
        return output;
    }

// Driver Function
    public static void main(String[] args)
    {
        // storing the sequence in array
        String str[] = {"2","22","222",
                        "3","33","333",
                        "4","44","444",
                        "5","55","555",
                        "6","66","666",
                        "7","77","777","7777",
                        "8","88","888",
                        "9","99","999","9999"
                    };
  
        String input = "GEEKSFORGEEKS";
        System.out.println(printSequence(str, input));
    }
}


19. MINIMUM NO OF BRACKET REVERSAL TO MAKE EXPRESSION BALANCED
public class GFG
{
 
    // Method count minimum reversal for
    //making an expression balanced.
    //Returns -1 if expression cannot be balanced
    static int countMinReversals(String expr)
    {
        int len = expr.length();
     
        // length of expression must be even to make
        // it balanced by using reversals.
        if (len%2 != 0)
        return -1;
     
        // After this loop, stack contains unbalanced
        // part of expression, i.e., expression of the
        // form "}}..}{{..{"
        Stack<Character> s=new Stack<>();
         
        for (int i=0; i<len; i++)
        {
            char c = expr.charAt(i);
            if (c =='}' && !s.empty())
            {
                if (s.peek()=='{')
                    s.pop();
                else
                    s.push(c);
            }
            else
                s.push(c);
        }
     
        // Length of the reduced expression
        // red_len = (m+n)
        int red_len = s.size();
     
        // count opening brackets at the end of
        // stack
        int n = 0;
        while (!s.empty() && s.peek() == '{')
        {
            s.pop();
            n++;
        }
     
        // return ceil(m/2) + ceil(n/2) which is
        // actually equal to (m+n)/2 + n%2 when
        // m+n is even.
        return (red_len/2 + n%2);
    }
     
    // Driver method
    public static void main(String[] args)
    {
        String expr = "}}{{";
         
        System.out.println(countMinReversals(expr));
    }
 
}
      
    



38. MINIMUM FLIPS TO MAKE BINARY STRING ALTERNATE
class Solution {
    public int minOperations(String s) {
        int x = 0;
        int y = 0;
        
        for(int i = 0; i < s.length(); i++)
        {
            if(i%2 == 0 && s.charAt(i) == '1')
            {
                x++;
            }
            else if(i%2 == 1 && s.charAt(i) == '0')
            {
                x++;
            }
             if(i%2 == 0 && s.charAt(i) == '0')
            {
                y++;
            }
            else if(i%2 == 1 && s.charAt(i) == '1')
            {
                y++;
            }
        }
        return Math.min(x, y);
    }
}


39. REORGANIZE STRING SUCH THAT NO TWO ARE ADJACENT
class Solution {
    public String reorganizeString(String S) {
        Map<Character, Integer> counts = new HashMap<>();
        for(char c: S.toCharArray()){
            counts.put(c, counts.getOrDefault(c, 0) + 1);
        }
        
        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a,b) -> counts.get(b) - counts.get(a));
        maxHeap.addAll(counts.keySet());
        
        StringBuilder result = new StringBuilder();
        while(maxHeap.size() > 1){
            char current = maxHeap.remove();
            char next = maxHeap.remove();
            result.append(current);
            result.append(next);
            counts.put(current, counts.get(current) - 1);
             counts.put(next, counts.get(next) - 1);
            if(counts.get(current) > 0){
                maxHeap.add(current);
            }
             if(counts.get(next) > 0){
                maxHeap.add(next);
            }
            
        }
        if(!maxHeap.isEmpty()){
            char last = maxHeap.remove();
            if(counts.get(last) > 1){
                return "";
            }
            result.append(last);
        }
        return result.toString();
    }
}


40. REMOVE ALL ADJACENT DUPLICATES FROM STRING
class Solution {
    public String removeDuplicates(String S) {
        Stack<Character> st = new Stack<>();
        StringBuilder sb = new StringBuilder();
        
        for(int i = 0; i < S.length(); i++){
            if(!st.isEmpty() && st.peek() == S.charAt(i)){
                st.pop();
            } else {
                st.push(S.charAt(i));
            }
        }
        
        for(Character ch : st){
            sb.append(ch);
        }
        return sb.toString();
    }
}



                                                                                                 



2. STARTING POINT OF CYCLE IN LINKEDLIST
 public ListNode detectCycle(ListNode head) {
      if(head == null || head.next == null)
            return null;
        
        ListNode fast = head;
        ListNode slow = head;
        ListNode entry = head;
        
        while(fast.next != null && fast.next.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) {
                while(slow != entry){
                    slow = slow.next;
                    entry = entry.next;
                }
            return entry;
        }
    }
        return null;
    }
}
		  






		                        

          	                    
		                        

	




41. MINIMUM PLATFORMS NEEDED TO ACCOMODATE TRAINS
 
import java.util.*;

public class Main {

  public static int findPlatform(int[] arr, int[] dep) {
    Arrays.sort(arr);
    Arrays.sort(dep);

    int n = arr.length;
    int plateform = 0;

    int maxtrain = 0;
    int i = 0;
    int j = 0;

    while (i < n && j < n) {
      if (arr[i] <= dep[j]) {
        maxtrain++;
        i++;
      } else {
        maxtrain--;
        j++;
      }
      plateform = Math.max(plateform, maxtrain);
    }

    return plateform;
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    int[] dep = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    for (int i = 0; i < n; i++) {
      dep[i] = scn.nextInt();
    }

    int plateforms = findPlatform(arr, dep);
    System.out.println(plateforms);
  }
}
                                





		          	                    
42. MEETING ROOM 

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Main{
    public static boolean meetingRooms(int intervals[][]){
        // write code here
        if(intervals.length == 0 || intervals.length == 1) return true;
        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));
        
        int ep = intervals[0][1];
        
     for(int idx = 1 ; idx < intervals.length ; idx++){
            if(intervals[idx][0] < ep){
                return false;
            } else {
                ep = intervals[idx][1];
            }
        }
        
        return true;
    }
    public static void main(String args[]){
        Scanner scn = new Scanner(System.in);

        // Input Format
        int n = scn.nextInt();
        int input[][] = new int[n][2];

        for(int i = 0 ; i <  n ; i++){
            int sp = scn.nextInt();
            int ep = scn.nextInt();

            input[i][0] = sp;
            input[i][1] = ep;
        }

        // Output Format
        boolean res = meetingRooms(input);
        System.out.println(res);
    }



43 MERGE INTERVAL


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Main{
    public static int[][] mergeIntervals(int Intervals[][]){
        Arrays.sort(Intervals, (a,b) -> Integer.compare(a[0], b[0]));

        ArrayList<int[]> res = new ArrayList<>();

        for(int interval[] : Intervals){
            if(res.size() == 0){
                res.add(interval);
            }else{
                int prevInterval[] = res.get(res.size()-1);
                if(interval[0] < prevInterval[1]){
                    prevInterval[1] = Math.max(prevInterval[1],interval[1]);
                }else{
                    res.add(interval);
                }
            }
        }

        return res.toArray(new int[res.size()][]);
    }
    public static void main(String args[]){
        Scanner scn = new Scanner(System.in);

        // Input Format
        int n = scn.nextInt();
        int input[][] = new int[n][2];

        for(int i = 0 ; i <  n ; i++){
            int sp = scn.nextInt();
            int ep = scn.nextInt();

            input[i][0] = sp;
            input[i][1] = ep;
        }

        // Output Format
        int [][]output = mergeIntervals(input);

        System.out.print("[");
        for(int arr[] : output){
            System.out.print(Arrays.toString(arr));
        }
        System.out.println("]");
    }
}



44.  INSERT INTERVAL

import java.util.*;

public class Main {

  public static int[][] insertIntervals(int intervalList[][], int newInterval[]) {
    ArrayList<int[]> ans = new ArrayList<>();
    int idx = 0;
    while (idx < intervalList.length) {
      if (intervalList[idx][0] < newInterval[0]) {
        ans.add(intervalList[idx]);
        idx++;
      } else {
        break;
      }
    }

    if (ans.size() == 0 || newInterval[0] > ans.get(ans.size() - 1)[1]) {
      ans.add(newInterval);
    } else {
      int lastInterval[] = ans.get(ans.size() - 1);
      lastInterval[1] = Math.max(lastInterval[1] , newInterval[1]);
    }

    while (idx < intervalList.length) {
      int lastInterval[] = ans.get(ans.size() - 1);
      if (intervalList[idx][0] <= lastInterval[1]) {
        lastInterval[1] = Math.max(lastInterval[1], intervalList[idx][1]);
      } else {
        ans.add(intervalList[idx]);
      }
      idx++;
    }

    return ans.toArray(new int[ans.size()][]);
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int intervalList[][] = new int[n][2];
    for (int i = 0 ; i < n ; i++) {
      int st = scn.nextInt();
      int et = scn.nextInt();

      intervalList[i][0] = st;
      intervalList[i][1] = et;
    }
    int newInterval[] = new int[2];
    newInterval[0] = scn.nextInt();
    newInterval[1] = scn.nextInt();

    int ans[][] = insertIntervals(intervalList, newInterval);

    System.out.print("[");
    for (int interval[] : ans) {
      System.out.print(Arrays.toString(interval));
    }
    System.out.println("]");

  }
}





45. POLICE AND THIEVES
package automate;
import java.io.*;
import java.util.*;
class MyClass {
	
	public static void main(String args[]) {
		Scanner t = new Scanner(System.in);
		System.out.println("Enter the value");
		int n = t.nextInt();
		char[] arr = t.next().toCharArray();
		
		int k = t.nextInt();
		System.out.println(catchthieves(arr, n, k));
	}
	
	public static int catchthieves(char[] arr, int n, int k) {
		
		ArrayList<Integer> th = new ArrayList<>();
		ArrayList<Integer> p = new ArrayList<>();
		
		for(int i = 0; i < n; i++) {
			if(arr[i] == 'P') {
				p.add(i);
			} else {
				th.add(i);
			}
		}
			
			int s_t = 0;
			int s_p = 0;
			
			int ans = 0;
			
			while(s_t < th.size() && s_p < p.size()) {
				if(Math.abs(th.get(s_t) - p.get(s_p)) <= k) {
					ans++;
					s_t++;
					s_p++;
				} else if(th.get(s_t) < p.get(s_p))
					s_t++;
				else 
					s_p++;
			}
			
		return ans;
		
	}
	
}



		          	                    

46. MINIMUM COINS NEEDED
class Solution {
    public int coinChange(int[] coins, int amount) {
        
       if(coins.length == 0 || amount <= 0){
           return 0;
       }
        
        int numberofcoins = coins.length;
        
        int[][] arr = new int[numberofcoins][amount + 1];
        
        for(int i = 0; i < numberofcoins; i++){
            arr[i][0] = 0;
        }
        
        for(int i = 0; i < numberofcoins; i++){
            for(int j = 1; j <= amount; j++){
                
                int includingCurrentCoin = Integer.MAX_VALUE;
                int excludingCurrentCoin = Integer.MAX_VALUE;
                
                if(coins[i] <= j){
                    includingCurrentCoin = 1 + arr[i][j - coins[i]];
                }
                
                if ( i > 0){
                    excludingCurrentCoin =  arr[i - 1][j];
                }
                
                arr[i][j] = Math.min(includingCurrentCoin, excludingCurrentCoin);
            }
        }
        
        return arr[numberofcoins - 1][amount];
        
    }    
}


47. JOB SEQUENCING

	  
	  public static int[] JobScheduling(ArrayList<MyClass> arr, int n) {
		  
		 int n = startTime.length;
         Job[] arr = new Job[n];
        
        for(int i=0; i < n; i++){
             Job job = new Job(startTime[i], endTime[i], profit[i]);
             arr[i] = job;
        }
        
        Arrays.sort(arr, (a,b) -> (a.endtime - b.endtime));
		  
		  int maxi = 0;
		  for(int i = 0; i < n; i++) {
			  if(arr.[i].deadline  > maxi) {
				  maxi = arr.[i].deadline;
			  }
		  }
		  
		 int result[] = new int[maxi + 1];
		 
		 for(int i = 1; i <= maxi; i++) {
			 result[i] = -1;
		 }
		 
		 int countJobs = 0, jobProfit = 0;
		 
		 for(int i = 0; i < n; i++) {
			 for(int j = arr[i].deadline; j > 0; j--) {
				 
				 //free slot found
				 if(result[j] == -1) {
					 result[j] = i;
					 countJobs++;
					 jobProfit += arr[i].profit;
					 break;
				 }
			 }
		 }
		 
		 int ans[] = new int[2];
		 ans[0] = countJobs;
		 ans[1] = jobProfit;
		 return ans;
	  }
	}




48. FRACTIONAL KNAPSACK

class Solution
{
   public  class Items implements Comparable<Items>{
     int val;
     int wt;
     double r;
     
     Items(int val, int wt, double r){
         this.val = val;
         this.wt = wt;
         this.r = r;
     }
     
     public int compareTo(Items o){
         if(o.r > this.r){
             return 1;
         }
         else if(o.r < this.r){
             return -1;
         }
         else {
             return 0;
         }
     }
 }
 
    double fractionalKnapsack(int W, Item arr[], int n) 
    {
        Items[] items = new Items[n];
        
        for(int i=0; i< n; i++){
            double r = (values[i]*1.0) / weight[i];
            Item item = new Item(values[i], weight[i], r);
            items[i] = item;
        }
        
        Arrays.sort(items);
        
        double vib = 0;
        int rc = W;
        
        for(int i=0; i < items.length; i++){
            if(items[i].wt <= rc){
                vib += items[i].val;
                rc -= items[i].wt;
            }
            else {
                vib += items[i].val * ((double)rc / items[i].wt);
                rc = 0;
                break;
            }
        }
        return vib;
    }
}







49. LARGEST NUMBER FROM ARRAY

import java.util.*;
import java.io.*;

public class Main {

  public static String largestNumber(int[]nums) {
    //write your code here
    String[]arr = new String[nums.length];

    for (int i = 0; i < nums.length; i++) {
      arr[i] = nums[i] + "";
    }

    Arrays.sort(arr, (a, b)-> {
      long v1 = Long.parseLong(a + b);
      long v2 = Long.parseLong(b + a);

      if (v1 > v2) {
        return 1;
      }
      else if (v1 < v2) {
        return -1;
      }
      else {
        return 0;
      }
    });

    StringBuilder sb = new StringBuilder("");

    for (int i = arr.length - 1; i >= 0; i--) {
      sb.append(arr[i]);
    }

    if (sb.charAt(0) == '0') {
      return "0";
    }

    return sb.toString();
  }

  public static void main(String[]args) {
    //input work
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[]nums = new int[n];

    for (int i = 0; i < n; i++) {
      nums[i] = scn.nextInt();
    }

    System.out.println(largestNumber(nums));
  }
}

MAXIMUM SUBARRAY MIN PRODUCT

class Solution {
    public int maxSumMinProduct(int[] nums) {
        int n = nums.length;
        long[] psum = new long[n+1];
        
        for(int i=0; i < n; i++){
            psum[i+1] = psum[i] + nums[i];
        }
        
        int[] smallerOnLeft = NSEL(nums);
        int[] smallerOnRight = NSER(nums);
        
        long max = Long.MIN_VALUE;
        
        for(int i=0; i < n; i++){
            int min = nums[i];
            int lr = smallerOnLeft[i];
            int rr = smallerOnRight[i];
            
            long sum = psum[rr] - psum[lr+1];
            long minProduct = min * sum;
            max = Math.max(minProduct, max);
        }
        
        return (int)(max%1000000007);
    }
    
    public int[] NSEL(int nums[]){
        Stack<Integer> st = new Stack<>();
        
        int[] res = new int[nums.length];
        
        for(int i=0; i < nums.length; i++){
            while(st.size() > 0 && nums[st.peek()] >= nums[i]){
                st.pop();
            }
            
            if(st.size() == 0){
                res[i] = -1;
            }
            else {
                res[i] = st.peek();
            }
            st.push(i);
        }
        return res;
    }
    
    
     public int[] NSER(int nums[]){
        Stack<Integer> st = new Stack<>();
        
        int[] res = new int[nums.length];
        
        for(int i=nums.length-1; i >= 0; i--){
            while(st.size() > 0 && nums[st.peek()] >= nums[i]){
                st.pop();
            }
            
            if(st.size() == 0){
                res[i] = nums.length;
            }
            else {
                res[i] = st.peek();
            }
            st.push(i);
        }
        return res;
    }
}


50. FAULTY KEYBOARD

import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~~~~~

    public static boolean isPossible(String name, String typed) {
        // Write your code here
        if(name.length() > typed.length()) return false;
        
        int i = 0;
        int j = 0;
        
        while(i != name.length() && j != typed.length()) {
            if(name.charAt(i) == typed.charAt(j)) {
                i++;
                j++;
            } else if(i > 0 && name.charAt(i - 1) == typed.charAt(j)) {
                j++;
            } else {
                return false;
            }
        }
        
        while(j < typed.length()) {
            if(typed.charAt(j) != name.charAt(i - 1)) return false; 
            j++;
        }
        
        return i < name.length() ? false : true;
    }

    // ~~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~~~

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        
        String name = scn.next();
        String typed = scn.next();

        boolean res = isPossible(name, typed);

        System.out.println(res);
    }
}



	                        
32. MINIMUM COST OF ROPE

package automate;
import java.io.*;
import java.util.*;

public class MyClass {   
	
	

	   public static void main(String[] args) throws Exception {
		   Scanner t = new Scanner(System.in);
		   System.out.println("Enter the value");
		   int n = t.nextInt();
		   
		   int[] arr = new int[n];
		   
		   for(int i = 0; i < arr.length; i++) {
			   arr[i] = t.nextInt();
		   }
		   
		   System.out.println(minCost(arr));
		   
	   }
	   
	   public static int minCost(int arr[]) { 
		   PriorityQueue<Integer> minHeap = new PriorityQueue<>();
		    
		    for (int i = 0; i < arr.length; i++){
		        minHeap.add(arr[i]);
		    }
		    
		    int mincost = 0;
		    
		    while(minHeap.size() > 1){
		        
		        int tempcost = minHeap.poll() + minHeap.poll();
		        mincost = mincost + tempcost;
		        
		        minHeap.add(tempcost);
		    }
		    
		    return mincost;
	   }
	}


	                        








52. K CLOSEST ORIGIN

  
    class Point {
        int x;
        int y;
    }
    

    
     Point(int x, int y){
        this.x = x;
        this.y = y;
    }

}  
(n+k(logn))  nlogn for sorting and for k is klogn

    public int[][] kClosest(int[][] points, int k) {
        if(points.length == 0) return new int[0][0];
        
        // List<Point> is taken to handle the case where multiple points have same distance {[0,1] , [1,0]}
        
        Map<Double, List<Point>> map = new TreeMap<>();
        
        for(int[] point : points){
            double distance = Math.sqrt(point[0]*point[0] + point[1]*point[1]);
            
            List<Point> values = map.get(distance);
            
            if(values == null){
                values = new ArrayList<>();
            }
            
            values.add(new Point(point[0], point[1]));
            
            map.put(distance, values);
        }
        
        int[][] result = new int[k][2];
        
        for(Map.Entry<Double, List<Point>> entry : map.entrySet()) {
            
            for(Point value : entry.getValue()){
                
                if(k <= 0){
                    break;
                }
                
                result[k-1][0] = value.x;
                result[k-1][1] = value.y;
                
                k--;
            }
        }
        
        return result;
    }

53. GRID UNIQUE PATH

class Solution {
    public int uniquePaths(int m, int n) {
        
        int N = n + m - 2;
        int r = m - 1;
        double res = 1;
        
        for(int i = 1; i <= r; i++){
            res = res *(N - r + i) / i;
        }
        
        return (int)res;
    }
}




58. MAXIMUM LENGTH PAIR CHAIN

class Solution {
    public int findLongestChain(int[][] pairs) {
        int cur = Integer.MIN_VALUE;
        int res = 0;
        
        Arrays.sort(pairs, (a, b) -> {
            return a[1] - b[1];
        });
        
        for(int[] pair : pairs){
            if(cur < pair[0]) {
                cur = pair[1];
                res++;
            }
        }
        return res;
    }
}
        
        





54. HOUSE ROBBER

class Solution {
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        if(nums.length == 1){
            return nums[0];
        }
        if(nums.length == 2){
            return Math.max(nums[0], nums[1]);
        }
        
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        
        for(int i = 2; i < dp.length; i++){
            dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
        }
        
        return dp[nums.length - 1];
    }
}








55. FIND MINIMUM NO OF ARROWS NEEDED TO BURST BALLOON

import java.util.Arrays;
import java.util.Scanner;

public class Main {
  public static int minArrows(int coordinates[][]) {
    Arrays.sort(coordinates, (a, b) -> Integer.compare(a[1], b[1]));

    int end = coordinates[0][1], arrow = 1;

    for (int i = 1; i < coordinates.length ; i++) {
      if (coordinates[i][0] > end) {
        end = coordinates[i][1];
        arrow++;
      }
    }

    return arrow;
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt(); // number of balloons
    int coordinates[][] = new int[n][2];
    for (int i = 0 ; i < n ; i++) {
      coordinates[i][0] = scn.nextInt();
      coordinates[i][1] = scn.nextInt();
    }

    System.out.println(minArrows(coordinates));
  }
}
                                


78. VALID PALINDROME 2

import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~
  private static boolean isPalindrome(String s, int i, int j) {
    while (i <= j) {
      if (s.charAt(i) == s.charAt(j)) {
        i++;
        j--;
      } else {
        return false;
      }
    }
    return true;
  }

  public static boolean validPalindrome(String s) {
    int i = 0;
    int j = s.length() - 1;

    while (i <= j) {
      if (s.charAt(i) == s.charAt(j)) {
        i++;
        j--;
      } else {
        return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
      }
    }
    return true;
  }

  // ~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();

    boolean res = validPalindrome(str);
    System.out.println(res);
  }
}


79. ADD STRINGS

import java.util.*;

public class Main {

  public static String addStrings(String num1, String num2) {
    String res = "";

    int i = num1.length() - 1;
    int j = num2.length() - 1;

    int carry = 0;
    while (i >= 0 || j >= 0 || carry != 0) {
      int ival = i >= 0 ? num1.charAt(i) - '0' : 0;
      int jval = j >= 0 ? num2.charAt(j) - '0' : 0;

      int sum = ival + jval + carry;
      res = (sum % 10) + res;
      carry = sum / 10;

      i--;
      j--;
    }

    return res;
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String n1 = scn.nextLine();
    String n2 = scn.nextLine();

    String res = addStrings(n1, n2);
    System.out.println(res);
  }
}                           



56. FIRST BAD VERSION

import java.util.*;
import java.io.*;

public class Main {

  public static int firstBadVersion(int n) {
    //write your code here
    int lo = 1;
    int hi = n;
    int fbv = -1;

    while (lo <= hi) {
      int mid = lo + (hi - lo) / 2;

      if (isBadVersion(mid) == true) {
        fbv = mid;
        hi = mid - 1;
      }
      else {
        lo = mid + 1;
      }
    }

    return fbv;
  }

  static int bad = 0;
  public static boolean isBadVersion(int val) {
    if (val >= bad) {
      return true;
    }
    else {
      return false;
    }
  }

  public static void solve(int n, int fbv) {
    bad = fbv;
    System.out.println(firstBadVersion(n));
  }

  public static void main(String[]args) {
    //input work
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int fbv = scn.nextInt();

    solve(n, fbv);
  }
}







57. BOATS TO SAVE PEOPLE

import java.util.*;

public class Main {

  public static int numRescueBoats(int[] people, int limit) {
    int ans = 0;
    int i = 0;
    int j = people.length - 1;

    Arrays.sort(people);

    while (i <= j) {
      if (people[i] + people[j] > limit) {
        j--;
        ans++;
      } else {
        ans++;
        i++;
        j--;
      }
    }

    return ans;
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] people = new int[n];

    for (int i = 0; i < n; i++)
      people[i] = scn.nextInt();

    int limit = scn.nextInt();
    int boats = numRescueBoats(people, limit);
    System.out.println(boats);
  }
}


58. REVERSE VOWELS OF A STRING

import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~User Section~~~~~~~~~~~
  public static boolean isVowel(char[] arr, int indx) {
    char ch = arr[indx];
    if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||
        ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {
      return true;
    }
    return false;
  }

  public static void swap(char[] arr, int a, int b) {
    char temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
  }

  public static String reverseVowels(String s) {
    char[] arr = s.toCharArray();
    int left = 0;
    int right = s.length() - 1;

    while (left < right) {
      while (left < right && isVowel(arr, left) == false) {
        left++;
      }
      while (left < right && isVowel(arr, right) == false) {
        right--;
      }
      swap(arr, left, right);
      left++;
      right--;
    }

    String str = "";
    for (char ch : arr) {
      str += ch;
    }
    return str;
  }

  // ~~~~~~~~~~~~Input Management~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();

    String res = reverseVowels(str);
    System.out.println(res);
  }
}



59. SIEVE OF ERATHONESIS

import java.util.*;

public class Main {
    
    // ~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~
    public static void printPrimeUsingSieve(int n) {
        boolean[] isPrime = new boolean[n + 1];

        Arrays.fill(isPrime, true);

        for(int i = 2; i * i <= n; i++) {
            if(isPrime[i] == true) {
                for(int j = i + i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        for(int i = 2; i < isPrime.length; i++) {
            if(isPrime[i] == true) {
                System.out.print(i + " ");
            }
        }
        System.out.println();
    }

    // ~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~
    public static void main(String[] args) {   
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        printPrimeUsingSieve(n);
    }
}


60. INTERVAL LIST INTERSECTION

Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
  public static int[][] intersection(int intervalList1[][], int intervalList2[][]) {
    ArrayList<int[]> ans = new ArrayList<>();

    int i = 0, j = 0;

    while (i < intervalList1.length && j < intervalList2.length) {
      int cSP = Math.max(intervalList1[i][0], intervalList2[j][0]);
      int cEP = Math.min(intervalList1[i][1], intervalList2[j][1]);

      if (cSP <= cEP) {
        int tmp[] = {cSP, cEP};
        ans.add(tmp);
      }

      if (intervalList1[i][1] < intervalList2[j][1]) {
        i++;
      } else {
        j++;
      }
    }

    return ans.toArray(new int[ans.size()][]);
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    // Input format
    int n = scn.nextInt();
    int list1[][] = new int[n][2];
    for (int i = 0 ; i < n ; i++) {
      list1[i][0] = scn.nextInt();
      list1[i][1] = scn.nextInt();
    }

    int m = scn.nextInt();
    int list2[][] = new int[m][2];
    for (int i = 0 ; i < m ; i++) {
      list2[i][0] = scn.nextInt();
      list2[i][1] = scn.nextInt();
    }

    // output
    int ans[][] = intersection(list1, list2);
    System.out.print("[");
    for (int interval[] : ans) {
      System.out.print(Arrays.toString(interval));
    }
    System.out.println("]");
  }
}



61. CAR POOLING

import java.util.Scanner;

public class Main {
  public static boolean carPooling(int trips[][], int cap) {
    int lastDropLocation = -1;
    for (int trip[] : trips) {
      lastDropLocation = Math.max(lastDropLocation, trip[1]);
    }

    int highway[] = new int[lastDropLocation + 1];
    for (int trip[] : trips) {
      highway[trip[0]] += trip[2];
      highway[trip[1]] += -trip[2];
    }

    for (int i = 1 ; i <= lastDropLocation ; i++) {
      highway[i] += highway[i - 1];
      if (highway[i] > cap) {
        return false;
      }
    }

    return true;
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int trips[][] = new int[n][3];
    for (int i = 0 ; i < n ; i++) {
      trips[i][0] = scn.nextInt();
      trips[i][1] = scn.nextInt();
      trips[i][2] = scn.nextInt();
    }
    int cap = scn.nextInt();

    if (carPooling(trips, cap)) {
      System.out.println("YES");
    } else {
      System.out.println("NO");
    }

  }
}

                                

62. TWO SUM TARGET UNIQUE PAIR

import java.util.*;

public class Main {

  // ~~~~~~~~~~~~User Section~~~~~~~~~~~~
  public static List<List<Integer>> twoSum(int[] arr, int target) {
    List<List<Integer>> res = new ArrayList<>();
    int left = 0;
    int right = arr.length - 1;
    Arrays.sort(arr);
    while (left < right) {
      if (left != 0 && arr[left] == arr[left - 1]) {
        left++;
        continue;
      }
      int sum = arr[left] + arr[right];
      if (sum == target) {
        List<Integer> list = new ArrayList<>();
        list.add(arr[left]);
        list.add(arr[right]);
        res.add(list);

        left++;
        right--;
      } else if (sum > target) {
        right--;
      } else {
        left++;
      }
    }
    return res;
  }

  // ~~~~~~~~~~Input Management~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int target = scn.nextInt();
    List<List<Integer>> res = twoSum(arr, target);
    ArrayList<String> finalResult = new ArrayList<>();
    for (List<Integer> list : res) {
      Collections.sort(list);
      String ans = "";
      for (int val : list) {
        ans += val + " ";
      }
      finalResult.add(ans);
    }
    Collections.sort(finalResult);
    for (String str : finalResult) {
      System.out.println(str);
    }
  }
}





63. WIGGLE SORT 1
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
         int i = 0, j = 1, n = A.length;
        while (i < n && j < n) {
            while (i < n && A[i] % 2 == 0) {
                i += 2;
            }
            while (j < n && A[j] % 2 == 1) {
                j += 2;
            }
            if (i < n && j < n) {
                swap(A, i, j);
            }
        }
        return A;

import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~
  private static void swap(int[] arr, int a, int b) {
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
  }

  public static void wiggleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
      if (i % 2 == 0) {
        if (arr[i] > arr[i + 1]) {
          swap(arr, i, i + 1);
        }
      } else {
        if (arr[i] < arr[i + 1]) {
          swap(arr, i, i + 1);
        }
      }
    }
  }

  // ~~~~~~~~~~~~Input Management~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);

    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    wiggleSort(arr);

    for (int val : arr) {
      System.out.print(val + " ");
    }
    System.out.println();
  }

}


 64 . WIGGLE SORT 2
 reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....
Input: nums = [1,5,1,1,6,4]
Output: [1,6,1,5,1,4]
Explanation: [1,4,1,5,1,6] is also accepted.

class Solution {
    public void wiggleSort(int[] nums) {
         Arrays.sort(nums);
    int[] res = new int[nums.length];
    int j = nums.length - 1;
    int index = 1;
    while (index < nums.length) {
      res[index] = nums[j--];
      index += 2;
    }
    index = 0;
    while (index < nums.length) {
      res[index] = nums[j--];
      index += 2;
    }
    for (int i = 0; i < res.length; i++) {
      nums[i] = res[i];
    }
    }
}

64. MULTIPLY STRINGS

import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~
  public static String multiplication(String num1, String num2) {
    if (num1.equals("0") || num2.equals("0")) return "0";
    int l1 = num1.length();
    int l2 = num2.length();

    int[] res = new int[l1 + l2];

    int i = l2 - 1;
    int pf = 0;

    while (i >= 0) {
      int ival = i >= 0 ? num2.charAt(i) - '0' : 0;
      i--;

      int j = l1 - 1;
      int k = res.length - 1 - pf;

      int carry = 0;
      while (j >= 0 || carry != 0) {
        int jval = j >= 0 ? num2.charAt(j) - '0' : 0;
        j--;

        int prod = ival * jval + carry + res[k];
        res[k] = prod % 10;
        carry = prod / 10;
        k--;
      }
      pf++;
    }

    boolean flag = false;
    String str = "";
    for (int val : res) {
      if (val == 0 && flag == false) {
        continue;
      } else {
        flag = true;
        str += val;
      }
    }
    return str;
  }

  //~~~~~~~~~~~~Input Management~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);

    String str1 = scn.nextLine();
    String str2 = scn.nextLine();

    String res = multiplication(str1, str2);
    System.out.println(res);
  }
}


64. PASCAL TRIANGLE II

import java.util.*;

public class Main {

  // ~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~
  public static ArrayList<Integer> pascalRow(int r) {
    ArrayList<Integer> list = new ArrayList<>();
    int val = 1;
    for (int c = 0; c <= r; c++) {
      list.add(val);
      val = val * (r - c) / (c + 1);
    }

    return list;
  }

  // ~~~~~~~~~~~Input management~~~~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    ArrayList<Integer> res = pascalRow(n);
    for (int val : res) {
      System.out.print(val + " ");
    }
    System.out.println();
  }
}



65. PARTITION LABEL

import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~
  public static List<Integer> partitionLabels(String s) {
    HashMap<Character, Integer> map = new HashMap<>();
    List<Integer> res = new ArrayList<>();

    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);
      map.put(ch, i);
    }

    int max = 0;
    int prev = -1;
    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);
      max = Math.max(max, map.get(ch));
      if (max == i) {
        res.add(max - prev);
        prev = max;
      }
    }

    return res;
  }

  // ~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();

    List<Integer> res = partitionLabels(str);
    for (int val : res) {
      System.out.print(val + " ");
    }
  }
}


66. MEETING ROOM II

import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Scanner;


public class Main {
  public static int meetingRoomsUsingPQ(int intervals[][]) {
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    for (int interval[] : intervals) {
      if (pq.size() == 0) {
        pq.add(interval[1]);
      } else {
        if (interval[0] < pq.peek()) {
          pq.add(interval[1]);
        } else {
          pq.remove();
          pq.add(interval[1]);
        }
      }
    }

    return pq.size();
  }
  public static int meetingRoomsUsingCO(int intervals[][]) {
    int et[] = new int[intervals.length], st[] = new int[intervals.length];
    for (int i = 0; i < intervals.length; i++) {
      et[i] = intervals[i][1];
      st[i] = intervals[i][0];
    }

    Arrays.sort(et);
    Arrays.sort(st);

    int ePtr = 0, sPtr = 0, count = 0;
    while (sPtr < intervals.length) {
      if (et[ePtr] > st[sPtr]) {
        count++;
        sPtr++;
      } else {
        sPtr++;
        ePtr++;
      }
    }


67. MAXIMUM AVERAGE SUBARRAY I

import java.util.Scanner;

public class Main {
  public static double solution(int nums[], int k) {
    int sum = 0;
    for (int i = 0 ; i < k ; i++) {
      sum += nums[i];
    }
    int max = sum;
    for (int i = k ; i < nums.length ; i++) {
      sum += nums[i];
      sum -= nums[i - k];
      max = Math.max(max, sum);
    }
    return (max * 1.0) / k;
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int nums[] = new int[n];
    for (int i = 0 ; i < n ; i++) {
      nums[i] = scn.nextInt();
    }
    int k = scn.nextInt();

    System.out.println(solution(nums, k));
  }
}


68. MINIMUM LENGTH OF STRING AFTER REMOVING SIMILAR ENDS

nput: s = "aabccabba"
Output: 3
Explanation: An optimal sequence of operations is:
- Take prefix = "aa" and suffix = "a" and remove them, s = "bccabb".
- Take prefix = "b" and suffix = "bb" and remove them, s = "cca".

import java.util.Scanner;
public class Main {
  public static int minLen(String s) {
    int l = 0, r = s.length() - 1;
    while (l < r && s.charAt(l) == s.charAt(r)) {
      char ch = s.charAt(l);
      while (l < r && ch == s.charAt(l)) {
        l++;
      }
      while (l <= r && ch == s.charAt(r)) {
        r--;
      }
    }
    return r - l + 1;
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);

    String inp = scn.nextLine();
    int len = minLen(inp);

    System.out.println(len);
  }
}

                                

    return count;
  }
  public static void main(String args[]) {
    Scanner scn = new Scanner(System.in);

    // Input Format
    int n = scn.nextInt();
    int input[][] = new int[n][2];

    for (int i = 0 ; i <  n ; i++) {
      int sp = scn.nextInt();
      int ep = scn.nextInt();

      input[i][0] = sp;
      input[i][1] = ep;
    }

    // Output Format
    // System.out.println(meetingRoomsUsingPQ(input));
    System.out.println(meetingRoomsUsingCO(input));

  }
}
                                



69. MINIMUM DOMINO ROTATION FOR EQUAL ROW

import java.util.*;

public class Main {

  public static int minDominoRotations(int[] tops, int[] bottoms) {
    int count1 = 0, count2 = 0, count3 = 0, count4 = 0;

    int num1 = tops[0];
    int num2 = bottoms[0];

    for (int i = 0; i < tops.length; i++) {
      // count 1 is count of rotation if top array have num1
      if (count1 != Integer.MAX_VALUE) {
        if (tops[i] == num1) {
          // nothing to do for count
        } else if (bottoms[i] == num1) {
          count1++;
        } else {
          count1 = Integer.MAX_VALUE;
        }
      }

      // count 2 is count of rotation if bottom array have num1
      if (count2 != Integer.MAX_VALUE) {
        if (bottoms[i] == num1) {
          // nothing to do
        } else if (tops[i] == num1) {
          count2++;
        } else {
          count2 = Integer.MAX_VALUE;
        }
      }

      // count 3 is count of rotation if top array have num2
      if (count3 != Integer.MAX_VALUE) {
        if (tops[i] == num2) {
          // nothing to do for count
        } else if (bottoms[i] == num2) {
          count3++;
        } else {
          count3 = Integer.MAX_VALUE;
        }
      }

      // count 4 is count of rotation if bottom array have num2
      if (count4 != Integer.MAX_VALUE) {
        if (bottoms[i] == num2) {
          // nothing to do
        } else if (tops[i] == num2) {
          count4++;
        } else {
          count4 = Integer.MAX_VALUE;
        }
      }
    }

    int ans = Math.min(Math.min(count1, count2), Math.min(count3, count4));

    return ans == Integer.MAX_VALUE ? -1 : ans;
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] top = new int[n];
    int[] bottom = new int[n];

    // read top
    for (int i = 0; i < top.length; i++) {
      top[i] = scn.nextInt();
    }
    // read bottom
    for (int i = 0; i < bottom.length; i++) {
      bottom[i] = scn.nextInt();
    }

    int rotation = minDominoRotations(top, bottom);
    System.out.println(rotation);
  }
}
                                


70. MAXIMUM SWAP

import java.util.*;

public class Main {

  public static void swap(char[] arr, int i, int j) {
    char temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  public static String maximumSwap(String num) {
  String num = Integer.toString(nums); // int to string conversion  123 to "123"
    char[] arr = num.toCharArray();

    int[] iarr = new int[10];  // last index of digit
    for (int i = 0; i < arr.length; i++) {
      iarr[arr[i] - '0'] = i;
    }

    boolean flag = false;
    for (int i = 0; i < arr.length; i++)  {
      for (int j = 9; j > arr[i] - '0'; j--) {
        if (iarr[j] > i) {
          swap(arr, iarr[j], i);
          flag = true;
          break;
        }
      }
      if (flag == true) {
        break;
      }
    }

    String res = "";
    for (int i = 0; i < arr.length; i++) {
      res += arr[i];
    }
    return res;
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();
    String ans = maximumSwap(str);
    System.out.println(ans);
  }
}


71. NO. OF SUBARRAYS WITH BOUNDED MAXIMUM

import java.util.*;

public class Main {

  public static int numSubarrayBoundedMax(int[] arr, int left, int right) {
    int si = 0;
    int ei = 0;
    int count = 0;
    int prevc = 0;

    while (ei < arr.length) {
      if (arr[ei] >= left && arr[ei] <= right) {
        prevc = ei - si + 1;
        count += prevc;
      } else if (arr[ei] < left) {
        count += prevc;
      } else {
        prevc = 0;
        si = ei + 1;
      }
      ei++;
    }
    return count;
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    int left = scn.nextInt();
    int right = scn.nextInt();

    int count = numSubarrayBoundedMax(arr, left, right);
    System.out.println(count);
  }
}                                
  




72. MEDIAN OF MATRIX

public class Solution {
    private int countSmallerThanMid(ArrayList<Integer> row, int mid) {
        int l = 0, h = row.size() - 1; 
        while(l <= h) {
            int md = (l + h) >> 1; 
            if(row.get(md) <= mid) {
                l = md + 1;
            }
            else {
                h = md - 1;
            }
        }
        return l; 
    }
    public int findMedian(ArrayList<ArrayList<Integer>> A) {
        int low = Integer.MIN_VALUE;
        int high = Integer.MAX_VALUE; 
        int n = A.size();
        int m = A.get(0).size(); 
        while(low <= high) {
            int mid = (low + high) >> 1; 
            int cnt = 0;
            for(int i = 0;i<n;i++) {
                cnt += countSmallerThanMid(A.get(i), mid); 
            }
    
            if(cnt <= (n * m) / 2) low = mid + 1; 
            else high = mid - 1; 
        }
        return low; 
    }
}



73. FIRST MISSING POSITIVE

class Solution {
    public int firstMissingPositive(int[] nums) {
         int n = nums.length;
    boolean one = false;
    for (int i = 0; i < n; i++) {
      if (nums[i] == 1)
        one = true;

      if (nums[i] < 1 || nums[i] > n) {
        nums[i] = 1;
      }
    }

    if (one == false) return 1;

    for (int i = 0; i < n; i++) {
      int indx = Math.abs(nums[i]);
      nums[indx - 1] = -Math.abs(nums[indx - 1]);
    }

    for (int i = 0; i < n; i++) {
      if (nums[i] > 0) {
        return i + 1;
      }
    }
    return n + 1;
    }
}


74. FIND ALL DUPLICATES IN AN ARRAY
Input: nums = [4,3,2,7,8,2,3,1]
import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~~~User's Section~~~~~~~~~~~~~~~~~
  public static List<Integer> findDuplicates(int[] nums) {
    List<Integer> res = new ArrayList<>();

    for (int i = 0; i < nums.length; i++) {
      int indx = Math.abs(nums[i]) - 1;
      int val = nums[indx];

      if (val < 0) {
        res.add(indx + 1);
      } else {
        nums[indx] *= -1;
      }
    }
    return res;
  }




FIND ALL NUMBER DISSAPPERED IN AN ARRAY

Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]

class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> ans = new ArrayList<>();
       
        for(int num: nums){
            
            int index = Math.abs(num) - 1;
            
            if(nums[index] > 0){
                nums[index] = -nums[index];
            }
        }
        
        for(int i=0; i< nums.length; i++){
            if(nums[i] > 0){
                ans.add(i+1);
            }
        }
        
    return ans;
    }
}






75. CARS FLEET

class Solution {
    public int carFleet(int target, int[] position, int[] speed) {
        int n = position.length;
        double[][] cardata = new double[n][2];
        //0th - position
        //1st - time
        
        for(int i=0; i<n; i++){
            cardata[i][0] = position[i]*1d;
            cardata[i][1] = ((target-position[i])*1d)/speed[i];
        }
        
        Arrays.sort(cardata, (a,b) -> (Double.compare(a[0], b[0])));
        int nof = 1;
        double tt = cardata[n-1][1];
        for(int i=n-2; i>=0; i--){
            if(cardata[i][1] > tt){
                nof++;
                tt = cardata[i][1];
            }
        }
        
        return nof;
    }
}



75. FIND AND REPLACE PATTERN

class Solution {
    
     public static boolean isMatching(String str, String pat) {
    HashMap<Character, Character> map = new HashMap<>();
    HashSet<Character> set = new HashSet<>();

    for (int i = 0; i < str.length(); i++) {
      char pch = pat.charAt(i); // pattern character
      char sch = str.charAt(i); // string character
      if (map.containsKey(pch)) {
        if (map.get(pch) != sch)
          return false;
      } else {
        if (set.contains(sch)) return false;
        map.put(pch, sch);
        set.add(sch);
      }
    }
    return true;
  }
    
    public List<String> findAndReplacePattern(String[] words, String pattern) {
         List<String> res = new ArrayList<>();
    for (String str : words) {
      if (isMatching(str, pattern)) {
        res.add(str);
      }
    }
    return res;
    }
}



76. SHORTEST UNSORTED CONTINOUS SUBARRAY

nput: nums = [2,6,4,8,10,9,15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.

class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int end = -1;
        int max = nums[0];
        for(int i=1; i< nums.length; i++){
            if(max > nums[i]){
                end = i;
            } else {
                max = nums[i];
            }
        }
        
         int start = 0;
        int min = nums[nums.length - 1];
        for(int i=nums.length - 2; i>= 0; i--){
            if(nums[i] > min){
                start = i;
            } else {
                min = nums[i];
            }
        }
        
        return end - start + 1;
        
    }
}


75. WHERE WILL BALL FALL

class Solution {
    public int[] findBall(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        
        int[] ans = new int[m];
        
        for(int j=0; j<m; j++){
            int cpos = j;
            int npos = 0;
            for(int i=0; i< n; i++){
                npos = cpos + grid[i][cpos];
                
                if(npos < 0 || npos >= m || grid[i][cpos] != grid[i][npos]){
                    cpos = -1;
                    break;
                }
                cpos = npos;
            }
            
            
            ans[j] =  cpos;
        
        }
        
        return ans;
    }
}
      

76. WAYS TO MAKE SORTED ARRAY

class Solution {
    public int waysToMakeFair(int[] nums) {
        int n = nums.length;
        
        int[] odd = new int[n];
        int[] even = new int[n];
        
        int oddsum = 0;
        int evensum = 0;
        
        for(int i=0; i<n; i++){
            if(i%2 == 0){
                evensum += nums[i];
            } else {
                oddsum += nums[i];
            }
            
            odd[i] = oddsum;
            even[i] = evensum;
        }
        
        int ans = 0;
        for(int i=0; i < n; i++){
            if(i==0){
                int nos = even[n-1] - nums[0];
                int nes = odd[n-1];
                
                if(nos == nes) ans++;
                continue;
            }
            
            int nos = odd[i-1] + even[n-1] - even[i];
            int nes = even[i-1] + odd[n-1] - odd[i];
            
            if(nos == nes) ans++;
        }
        
        return ans;
    }
}  


77. SMALLEST RANGE COVERING ELEMENT FROM K LIST

class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int[] res = {-100000, 100000};
        int k = nums.size();
        int max = Integer.MIN_VALUE;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Integer.compare(a[0], b[0]));
        for(int i=0; i< k; i++){
            int mol = nums.get(i).get(0);
            int[] tba = {mol, 0, i};
            // 0th - min element of the list
            // 1st - index of element from the list
            // 2nd - index of list in nums
            max = Math.max(max, mol);
            pq.add(tba);
        }
        
        while(true){
            int[] min = pq.poll();
            if(res[1] - res[0] > max - min[0]){
                res[0] = min[0];
                res[1] = max;
            }
            min[1]++;
            List<Integer> cl = nums.get(min[2]);
            if(min[1] == cl.size()){
                break;
            }else {
                min[0] = cl.get(min[1]);
                max = Math.max(max, cl.get(min[1]));
                pq.add(min);
            }
            
        }
        
        return res;
        
    }
}


78. TEXT JUSTIFICATION

class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
         List<String> list = new ArrayList<>();
    int i = 0;
    while (i < words.length) {
      int wc = words[i].length();
      int j = i + 1;

      int can = 0;

      while (j < words.length && wc + can + words[j].length() + 1 <= maxWidth) {
        wc += words[j].length();
        can++;
        j++;
      }

      int vac = maxWidth - wc;



      int atleast = can == 0 ? 0 : vac / can;
      int extra = can == 0 ? 0 : vac % can;

      if (j == words.length) {
        atleast = 1;
        extra = 0;
      }

      StringBuilder sb = new StringBuilder();

      for (int k = i; k < j; k++) {
        sb.append(words[k]);
        if (k == j - 1)break;
        for (int e = 0; e < atleast; e++)sb.append(" ");
        if (extra > 0) {
          sb.append(" ");
          extra--;
        }
      }

      while (sb.length() < maxWidth)sb.append(" ");

      list.add(sb.toString());

      i = j;
    }

    return list;
    }
}
                