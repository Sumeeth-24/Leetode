FAIR DISTRIBUTION OF COOKIES

class Solution {
         private   int res = Integer.MAX_VALUE;
    public int distributeCookies(int[] cookies, int k) {

        
             
                    dfs(cookies, 0, k, new int[k]);
                    return res;
              }

void dfs(int[] cookies, int cur, int k, int[] children) {
    if (cur == cookies.length) {
        int max = 0;
        for (int c : children) max = Math.max(max, c);
        res = Math.min(res, max);
        return;
    }
    for (int i = 0; i < k; i++) {
        children[i] += cookies[cur];
        dfs(cookies, cur + 1, k, children);
        children[i] -= cookies[cur];
    }
}
  

PALINDROME PARTITIONING

class Solution {
    public List<List<String>> partition(String s) {
    List<String> list = new ArrayList<>();
    backtrack(s, list);
    return al;
}

List<List<String>> al = new ArrayList<>();
public void backtrack(String str, List<String> list){
    if(str.length() == 0){
        al.add(new ArrayList<>(list));
        return;
    }
    
    for(int i=0; i<str.length(); i++){
        String prefix = str.substring(0, i+1);
        String ros = str.substring(i+1);
        
        if(isPalindrome(prefix)){
            list.add(prefix);
            backtrack(ros, list);
            list.remove(list.size()-1);
        }
        
        
    }  
    
}



boolean isPalindrome(String str){
  int l = 0;
	int r = str.length()-1;
	
	while(l < r) {
		char left = str.charAt(l);
		char right = str.charAt(r);
		if(left != right) {
			return false;
		}
		
		l++;
		r--;
	}
	
	return true;
}
}


FIND 3 DIGIT EVEN NUMBER

class Solution {
    HashSet<Integer> set = new HashSet<>();
    public int[] findEvenNumbers(int[] digits) {
        boolean[] isUsed = new boolean[digits.length];
        backtrack(digits, 0, new String(), isUsed);
        int[] res = set.stream().sorted().mapToInt(i -> i).toArray();
        return res;
    }
    private void backtrack(int[] digits, int idx, String curr, boolean[] isUsed) {
        if (idx == 3) {
            int val = Integer.parseInt(curr);
            if (val % 2 == 0) set.add(val);
            return;
        } 
        for (int i = 0; i < digits.length; i++) {
            if (isUsed[i] || (idx == 0 && digits[i] == 0 ) || ( idx == 2 && digits[i] % 2 != 0)) continue;
            isUsed[i] = true;
            backtrack(digits, idx + 1, curr + digits[i], isUsed);
            isUsed[i] = false;
        }
    }
}


class Solution {
  
    public int[] findEvenNumbers(int[] digits) {
       int[] freq = new int[10];
        List<Integer> res = new ArrayList<>();
        for(int i : digits) freq[i]++;
        for(int i = 100; i <= 998; i+=2){
            int[] temp = freq.clone();
            if(solve(temp, i)){
                res.add(i);
            }
        }
        
        int[] ans = res.stream().mapToInt(i->i).toArray();
        return ans;
    }
    
    boolean solve(int[] freq, int num){
        
        while(num != 0){
            int r = num % 10;
            if(freq[r] > 0) freq[r]--;
            else return false;
            num = num / 10;
        }
        
        return true;
    }
}

SUBSET II

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] S) {
         List<List<Integer>> result = new ArrayList<List<Integer>>();
   
    if(S.length == 0){
        return result;
    }
    
    Arrays.sort(S);
    dfs(S, 0, new ArrayList<Integer>(), result);
    return result;
}

public void dfs(int[] s, int index, List<Integer> path, List<List<Integer>> result){
    result.add(new ArrayList<Integer>(path));
    
    for(int i = index; i < s.length; i++){
        if(i != index && s[i] == s[i-1]) continue;
        path.add(s[i]);
        dfs(s, i+1, path, result);
        path.remove(path.size()-1);
    }
    }
}


LETTER CASE PERMUTATION

class Solution {
    public List<String> letterCasePermutation(String S) {
         if (S == null) {
            return new LinkedList<>();
        }
        int n = S.length();
        LinkedList<String> queue = new LinkedList<>();
        queue.add(S);
        
        for (int i = n-1; i >= 0; i--) {
            char c = S.charAt(i);
            if (Character.isDigit(c)) continue; 
            
            int size = queue.size();
            while(size-- > 0) {
                String curr = queue.poll();
                String left = curr.substring(0, i);
                String right = curr.substring(i+1, n);
                queue.add(left + Character.toLowerCase(c) + right);
                  queue.add(left + Character.toUpperCase(c) + right);
                
                
            }
        }
        
        return queue;
    }
}


GENERATE PARENTHESIS

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> list = new ArrayList<String>();
        backtrack(list, new StringBuilder(), 0, 0, n);
        return list;
    }
    
    public void backtrack(List<String> list, StringBuilder str, int open, int closed, int n){
        
        //aborting condition
        if(closed > open){
            return;
        }
        
        if(closed == open && str.length() == 2*n){
            list.add(str.toString());
            return;
        }
         
        if(open < n){
            str.append("(");
            backtrack(list, str, open+1, closed, n);
            str.deleteCharAt(str.length() - 1);
        }
          if(closed < n){
            str.append(")");
            backtrack(list, str, open, closed+1, n);
            str.deleteCharAt(str.length() - 1);
        }
    }
}


ONES AND ZEROS

class Solution {
    
    int[][][] dp;
    public int findMaxForm(String[] strs, int m, int n) {
        dp = new int[m+1][n+1][strs.length];
        return helper(strs, m, n, 0);
    }
    
    public int helper(String[] strs, int zero, int one, int index){
        if(index == strs.length || zero + one == 0){
            return 0;
        }
        
        if(dp[zero][one][index] > 0){
            return dp[zero][one][index];
        }
        
        int[] count = count(strs[index]);
        
        //consider changes the zero and one
        int consider = 0;
        
        if(zero >= count[0] && one >= count[1]){
            consider = 1 + helper(strs, zero - count[0], one - count[1], index + 1);
        }
        
        //skip
        int skip = helper(strs, zero, one, index+1);
        
        dp[zero][one][index] =  Math.max(consider, skip);
        return  dp[zero][one][index];
        
    }
    
    public int[] count(String s){
        int[] count = new int[2];
        for(char c : s.toCharArray()){
            count[c - '0']++;
        }
        return count;
    }
}


ITERATOR FOR COMBINATION

class CombinationIterator {
    
    PriorityQueue<String> pq = new PriorityQueue<>();
    public CombinationIterator(String characters, int combinationLength) {
         generateSub(characters, 0, combinationLength, new StringBuilder());
    }
    
    private void generateSub(String s , int start, int len, StringBuilder result) {
        if (result.length() == len){
            pq.add(result.toString());
            return;
        }
        for (int i = start; i < s.length(); i++){
            result.append(s.charAt(i));
            generateSub(s, i+1, len,  result);
            result.deleteCharAt(result.length()-1);
        }
    }
    
    
    public String next() {
         return pq.poll();
    }
    
    public boolean hasNext() {
        return !pq.isEmpty();
    }
}

 Set seen = new HashSet();
    for (int i=0; i<9; ++i) {
        for (int j=0; j<9; ++j) {
            char number = board[i][j];
            if (number != '.')
                if (!seen.add(number + " in row " + i) ||
                    !seen.add(number + " in column " + j) ||
                    !seen.add(number + " in block " + i/3 + "-" + j/3))
                    return false;
        }
    }
    return true;

1. SUDOKU SOLVER
import java.io.*;
import java.util.*;

public class MyClass {

	 public static void display(int[][] board){
		    for(int i = 0; i < board.length; i++){
		      for(int j = 0; j < board[0].length; j++){
		        System.out.print(board[i][j] + " ");
		      }
		      System.out.println();
		    }
		  }

		  public static void solveSudoku(int[][] board, int i, int j) {
		    if (i == board.length){
		      display(board);
		      return;
		    }

		    int ni = 0;
		    int nj = 0;

		    if(j == board[0].length - 1){
		      ni = i + 1;
		      nj = 0;
		    } else {
		      ni = i;
		      nj = j + 1;
		    }

		    if(board[i][j] != 0){
		      solveSudoku(board, ni, nj);
		    } else {
		      for(int po = 1; po <= 9; po++){
		        if(isValid(board, i, j, po)== true){
		          board[i][j] = po;
		          solveSudoku(board, ni, nj);
		          board[i][j] = 0;
		        }
		      }
		    }
		  }

		  public static boolean isValid(int[][] board, int x, int y, int val) {
		    
		    for (int j = 0; j < board[0].length; j++) {
		      if (board[x][j] == val) {
		        return false;
		      }
		    }

		    for (int i = 0; i < board[0].length; i++) {
		      if (board[i][y] == val) {
		        return false;
		      }
		    }

		    int smi = x / 3 * 3;
		    int smj = y / 3 * 3;
		    for (int i = 0; i < 3; i++) {
		      for (int j = 0; j < 3; j++) {
		        if (board[smi + i][smj + j] == val) {
		          return false;
		        }
		      }
		    }

		    return true;
		  }

		  public static void main(String[] args) throws Exception {
		    Scanner scn = new Scanner(System.in);
		    System.out.println("Enter the value");
		    int[][] arr = new int[9][9];
		    for (int i = 0; i < 9; i++) {
		      for (int j = 0; j < 9; j++) {
		        arr[i][j] = scn.nextInt();
		      }
		    }

		    solveSudoku(arr, 0, 0);
		  }
		}

2. HOW TO PRINT ABBREVIATION USING RECURSION
import java.io.*;
import java.util.*;

public class Main {

    public static void solution(String str, String asf,int count, int pos){
        if(pos == str.length()){
            if(count == 0){
                 System.out.println(asf);
                
            }else{
            System.out.println(asf + count);
             }
            return;
        }
        solution(str, asf + (count > 0 ? count : "" ) + str.charAt(pos), 0, pos + 1); //yes call -> including curr char
        solution(str, asf, count + 1, pos + 1); //not including curr char -> just converting letters to a number
    }

	public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        String str = scn.nextLine();
        solution(str,"",0,0);
     
    }
}

3. N-QUEENS PROBLEM

import java.io.*;
import java.util.*;

public class MyClass {

	
	 int count = 0;
    public int totalNQueens(int n) {
        boolean[][] board = new boolean[n][n];
	    boolean[] cols = new boolean[n];
	    boolean[] ndiag = new boolean[2 * n - 1];
	    boolean[] rdiag = new boolean[2 * n - 1];
	   solution(board, 0, cols, ndiag, rdiag, "");
        return count;
        
    }
    
    public  void solution(boolean[][] board, int row, boolean[] cols, boolean[] ndiag, boolean[] rdiag, String asf) {
      
	    if (row == board.length) {
	      System.out.println(asf + ".");
          count++;
	     
	    }

	    for (int col = 0; col < board.length; col++) {
	      if (!cols[col] && !ndiag[row + col] && !rdiag[row - col + board.length - 1]) {
	        board[row][col] = true;
	        cols[col] = true;
	        ndiag[row + col] = true;
	        rdiag[row - col + board.length - 1] = true;
	        solution(board, row + 1, cols, ndiag, rdiag, asf + row + "-" + col + ", ");
	        board[row][col] = false;
	        cols[col] = false;
	        ndiag[row + col] = false;
	        rdiag[row - col + board.length - 1] = false;
	      }
	    }
	  }

	}

4. WORD BREAK PROBLEM
import java.io.*;
import java.util.*;

public class MyClass {

	

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int n = scn.nextInt();
		HashSet<String> dict = new HashSet<>();
		System.out.println("Enter the value");
		for(int i = 0  ; i  < n; i++){
			dict.add(scn.next());
		}
		System.out.println("Enter the value");
		String sentence = scn.next();
		wordBreak(sentence,"", dict);
	}

	public static void wordBreak(String str, String ans, HashSet<String> dict){
		if(str.length() == 0){
			System.out.println(ans);
			return;
		}
		for(int i = 0; i < str.length(); i++){
			String left = str.substring(0, i + 1);
			if(dict.contains(left)){
				String right = str.substring(i + 1);
				wordBreak(right, ans + left + " ", dict);
			}
		}
	}
		
}

5. MAXIMUM SCORE OF WORD
import java.io.*;
import java.util.*;

public class MyClass {

	
	public static void main(String[] args) {

		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int nofWords = scn.nextInt();
		String[] words = new String[nofWords];
		System.out.println("Enter the value");
		for(int i = 0 ; i < words.length; i++) {
			words[i] = scn.next();
		}
		System.out.println("Enter the value");
		int nofLetters = scn.nextInt();
		char[] letters = new char[nofLetters];
		System.out.println("Enter the value");
		for (int i = 0; i < letters.length; i++) {
			letters[i] = scn.next().charAt(0);
		}
		int[] score = new int[26];
		System.out.println("Enter the value");
		for (int i = 0; i < score.length; i++) {
			score[i] = scn.nextInt();
		}
		if (words == null || words.length == 0 || letters == null || letters.length == 0 || score == null
				|| score.length == 0) {
			System.out.println(0);
			return;
		}
		int[] farr = new int[score.length];
		for (char ch : letters) {
			farr[ch - 'a']++;
		}
		System.out.println(solution2(words, farr, score, 0));

	}

	public static int solution2(String[] words, int[] farr, int[] score, int idx) {
		if (idx == words.length) {
			return 0;
		}

		int sno = 0 +  solution2(words, farr, score, idx + 1);  // not included
	
        // include
		int sword = 0;
		String word = words[idx];
		boolean flag = true;
		for (int i = 0; i < word.length(); i++) {
			char ch = word.charAt(i);
			
			if (farr[ch - 'a'] == 0) {
				flag = false;
			}
			farr[ch - 'a']--;
			sword += score[ch - 'a'];
		}
		
		int syes = 0;
		if(flag) {
			syes = sword + solution2(words, farr, score, idx + 1);
		}
		
		for (int i = 0; i < word.length(); i++) {
			char ch = word.charAt(i);
			farr[ch - 'a']++;
	}
		return Math.max(sno,  syes);
}
}

6. GAME OF EXECUTION (JOSEPHUS PROBLEM )
package automate;
import java.io.*;
import java.util.*;

public class MyClass {

	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int k = scn.nextInt();
	        System.out.println(solution(n, k));
	    }

	    public static int solution(int n, int k) {
	        if (n == 1) {
	            return 0;
	        } else {
	            int x = solution(n-1, k);
	            int y = (x+k) % n;
	            return y;
	        }
	    }


	}

class Solution {
    public int findTheWinner(int n, int k) {
        int result = 0;
        for(int i=1; i<=n; i++) {
            result = (result + k) % i;
        }
        return result + 1;
    }
}


7. PRINT IN LEXICOGRAPHICAL ORDER
package automate;
import java.io.*;
import java.util.*;

public class MyClass {

	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        for (int i = 1; i < 10; i++) {
	            dfs(i, n);
	        }
	    }

	    public static void dfs(int cur, int n) {
	        if (cur > n) {
	            return;
	        } else {
	            System.out.println(cur);
	            for (int i = 0; i < 10; i++) {
	                dfs(10 * cur + i, n);
	            }
	        }
	    }
	}


8. GOLDMINE 2 
package automate;
import java.io.*;
import java.util.*;

public class MyClass {
	static int max = 0;
	public static int getMaxGold(int[][] arr) {
		for(int i=0; i< arr.length; i++) {
			for(int j=0; j<arr[0].length; j++) {
				if(arr[i][j] != 0) {
					findMaxGold(i,j,0,arr);
				}
			}
		}
		return max;
	}
	public static void findMaxGold(int i, int j, int gsf, int arr[][]) {
		if(i == arr.length || j == arr[0].length || i == -1 || j== -1 || arr[i][j] == 0) {
			if(gsf > max)
				max = gsf;
			return;
		}
		int temp = arr[i][j];
		gsf += arr[i][j];
		
		arr[i][j] = 0;
		findMaxGold(i-1, j, gsf, arr);
		findMaxGold(i, j+1, gsf, arr);
		findMaxGold(i+1, j, gsf, arr);
		findMaxGold(i, j-1, gsf, arr);
		arr[i][j] = temp;
	}


	  public static void main(String[] args) {
		  Scanner scn = new Scanner(System.in);
		  System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int m = scn.nextInt();
	        int[][] arr = new int[m][n];
	        System.out.println("Enter the value");
	        for (int i = 0; i < arr.length; i++) {
	            for (int j = 0; j < arr[0].length; j++) {
	                arr[i][j] = scn.nextInt();
	            }
	        }
	       int max= getMaxGold(arr);
	        System.out.println(max);
	}
}


9. CROSSWORD PUZZLE
package automate;
import java.io.*;
import java.util.*;

public class MyClass {
	   public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        char[][] arr = new char[10][10];
	        System.out.println("Enter the value");
	        for (int i = 0; i < arr.length; i++) {
	            String str = scn.next();
	            arr[i] = str.toCharArray();
	        }
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        String[] words = new String[n];
	        System.out.println("Enter the value");
	        for (int i = 0; i < words.length; i++) {
	            words[i] = scn.next();
	        }
	        solution(arr, words, 0);

	    }

	    public static void solution(char[][] arr, String[] words, int vidx) {
	        if (vidx == words.length) {
	            print(arr);
	            return;
	        }
	        String word = words[vidx];
	        for (int i = 0; i < 10; i++) {
	            for (int j = 0; j < 10; j++) {
	           
	                if (arr[i][j] == '-' || arr[i][j] == word.charAt(0)) {
	                    if (canPlaceVertical(arr, word, i, j) ) {
	                        boolean[] weplaced =  placeVertical(arr, word, i, j);
	                        //call
	                        solution(arr, words, vidx + 1);
	                        unplaceVertical(arr, weplaced, i, j);
	                    }

	                    if (canPlaceHorizontal(arr, word, i, j)) {
	                        boolean[] weplaced = placeHorizontal(arr, word, i, j);
	                        //call
	                        solution(arr, words, vidx + 1);
	                        unplaceHorizontal(arr, weplaced, i, j);
	                    }
	                }
	            }
	        }
	    }

	    public static boolean canPlaceVertical(char[][] arr, String word, int i, int j) {
	    	  if(i -1 >= 0 && arr[i-1][j] != '+') {
		    	  return false;
		      } else if (i + word.length() < arr[0].length && arr[i + word.length()][j] != '+') {
		    	  return false;
		      }
		      
		      for(int ii = 0; ii < word.length(); ii++) {
		    	  if(i + ii >= arr.length) {
		    		  return false;
		    	  }
		    	  
		            if (arr[i + ii][j] == '-' || arr[i + ii][j] == word.charAt(ii)) {
		                continue;
		            } else {
		                return false;
		            }
		        }
		       return true;
		    }

	    public static boolean canPlaceHorizontal(char[][] arr, String word, int i, int j) {
	      if(j -1 >= 0 && arr[i][j-1] != '+') {
	    	  return false;
	      } else if (j + word.length() < arr[0].length && arr[i][j + word.length()] != '+') {
	    	  return false;
	      }
	      
	      for(int jj = 0; jj < word.length(); jj++) {
	    	  if(j + jj >= arr[0].length) {
	    		  return false;
	    	  }
	    	  
	            if (arr[i][j + jj] == '-' || arr[i][j + jj] == word.charAt(jj)) {
	                continue;
	            } else {
	                return false;
	            }
	        }
	       return true;
	    }

	    public static boolean[] placeVertical(char[][] arr, String word, int i, int j) {
	    	boolean[] wePlaced = new boolean[word.length()];
	    	
	        for (int ii = 0; ii < word.length(); ii++) {
	            if (arr[i + ii][j] == '-') {
	            	 arr[i + ii][j] = word.charAt(ii);
	                wePlaced[ii] = true;
	            }
	           
	        }
	        return wePlaced;
	    }

	    public static void unplaceVertical(char[][] arr,boolean[] wePlaced, int i, int j) {
	        for (int ii = 0; ii < wePlaced.length; ii++) {
	            if (wePlaced[ii] == true) {
	                arr[i + ii][j] = '-';
	            }
	        }
	    }

	    public static boolean[] placeHorizontal(char[][] arr, String word, int i, int j) {
	    	boolean[] wePlaced = new boolean[word.length()];
	    	
	        for (int jj = 0; jj < word.length(); jj++) {
	            if (arr[i][j + jj] == '-') {
	            	 arr[i][j+ jj] = word.charAt(jj);
	                wePlaced[jj] = true;
	            }
	           
	        }
	        return wePlaced;
	    }

	    public static void unplaceHorizontal(char[][] arr,boolean[] wePlaced, int i, int j) {
	        for (int jj = 0; jj < wePlaced.length; jj++) {
	            if (wePlaced[jj] == true) {
	                arr[i][j + jj] = '-';
	            }
	        }
	    }

	    public static void print(char[][] arr) {
	        for (int i = 0; i < arr.length; i++) {
	            for (int j = 0; j < arr.length; j++) {
	                System.out.print(arr[i][j] + "");
	            }
	            System.out.println();
	        }

	    }
}

10. QUEEN PERMUTATION ( queen chooses )
package automate;
import java.io.*;
import java.util.*;

public class MyClass {
	 public static void queensPermutations(int qpsf, int tq, int[][] chess) {
	        if (qpsf == tq) {
	            for (int row = 0; row < chess.length; row++) {
	                for (int col = 0; col < chess[0].length; col++) {
	                	if(chess[row][col] == 0) {
	                		 System.out.print("-\t");
	                	} else {
	                		System.out.println( "q" + chess[row][col] + "\t" ); 
	                	}
	                   
	                }
	                System.out.println();
	            }
	            System.out.println();
	            return;
	        }

	        for (int row = 0; row < chess.length; row++) {
	            for (int col = 0; col < chess[0].length; col++) {
	                if (chess[row][col] == 0) {
	                    chess[row][col] = qpsf + 1;
	                    queensPermutations(qpsf + 1, tq, chess);
	                    chess[row][col] = 0;
	                }
	            }
	        }
	    }
	    public static void main(String[] args) throws Exception {
	      Scanner t = new Scanner(System.in);
	      System.out.println("Enter the value");
	        int n = t.nextInt();
	     
	        int[][] chess = new int[n][n];

	        queensPermutations(0, n, chess);
	    }
	}

11. FRIENDS PAIRING
package automate;
import java.io.*;
import java.util.*;

public class MyClass {
	static int counter = 1;

    public static void solution(int i, int n, boolean[] used, String asf) {
        if (i > n) {
            System.out.println(counter + "." + asf);
            counter++;
            return;
        }

        if (used[i]) {
            solution(i + 1, n, used, asf);
        } else {
            used[i] = true;
            solution(i + 1, n, used, asf + "(" + i + ") ");

            for (int j = i + 1; j <= n; j++) {
                if (used[j] == false) {
                    used[j] = true;
                    solution(i + 1, n, used, asf + "(" + i + "," + j + ") ");
                    used[j] = false;
                }
            }

            used[i] = false;
        }
    }

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the value");
        int n = sc.nextInt();
        boolean[] used = new boolean[n + 1];
        solution(1, n, used, "");
    }
}

12. PARTITIONS IN K SUBSET
package automate;
import java.io.*;
import java.util.*;

public class MyClass {
	   public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int k = scn.nextInt();
	        ArrayList < ArrayList < Integer >> ans = new ArrayList < > ();
	        for (int i = 0; i < k; i++) {
	            ans.add(new ArrayList < > ());
	        }
	        solution(1, n, k, 0, ans);

	    }

	    static int counter = 1;
	    public static void solution(int i, int n, int k, int rssf, ArrayList < ArrayList < Integer >> ans) {
	        if (i == n + 1) {
	            if (rssf == k) {
	                System.out.print(counter + ". ");
	                counter++;
	                for (ArrayList < Integer > a: ans) {
	                    System.out.print(a + " ");
	                }
	                System.out.println();
	            }
	            return;
	        }

	        for (int j = 0; j < ans.size(); j++) {
	            if (ans.get(j).size() == 0) {
	                ans.get(j).add(i);
	                solution(i + 1, n, k, rssf + 1, ans);
	                ans.get(j).remove(ans.get(j).size() - 1);
	                break;
	            } else {
	                ans.get(j).add(i);
	                solution(i + 1, n, k, rssf, ans);
	                ans.get(j).remove(ans.get(j).size() - 1);
	            }
	        }

	    }

	}

PERMUTATION OF A STRING
// aabb a2b2
class Solution {
    public List<String> find_permutation(String S) {
        List<String> res = new ArrayList<>();
        Character[] spots = new Character[S.length()];
        HashMap<Character, Integer> lastOccurence = new HashMap<>();
        
        for(char ch : S.toCharArray()){
            lastOccurence.put(ch, -1);
        }
        
        generate(0, S, spots, lastOccurence, res);
        Collections.sort(res);
        return res;
    }
    
    public void generate(int cc, String str, Character[] spots, HashMap<Character, Integer> lastOccurence, List<String> ans){
        StringBuilder sb = new StringBuilder();
        if(cc == str.length()){
            for(int i=0; i < spots.length; i++){
                sb.append(spots[i]);
            }
            ans.add(sb.toString());
            return;
        }
        
        char ch = str.charAt(cc);
        int lo = lastOccurence.get(ch);
        
        for(int i = lo + 1; i < spots.length; i++){
            if(spots[i] == null){
                spots[i] = ch;
                lastOccurence.put(ch, i);
                generate(cc + 1, str, spots, lastOccurence, ans);
                spots[i] = null;
                lastOccurence.put(ch, -1);
            }
        }
    }
}



Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").

class Solution {
    public boolean isPermutation(int[] s1Arr, int[] s2Arr){
        
        for(int i=0; i < s1Arr.length; i++){
            if(s1Arr[i] != s2Arr[i])
                return false;
        }
        return true;
    }
    
    public boolean checkInclusion(String s1, String s2) {
        int s1Len = s1.length();
        int s2Len = s2.length();
        
        if(s2 == null || s2.length() == 0 || s1Len > s2Len) return false;
        
        int[] s1Arr = new int[26];
        int[] s2Arr = new int[26];
        
        for(int i=0; i< s1Len; i++){
            s1Arr[s1.charAt(i) - 'a']++;
            s2Arr[s2.charAt(i) - 'a']++;
        }
            
            for(int i=0; i < s2Len - s1Len; i++){
                if(isPermutation(s1Arr, s2Arr))
                    return true;
                
                s2Arr[s2.charAt(i) - 'a']--;
                s2Arr[s2.charAt(i + s1Len) - 'a']++;
            }
        
        if(isPermutation(s1Arr, s2Arr))
                    return true;
            
            
        
        return false;
    }
}



13. PALINDROMIC PERMUTATION OF A STRING
package automate;
import java.io.*;
import java.util.*;

public class MyClass {
	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        String str = scn.nextLine();
	        HashMap < Character, Integer > fmap = new HashMap < > ();
	        for (int i = 0; i < str.length(); i++) {
	            char ch = str.charAt(i);
	           if(fmap.containsKey(ch)) {
	        	   int of = fmap.get(ch);
	        	   fmap.put(ch, of + 1);
	           } else {
	        	   fmap.put(ch, 1);
	           }
	        }
	        
	     
	        Character odd = null;
	        int odds = 0;
	        int length = 0;
	       
	           for(char ch: fmap.keySet()) {
	        	   int freq = fmap.get(ch);
	        	   
	        	   if(freq % 2 == 1) {
	        		   odd = ch;
	        		   odds++;
	        	   }
	        	   fmap.put(ch, freq/2);
	        	   length += freq/2;
	           }
	           if(odds > 1) {
	        	   System.out.println(-1);
	        	   return;
	           }
	        generatepw(1, length, fmap, odd, "");
	        

	    }

	    public static void generatepw(int cs, int ts, HashMap < Character, Integer > fmap, Character oddc, String asf) {
	        if (cs > ts) {
	        	String rev = "";
	        	for(int i = asf.length() - 1; i >=0; i--) {
	        		rev += asf.charAt(i);
	        	}
	        	String res = asf;
	        	if(oddc != null) {
	        		res += oddc;
	        	}
	        	res += rev;
	            System.out.println(res);
	            return;
	        }

	        for (char ch: fmap.keySet()) {
	            if (fmap.get(ch) > 0) {
	                fmap.put(ch, fmap.get(ch) - 1);
	                generatepw(cs + 1, ts, fmap, oddc, asf + ch);
	                fmap.put(ch, fmap.get(ch) + 1);
	            }
	        }
	    }

	  

	}


15. EQUAL SUM SUBSETS PARTITION
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	      
	        int[] arr = new int[n];
	        
	        int sum = 0;
	        System.out.println("Enter the value");
	        for (int i = 0; i < arr.length; i++) {
	            arr[i] = scn.nextInt();
	            sum += arr[i];
	        }
	        System.out.println("Enter the value");
	        int k = scn.nextInt();
	        // if k is equal to 1, then whole array is your answer 
	        if (k == 0) {
	            System.out.print("[");
	            for (int i = 0; i < arr.length; i++) {
	                System.out.print(arr[i] + ", ");
	            }
	            System.out.println("]");
	            return;
	        }
	        //if there are more subsets than no. of elements in array or sum of all elements is not divisible by k
	        if (k > n || sum % k != 0) {
	            System.out.println("-1");
	            return;
	        }
	        int[] subsetSum = new int[k];
	        ArrayList < ArrayList < Integer >> ans = new ArrayList < > ();
	        for (int i = 0; i < k; i++) {
	            ans.add(new ArrayList < > ());
	        }
	        solution(arr, 0, n, k, subsetSum, 0, ans);
	    }

	    public static void solution(int[] arr, int vidx, int n, int k, int[] subsetSum, int ssssf, ArrayList < ArrayList < Integer >> ans) {
	        if (vidx == arr.length) {
	            if (ssssf == k) {
	                boolean flag = true;
	                for (int i = 0; i < subsetSum.length-1; i++) {
	                    if (subsetSum[i] != subsetSum[i+1]) {
	                        flag = false;
	                        break;
	                    }
	                }
	                if (flag == true) {
	                    for (ArrayList < Integer > a: ans) {
	                        System.out.print(a + " ");
	                    }
	                    System.out.println();
	                }
	            }
	            return;
	        }

	        for (int j = 0; j < ans.size(); j++) {
	            if (ans.get(j).size() > 0) {
	            	  ans.get(j).add(arr[vidx]);
		                subsetSum[j] += arr[vidx];
		                solution(arr, vidx + 1, n, k, subsetSum, ssssf, ans);
		                subsetSum[j] -= arr[vidx];
		                ans.get(j).remove(ans.get(j).size() - 1);
	            } else {
	                ans.get(j).add(arr[vidx]);
	                subsetSum[j] += arr[vidx];
	                solution(arr, vidx + 1, n, k, subsetSum, ssssf + 1, ans);
	                subsetSum[j] -= arr[vidx];
	                ans.get(j).remove(ans.get(j).size() - 1);
	            
	                break;
	            } 
	        }
	    }
}


public boolean isKPartitionPossible(int nums[], int n, int k)
    {
	// Your code here
	 int sum = 0;
        for(int num:nums)sum += num;
        if(k <= 0 || sum%k != 0)return false;
        int[] visited = new int[nums.length];
        return canPartition(nums, visited, 0, k, 0, 0, sum/k);
    }
    
    public boolean canPartition(int[] nums, int[] visited, int start_index, int k, int cur_sum, int cur_num, int target){
        if(k==1)return true;
        if(cur_sum == target && cur_num>0)return canPartition(nums, visited, 0, k-1, 0, 0, target);
        for(int i = start_index; i<nums.length; i++){
            if(visited[i] == 0){
                visited[i] = 1;
                if(canPartition(nums, visited, i+1, k, cur_sum + nums[i], cur_num++, target))return true;
                visited[i] = 0;
            }
        }
        return false;
    }
}



16. WORD PATTERN MATCHING
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        String str = scn.next();
	        String pattern = scn.next();
	        HashMap < Character, String > map = new HashMap < > ();
	        solution(str, pattern, map, pattern);
	    }

	    public static void solution(String str, String pattern, HashMap < Character, String > map, String op) {
	        if (pattern.length() == 0) {
	            if (str.length() == 0) {
	               HashSet<Character> alreadyPrinted = new HashSet<>();
	                for (int i = 0; i < op.length(); i++) {
	                    char ch = op.charAt(i);
	                    if (alreadyPrinted.contains(ch) == false) {
	                        System.out.print(ch + " -> " + map.get(ch) + ", ");
	                        alreadyPrinted.add(ch);
	                    }
	                }
	                System.out.println(".");
	            }
	            return;
	        }

	        char chp = pattern.charAt(0);
	        String rop = pattern.substring(1);

	        if (!map.containsKey(chp)) {
	            //if character is coming for the first time
	            for (int i = 0; i < str.length(); i++) {
	                String fh = str.substring(0, i + 1);
	                String ros = str.substring(i + 1);

	                map.put(chp, fh);
	                solution(ros, rop, map, op);
	                map.remove(chp);
	            }
	        } else {
	            //if character has already appeared 
	            String prevmatching = map.get(chp);
	            if(str.length() >= prevmatching.length() ) {
	            	  String nextsubstring =  str.substring(0, prevmatching.length());
	  	            String ros =  str.substring( prevmatching.length());
	  	            if (prevmatching.equals(nextsubstring)) {
	  	                solution(ros, rop, map, op);
	  	            }
	            }
	          
	        }
	    }

	}

17. COIN CHANGE COMBINATION (WITHOUT DUPLICACY)
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static void coinChange(int i, int[] coins, int amtsf, int tamt, String asf) {
	        if (i == coins.length) {
	            if (amtsf == tamt) {
	                System.out.println(asf + ".");
	            }
	            return;
	        }
	        coinChange(i + 1, coins, amtsf + coins[i], tamt, asf + coins[i] + "-");
	        coinChange(i + 1, coins, amtsf + 0, tamt, asf + "");
	    }
	    public static void main(String[] args) throws Exception {
	      Scanner t = new Scanner(System.in);
	      System.out.println("Enter the value");
	      int n = t.nextInt();
	      int[] coins = new int[n];
	      System.out.println("Enter the value");
	        for (int i = 0; i < n; i++) {
	            coins[i] = t.nextInt();
	        }
	        System.out.println("Enter the value");
	        int amt =t.nextInt();
	        coinChange(0, coins, 0, amt, "");
	    }
	}

18. REMOVE INVALID PARENTHESIS
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        String str = scn.next();
	        int mr = getMin(str);
	        solution(str, mr, new HashSet < > ());
	    }


	    public static void solution(String str, int minRemoval, HashSet < String > ans) {
	     
	        if (minRemoval == 0) {
	        	int mnrow = getMin(str);
	        	if(mnrow == 0) {
	        		if(!ans.contains(str)) {
	        			System.out.println(str);
	        			ans.add(str);
	        		}
	        	}
	            return;
	        }

	        for (int i = 0; i < str.length(); i++) {
	            String left = str.substring(0, i);
	            String right = str.substring(i + 1);
	            solution(left + right, minRemoval - 1, ans);
	        }
	    }

	    public static int getMin(String str) {
	        Stack < Character > st = new Stack < > ();
	        for (int i = 0; i < str.length(); i++) {
	            char ch = str.charAt(i);
	            if (ch == '(') {
	                st.push(ch);
	            } else {
	                if (st.size() == 0 || st.peek() == ')') {
	                    st.push(ch);
	                } else if (st.peek() == '(') {
	                    st.pop();
	                }
	            }
	        }
	        return st.size();
	    }

	  

	}

19. MINIMUM SUBSET SUM DIFFERENCE( TUG OF WAR )
package automate;
import java.io.*;
import java.util.*;

public class MyClass {

	 public static void main(String[] args) {
	        Scanner t = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = t.nextInt();
	        int[] arr = new int[n];
	        System.out.println("Enter the value");
	        for (int i = 0; i < arr.length; i++) {
	            arr[i] = t.nextInt();
	        }

	        solve(arr, 0, new ArrayList < > (), new ArrayList < > (), 0, 0);
	        System.out.println(ans);
	    }

	    static int mindiff = Integer.MAX_VALUE;
	    static String ans = "";

	    public static void solve(int[] arr, int vidx, ArrayList < Integer > set1, ArrayList < Integer > set2, int soset1,
	        int soset2) {
	        if (vidx == arr.length) {
	            if (Math.abs(soset1 - soset2) < mindiff) {
	                mindiff = Math.abs(soset1 - soset2);
	                ans = set1 + " " + set2;
	            }
	            return;
	        }

	        if (set1.size() < (arr.length + 1) / 2) {
	            set1.add(arr[vidx]);
	            solve(arr, vidx + 1, set1, set2, soset1 + arr[vidx], soset2);
	            set1.remove(set1.size() - 1);
	        }

	        if (set2.size() < (arr.length + 1) / 2) {
	            set2.add(arr[vidx]);
	            solve(arr, vidx + 1, set1, set2, soset1, soset2 + arr[vidx]);
	            set2.remove(set2.size() - 1);
	        }
	    }

	}


MIN ABSOLUTE SUM DIFF

class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
       int len = nums1.length, mod = 1_000_000_007;
    int[] diff = new int[len];
    long sum = 0, ans = 0;
    
    for(int i = 0 ; i < len ; i++){
        diff[i] = Math.abs(nums1[i] - nums2[i]);
        sum += diff[i];
    }
    
    ans = sum;
    Arrays.sort(nums1);
    
    for(int i = 0 ; i < len ; i++){
        sum -= diff[i];            
        int val = bestMatch(nums1, nums2[i]);
        sum += val;
        
        if(sum < ans){
            ans = sum;
        }
        sum -= val;
        sum += diff[i];
    }
    
    return (int) (ans % mod);
}

public int bestMatch(int[] nums, int target){
    
    int lo = 0, hi = nums.length - 1, small = -1, big = -1, ans = Integer.MAX_VALUE;
    while(lo <= hi){
        
        int mid = lo + (hi - lo) / 2;
        if(nums[mid] == target)
            return 0;
        else if(nums[mid] < target){
            lo = mid + 1;
            small = mid;
        }
        else{
            hi = mid - 1;
            big = mid;
        }
    }
    
    if(small != -1)
        ans = Math.abs(target - nums[small]);
    
    if(big != -1)
        ans = Math.min(ans, Math.abs(target - nums[big]));
    
    return ans;
}
}

20. PRINT PERMUTATIONS
package automate;                                                                                                                                                                              
import java.io.*;                                                                                                                                                                              
import java.util.*;                                                                                                                                                                            
                                                                                                                                                                                               
public class MyClass {                                                                                                                                                                         
                                                                                                                                                                                               
	public static void permutations(int[] boxes, int ci, int ti) {                                                                                                                             
        if (ci > ti) {                                                                                                                                                                         
            for (int i = 0; i < boxes.length; i++) {                                                                                                                                           
                System.out.print(boxes[i]);                                                                                                                                                    
            }                                                                                                                                                                                  
            System.out.println();                                                                                                                                                              
            return;                                                                                                                                                                            
        }                                                                                                                                                                                      
        for (int i = 0; i < boxes.length; i++) {                                                                                                                                               
            if (boxes[i] == 0) {                                                                                                                                                               
                boxes[i] = ci;                                                                                                                                                                 
                permutations(boxes, ci + 1, ti);                                                                                                                                               
                boxes[i] = 0;                                                                                                                                                                  
            }                                                                                                                                                                                  
        }                                                                                                                                                                                      
    }                                                                                                                                                                                          
                                                                                                                                                                                               
    public static void main(String[] args) throws Exception {                                                                                                                                  
		  Scanner t = new Scanner(System.in);                                                                                                                                                  
		  System.out.println("Enter the value");                                                                                                                                               
          int nboxes = t.nextInt();                                                                                                                                                            
                                                                                                                                                                                               
        int arr[] = new int[nboxes];                                                                                                                                                           
        System.out.println("Enter the value");                                                                                                                                               
        for (int i = 0; i < arr.length; i++) {                                                                                                                                               
            arr[i] = t.nextInt();                                                                                                                                                            
        }                                                                                                                                                                                    
                                                                                                                                                                                               
        System.out.println("Enter the value");                                                                                                                                                 
        int ritems = t.nextInt();                                                                                                                                                              
        permutations(arr, 1, ritems);                                                                                                                                                          
    }                                                                                                                                                                                          
                                                                                                                                                                                               
} 

21. PRINT COMBINATIONS
package automate;
import java.io.*;
import java.util.*;

public class MyClass {

	 public static void combinations(int cb, int tb, int ssf, int ts, String asf) {
	        if (cb > tb) {
	            if (ssf == ts) {
	                System.out.println(asf);
	            }
	            return;
	        }

	        combinations(cb + 1, tb, ssf + 1, ts, asf + "i");
	        combinations(cb + 1, tb, ssf + 0, ts, asf + "-");
	    }

	    public static void main(String[] args) throws Exception {
	    Scanner t = new Scanner(System.in);
	    System.out.println("Enter the value");
	        int nboxes = t.nextInt();
	        int ritems = t.nextInt();
	        combinations(1, nboxes, 0, ritems, "");
	    }

	}                                                                                                                                                                                             
      

22. PRINT PERMUTATIONS USING COMBINATION
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


    public static void permutations(int cb, int tb, int[] items, int ssf, int ts, String asf) {
        if (cb > tb) {
            if (ssf == ts) {
                System.out.println(asf);
            }
            return;
        }


        for (int i = 0; i < items.length; i++) {
            if (items[i] == 0) {    // to know if item got selected
                items[i] = 1;
                permutations(cb + 1, tb, items, ssf + 1, ts, asf + (i + 1));
                items[i] = 0;
            }
        }
        permutations(cb + 1, tb, items, ssf, ts, asf + 0);
    }

    public static void main(String[] args) throws Exception {
    	 Scanner t = new Scanner(System.in);
 	    System.out.println("Enter the value");
 	        int nboxes = t.nextInt();
 	        int ritems = t.nextInt();
        permutations(1, nboxes, new int[ritems], 0, ritems, "");
    }

}    
           ts = r items  


23. PRINT COMBINATION USING PERMUTATION    
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static void combinations(boolean[] boxes, int ci, int ti, int llb) {
	        if (ci > ti) {
	        for (int i = 0; i < boxes.length; i++) {
	            if (boxes[i]) {
	               System.out.print("i");
	            } else {
	            	 System.out.print("-");
	            }
	        }
	        System.out.println();
	        return;
	    }
	        
	        for (int b = llb + 1; b < boxes.length; b++) {
	            if (boxes[b] == false) {
	                boxes[b] = true;
	                combinations(boxes, ci + 1, ti, b);
	                boxes[b] = false;
	            }
	        }
	 }

	    public static void main(String[] args) throws Exception {
	    	 Scanner t = new Scanner(System.in);
	  	    System.out.println("Enter the value");
	  	        int nboxes = t.nextInt();
	  	        int ritems = t.nextInt();
	        combinations(new boolean[nboxes], 1, ritems, -1);
	    }

	}

24. LARGEST NUMBER POSSIBLE AFTER KTH SWAP
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	    static String lmax;
	    public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        String str = scn.next();
	        System.out.println("Enter the value");
	        int k = scn.nextInt();
	        lmax = str;
	        findMaximum(str, k);
	        System.out.println(lmax);
	    }
	    


	    public static void findMaximum(String str, int k) {
	    	
            if (Integer.parseInt(str) > Integer.parseInt(lmax)) {
                lmax = str;
            }
            
	        if (k == 0) {
	            return;
	        }

	        for (int i = 0; i < str.length() - 1; i++) {
	            for (int j = i + 1; j < str.length(); j++) {
	                if (str.charAt(i) < str.charAt(j)) {
	                    String swapped = swap(str, i, j);
	                    findMaximum(swapped, k - 1);
	                }
	            }
	        }
	    }

	    public static String swap(String str, int i, int j) {
	        char ith = str.charAt(i);
	        char jth = str.charAt(j);

	        String left = str.substring(0, i);
	        String middle = str.substring(i + 1, j);
	        String right = str.substring(j + 1);

	        return left + jth + middle + ith + right;
	    }

	}    


25. PERMUTATION OF WORDS
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static void generateWords(int cs, int ts, HashMap<Character, Integer> fmap, String asf) {
		    if(cs > ts){
		      System.out.println(asf);
		      return;
		    }

		    for (char ch : fmap.keySet()) {
		      if (fmap.get(ch) > 0) {
		        fmap.put(ch, fmap.get(ch) - 1);
		        generateWords(cs + 1, ts, fmap, asf + ch);
		        fmap.put(ch, fmap.get(ch) + 1);
		      }
		    }
		  }

		  public static void main(String[] args) throws Exception {
		    Scanner br = new Scanner(System.in);
		    System.out.println("Enter the value");
		    String str = br.nextLine();

		    HashMap<Character, Integer> fmap = new HashMap<>();
		    for(char ch: str.toCharArray()){
		      if(fmap.containsKey(ch)){
		        fmap.put(ch, fmap.get(ch) + 1);
		      } else {
		        fmap.put(ch, 1);
		      }
		    }

		    generateWords(1, str.length(), fmap, "");
		  }

		}    


26. WORDS K SELECTION (WITHOUT REPETITION)
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static void generateSelection(int i, String ustr, int ssf, int ts, String asf) {
		    if (i == ustr.length()) {
		      if(ssf == ts){
		        System.out.println(asf);
		      }
		      return;
		    }

		    char ch = ustr.charAt(i);
		    generateSelection(i + 1, ustr, ssf + 1, ts, asf + ch);
		    generateSelection(i + 1, ustr, ssf + 0, ts, asf + "");
		  }

		  public static void main(String[] args) throws Exception {
			  Scanner br = new Scanner(System.in);
			    System.out.println("Enter the value");
		    String str = br.nextLine();
		    System.out.println("Enter the value");
		    int k = br.nextInt();

		    HashSet<Character> unique = new HashSet<>();
		    String ustr = "";
		    for (char ch : str.toCharArray()) {
		      if (unique.contains(ch) == false) {
		        unique.add(ch);
		        ustr += ch;
		      }
		    }

		    generateSelection(0, ustr, 0, k, "");
		  }

		}

27. K LENGTH WORD
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static void generateWords(int cc, String ustr, int ssf, int ts, Character[] spots) {
		    if (cc == ustr.length()) {
		      if(ssf == ts){
		        for(int i = 0; i < spots.length; i++){
		          System.out.print(spots[i]);
		        }
		        System.out.println();
		      }
		      return;
		    }

		    char ch = ustr.charAt(cc);
		    for(int i = 0; i < spots.length; i++){
		      if(spots[i] == null){
		        spots[i] = ch;
		        generateWords(cc + 1, ustr, ssf + 1, ts, spots);
		        spots[i] = null;
		      }
		    }
		    generateWords(cc + 1, ustr, ssf + 0, ts, spots);
		  }

		  public static void main(String[] args) throws Exception {
			  Scanner br = new Scanner(System.in);
			    System.out.println("Enter the value");
		    String str = br.nextLine();
		    System.out.println("Enter the value");
		    int k = br.nextInt();
		    
		    HashSet<Character> unique = new HashSet<>();
		    String ustr = "";
		    for (char ch : str.toCharArray()) {
		      if (unique.contains(ch) == false) {
		        unique.add(ch);
		        ustr += ch;
		      }
		    }

		    Character[] spots = new Character[k];
		    generateWords(0, ustr, 0, k, spots);
		  }

		}

28. QUEEN COMBINATIONS
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


    public static void queensCombinations(int qpsf, int tq, boolean[][] chess, int lcno) {
		 if (qpsf == tq) {
	            for (int row = 0; row < chess.length; row++) {
	                for (int col = 0; col < chess.length; col++) {
	                    System.out.print(chess[row][col] ? "q\t" : "-\t");
	                }
	                System.out.println();
	            }
	            System.out.println();
	            return;
	        }

	        for (int cell = lcno + 1; cell < chess.length * chess.length; cell++) {
	            int row = cell / chess.length;
	            int col = cell % chess.length;

	            if (chess[row][col] == false) {
	                chess[row][col] = true;
	                queensCombinations(qpsf + 1, tq, chess, cell);
	                chess[row][col] = false;
	            }
	        }
	    }

	    public static void main(String[] args) throws Exception {
	    	 Scanner br = new Scanner(System.in);
			    System.out.println("Enter the value");
			    int n = br.nextInt();
	        boolean[][] chess = new boolean[n][n];

	        queensCombinations(0, n, chess, -1);
	    }
	}



	                                   

	


29. QUEENS PERMUTATIONS
package automate;
import java.io.*;
import java.util.*;

public class MyClass {

	 public static void queensPermutations(int qpsf, int tq, int row, int col, String asf, boolean[] queens) {
	        if (row == tq) {
	            if (qpsf == tq) {
	                System.out.println(asf);
	                System.out.println();
	            }
	            return;
	        }

	        int nr = 0;
	        int nc = 0;
	        char sep = '\0';
	        
	        if(col == tq - 1) {
	        	nr = row + 1;
	        	nc = 0;
	        	sep = '\n';
	        } else {
	        	nr = row;
	        	nc = col + 1;
	        	sep = '\t';
	        }
	        for(int i = 0; i < queens.length; i++) {
	        	if(queens[i] == false) {
	        		queens[i] = true;
	        		queensPermutations(qpsf + 1, tq, nr, nc, asf + "q" + (i +1) + sep, queens);
	        		queens[i] = false;
	        	}
	        }
	        queensPermutations(qpsf + 0, tq, nr, nc, asf + "-" + sep, queens);
	    }

	    public static void main(String[] args) throws Exception {
	    	 Scanner br = new Scanner(System.in);
			    System.out.println("Enter the value");
			    int n = br.nextInt();
	        boolean[] queens = new boolean[n];

	        queensPermutations(0, n, 0, 0, "", queens);
	    }
	}



30. NQUEENS COMBINATIONS
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	public static boolean IsQueenSafe(boolean[][] chess, int row, int col) {
        // vertical
        for (int i = row, j = col; i >= 0; i--) {
            if(chess[i][j]){
                return false;
            }
        }

        // horizontal
        for (int i = row, j = col; j >= 0; j--) {
            if(chess[i][j]){
                return false;
            }
        }

        // diagonal
        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
            if(chess[i][j]){
                return false;
            }
        }

        // anti-diagonal
        for (int i = row, j = col; i >= 0 && j < chess.length; i--, j++) {
            if(chess[i][j]){
                return false;
            }
        }

        return true;
    }

    public static void nqueens(int qpsf, int tq, boolean[][] chess, int lcno) {
        if (qpsf == tq) {
            for (int row = 0; row < chess.length; row++) {
                for (int col = 0; col < chess.length; col++) {
                    System.out.print(chess[row][col] ? "q\t" : "-\t");
                }
                System.out.println();
            }
            System.out.println();
            return;
        }

        for (int cell = lcno + 1; cell < chess.length * chess.length; cell++) {
            int row = cell / chess.length;
            int col = cell % chess.length;
            
            if (chess[row][col] == false && IsQueenSafe(chess, row, col)) {
                chess[row][col] = true;
                nqueens(qpsf + 1, tq, chess, cell);
                chess[row][col] = false;
            }
        }
    }

    public static void main(String[] args) throws Exception {
    	 Scanner br = new Scanner(System.in);
		    System.out.println("Enter the value");
		    int n = br.nextInt();
        boolean[][] chess = new boolean[n][n];

        nqueens(0, n, chess, -1);
    }
}


31. NQUEENS PERMUTATIONS
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static boolean IsQueenSafe(int[][] chess, int row, int col) {
	        // vertical
	        for (int i = row, j = col; i >= 0; i--) {
	            if(chess[i][j] > 0){
	                return false;
	            }
	        }

	        for (int i = row, j = col; i < chess.length; i++) {
	            if(chess[i][j] > 0){
	                return false;
	            }
	        }

	        // horizontal
	        for (int i = row, j = col; j >= 0; j--) {
	            if(chess[i][j] > 0){
	                return false;
	            }
	        }

	        for (int i = row, j = col; j < chess.length; j++) {
	            if(chess[i][j] > 0){
	                return false;
	            }
	        }

	        // diagonal
	        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
	            if(chess[i][j] > 0){
	                return false;
	            }
	        }

	        for (int i = row, j = col; i < chess.length && j < chess.length; i++, j++) {
	            if(chess[i][j] > 0){
	                return false;
	            }
	        }

	        // anti-diagonal
	        for (int i = row, j = col; i >= 0 && j < chess.length; i--, j++) {
	            if(chess[i][j] > 0){
	                return false;
	            }
	        }

	        for (int i = row, j = col; i < chess.length && j >= 0; i++, j--) {
	            if(chess[i][j] > 0){
	                return false;
	            }
	        }

	        return true;
	    }

	    public static void nqueens(int qpsf, int tq, int[][] chess) {
	        if (qpsf == tq) {
	            for (int row = 0; row < chess.length; row++) {
	                for (int col = 0; col < chess.length; col++) {
	                	if(chess[row][col] == 0) {
	                		  System.out.print( "-\t");
	                	} else {
	                		 System.out.print( "q"+ chess[row][col] + "\t");
	                	}
	                }
	                System.out.println();
	            }
	            System.out.println();
	            return;
	        }

	        for (int cell = 0; cell < chess.length * chess.length; cell++) {
	            int row = cell / chess.length;
	            int col = cell % chess.length;

	            if (chess[row][col] == 0 && IsQueenSafe(chess, row, col)) {
	                chess[row][col] = qpsf + 1;
	                nqueens(qpsf + 1, tq, chess);
	                chess[row][col] = 0;
	            }
	        }
	    }

	    public static void main(String[] args) throws Exception {
	    	 Scanner br = new Scanner(System.in);
			    System.out.println("Enter the value");
			    int n = br.nextInt();
	        int[][] chess = new int[n][n];

	        nqueens(0, n, chess);
	    }
	}


	                         
32. KNIGHTS COMBINATIONS
package automate;
import java.io.*;
import java.util.*;

public class MyClass {


	 public static boolean IsKnightSafe(boolean[][] chess, int i, int j) {
	        if(i - 1 >= 0 && j - 2 >= 0 && chess[i - 1][j - 2]){
	            return false;
	        }

	        if(i - 2 >= 0 && j - 1 >= 0 && chess[i - 2][j - 1]){
	            return false;
	        }

	        if(i - 2 >= 0 && j + 1 < chess.length && chess[i - 2][j + 1]){
	            return false;
	        }

	        if(i - 1 >= 0 && j + 2 < chess.length && chess[i - 1][j + 2]){
	            return false;
	        }

	        return true;
	    }

	    public static void nknights(int kpsf, int tk, boolean[][] chess, int lcno) {
	        if (kpsf == tk) {
	            for (int row = 0; row < chess.length; row++) {
	                for (int col = 0; col < chess.length; col++) {
	                    System.out.print(chess[row][col] ? "k\t" : "-\t");
	                }
	                System.out.println();
	            }
	            System.out.println();
	            return;
	        }

	        for (int cell = lcno + 1; cell < chess.length * chess.length; cell++) {
	            int row = cell / chess.length;
	            int col = cell % chess.length;
	            
	            if (chess[row][col] == false && IsKnightSafe(chess, row, col)) {
	                chess[row][col] = true;
	                nknights(kpsf + 1, tk, chess,cell);
	                chess[row][col] = false;
	            }
	        }
	    }

	    public static void main(String[] args) throws Exception {
	    	 Scanner br = new Scanner(System.in);
			    System.out.println("Enter the value");
			    int n = br.nextInt();
	        boolean[][] chess = new boolean[n][n];

	        nknights(0, n, chess, -1);
	    }
	}


    
  

	                        	                         
 BIT STUFFING
package automate;
import java.io.*;
import java.util.*;

public class MyClass {

	 public static void main(String[] args) throws Exception {
		 Scanner t = new Scanner(System.in);
	     System.out.println("Enter the value");
	     String data = t.nextLine();
	     String res = " ";
	     bitStuffing(data, res);
	 }
	 
	   public static void bitStuffing(String data, String res) {
	     int counter = 0;
		 for(int i =0; i < data.length(); i++)
		 {
			 if(data.charAt(i)!= '1' && data.charAt(i)!= '0' ) 
			     {
				 
					 System.out.println("Please enter only binary values ");
					 return  ;
				 }
				 if(data.charAt(i) == '1')
				 {
					 counter++;
					 res +=  data.charAt(i); 
				 }
				 else
				 {
					 res +=  data.charAt(i); 
					 counter = 0;
				 }
				 if (counter == 5)
				 {
					 res +=  '0';
					 counter = 0;
				 }
				
		 }
		     System.out.println("Before bit stuffing is : |01111110 | "+data+" |01111110| ");
			 System.out.println(" After stuffing is : |01111110 |  "+res+" |01111110 | ");
			 
		 }	
}



    
   


	                        	                                      


	                                   


	                                   	                                   
		                        


		                                                                                                                                                                                                   
                                                                                                                                                                                               