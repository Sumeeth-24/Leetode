RANK TEAM BY VOTES

// [ABC, ACB, ABC, ACB, ACB]
ans = ACB

class Solution {
    public String rankTeams(String[] votes) {
        int n= votes[0].length();
        HashMap<Character, int[]> map= new HashMap<>();
        for(String str: votes){
            for(int i=0; i<n; i++){
                char ch = str.charAt(i);
                //Initialising an array if the character is absent
                map.computeIfAbsent(ch, a-> new int[n]);
                map.get(ch)[i]++;
            }
        }
        //Sort using the comparator
        List<Character> res= new ArrayList<>(map.keySet());
        //We need to sort according to the positions
        Collections.sort(res, (a,b)->
        {
            for(int i=0; i<n; i++)
                if(map.get(a)[i]!= map.get(b)[i])
                    return map.get(b)[i]- map.get(a)[i];
            return 0;
        });
        
        //Convert it into a string and return
        StringBuilder sb= new StringBuilder();
    	for(int i=0; i<res.size(); i++)
    		sb.append(res.get(i));
    	return sb.toString();
    }
}

COUNT COMMON WORDS WITH ONE OCCURENCE

class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String , Integer> map = new HashMap<>();
        int res = 0 ;
        
        for(int i =0;i< words1.length;i++)
            map.put(words1[i],map.getOrDefault(words1[i],0)+1);
        
        for(int i =0;i< words2.length;i++){

            if(map.containsKey(words2[i]) && map.get(words2[i]) <= 1){
                map.put(words2[i],map.get(words2[i]) - 1);
               
            }
                
            else if(map.containsKey(words2[i]) && map.get(words2[i]) == 0){
                
               
                 res++;
            }
                    
            
        }
        
        return res;
    }
}

                                                 ADVANCE HASHMAP AND HEAP

1. FIND NO.OF EMPLOYEES UNDER EVERY MANAGER

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static void main(String[] args) {
		    Scanner scn = new Scanner(System.in);
		    System.out.println("Enter the value");
		    int n = scn.nextInt();
		    
		    HashMap<String, String> map = new HashMap<String, String>(); 
		    for (int i = 0; i < n; i++) {
			      map.put(scn.next(), scn.next());
			      }
		    findCount(map);
	 }
	 
	 public static void findCount(HashMap<String, String> map) {
		   HashMap<String, HashSet<String>> tree = new HashMap<>();
		   String ceo = "";
		   
		   for(String emp: map.keySet()) {
			   String man = map.get(emp);
			   
			   if(man.equals(emp)) {
				   ceo = man;
			   } else {
				   if(tree.containsKey(man)) {
					   HashSet<String> emps = tree.get(man);
					   emps.add(emp);
				   } else {
					   HashSet<String> emps = new HashSet<>();
					   emps.add(emp);
					   tree.put(man , emps);
				   }
			   }
		   }
		   
		   HashMap<String, Integer> result = new HashMap<>();
		   getSize(tree, ceo, result);
		   
		   for(String emp: result.keySet()) {
			   System.out.println(emp + " " +result.get(emp));
		   }
		}
	 
	 public static int getSize(HashMap<String, HashSet<String>> tree, String man, HashMap<String, Integer> result) {
		 if(tree.containsKey(man) == false) {
			 result.put(man,  0);
			 return 1;
		 }
		 
		 int sz = 0;
		 
		 for(String emp: tree.get(man)) {
			 int cs = getSize(tree, emp, result);
			 sz += cs;
		 }
		 
		 result.put(man, sz);
		 return sz + 1;
	 }
}


2. ITERNARY FROM TICKETS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int noofpairs_src_des = scn.nextInt();
		HashMap<String, String> map = new HashMap<>();
	
		for (int i = 0; i < noofpairs_src_des; i++) {
			String s1 = scn.next();
			String s2 = scn.next();
			map.put(s1, s2);
			
		}

		// first we have to find starting point
		HashMap<String, Boolean> psrc = new HashMap<>();
		for(String src: map.keySet()) {
			String dest = map.get(src);
			
			psrc.put(dest, false);
			if(psrc.containsKey(src) == false) {
				psrc.put(src, true);
			}
		}
		
		String src = "";
		for(String pot: psrc.keySet()) {
			Boolean val = psrc.get(pot);
			if(val == true) {
				src = pot;
				break;
			}
		}
		
		while(true) {
			if(map.containsKey(src) == true) {
				System.out.print(src + "->");
				src = map.get(src);
			} else {
				System.out.print(src + ".");
				break;
			}
		}

	}
}



RECONSTRUCT ITERNARY

Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is larger in lexical order.

class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        LinkedList<String> ret = new LinkedList<String>();
    Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();
    Stack<String> stack = new Stack<String>();
    for(List<String> t : tickets) {
        if(!map.containsKey(t.get(0))) map.put(t.get(0), new PriorityQueue<String>());
        map.get(t.get(0)).add(t.get(1));
    }
    stack.push("JFK");
    while(!stack.isEmpty()) {
        String next = stack.peek();
        if(map.containsKey(next) && map.get(next).size() > 0) stack.push(map.get(next).poll());
        else ret.addFirst(stack.pop());
    }
    return ret;
    }
}


3. ARRAY PAIR DIVISIBLE BY K

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < n; i++){
			arr[i] = scn.nextInt();
		}
		int k = scn.nextInt();
		solution(arr,k);
	}

	public static void solution(int[] arr, int k){
		// frequency map of remainders
		HashMap<Integer, Integer> rfmap = new HashMap<>();
		
		for (int val : arr) {
			
			int rem = val % k;
			if(rem < 0) {
				rem += k;
			}
			int of = rfmap.getOrDefault(rem, 0);
			rfmap.put(rem, of + 1);
		}



		for (int val : arr) {
			int rem = val % k;
			if(rem < 0) {
				rem += k;
			}
			
			if(rem == 0) {
				int fq = rfmap.get(rem);
				if(fq % 2 == 1) {
					System.out.println(false);
					return;
				}
			} else if(2 * rem == k) {
				int fq = rfmap.get(rem);
				if(fq % 2 == 1) {
					System.out.println(false);
					return;
				}
			} else {
				int fq = rfmap.get(rem);
				int ofq = rfmap.get(k - rem);
				if(fq != ofq) {
					System.out.println(false);
					return;
				}
				
			}
		}

		System.out.println("true");
	}
}


4. DISTINCT ELEMENTS IN WINDOWS OF SIZE K

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int[] arr = new int[scn.nextInt()];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = scn.nextInt();
		}
		int k = scn.nextInt();
		ArrayList<Integer> ans = solution(arr,k);
		for(int a : ans){
			System.out.print(a + " ");
		}
	}

	public static ArrayList<Integer> solution(int[] arr, int k) {
		ArrayList<Integer> ans = new ArrayList<>();
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		
		
		for(int i = 0 ; i <= k - 2; i++) {
			map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
		}
		for(int j = 0, i = k - 1; i < arr.length;) {
			map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);   // acquire
			
			ans.add(map.size());  // work
			
			//release
			int freq = map.get(arr[j]);
			if(freq == 1) {
				map.remove(arr[j]);
			} else {
				map.put(arr[j], freq - 1);
			}
			
			i++;
			j++;
		}
		
		return ans;
	}

}


5. LARGEST SUBARRAY WITH 0 SUM

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int[] arr = new int[scn.nextInt()];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	public static int solution(int[] arr) {
		HashMap<Integer, Integer> map = new HashMap<>();
		int mlen = 0;
		
		int i = -1;
		int sum = 0;
		map.put(sum,  -1);
		while(i < arr.length - 1) {
			i++;
			sum += arr[i];
			
			if(map.containsKey(sum) == false) {
				map.put(sum, i);
			} else {
				int len = i - map.get(sum);
				if(len > mlen) {
					mlen = len;
				}
			}
		}
		
		return mlen;
	}

}


6. COUNT OF ZERO SUM SUBARRAY

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int n = scn.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));

	}

	public static int solution(int[] arr) {
		int count = 0;
		HashMap<Integer, Integer> map = new HashMap<>();
		
		
		int i = -1;
		int sum = 0;
		map.put(sum, 1);
		while(i < arr.length - 1) {
			i++;
			sum += arr[i];
			
			if(map.containsKey(sum)) {
				count += map.get(sum);
				map.put(sum, map.get(sum) + 1);
			} else {
				map.put(sum, 1);
			}
		}
		
		return count;
	}

}



7. MINIMUM WINDOW SUBSTRING  (smallest substring of a string containing all characters of another string )

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1,s2));
	}

	public static String solution(String s1, String s2){
	   String ans = "";
	   
	   HashMap<Character, Integer> map2 = new HashMap<>();
	   for(int i = 0; i < s2.length(); i++) {
		   char ch = s2.charAt(i);
		   map2.put(ch, map2.getOrDefault(ch, 0) + 1);
	   }
	   
	   int mct = 0;
	   int dmct = s2.length();
	   
	   HashMap<Character, Integer> map1 = new HashMap<>();
	   int i = -1;
	   int j = -1;
	   
	   while(true) {
		   boolean f1 = false;
		   boolean f2 = false;
		   //acquire
		   while(i < s1.length() - 1 && mct < dmct) {
			   i++;
			   char ch = s1.charAt(i);
			   map1.put(ch, map1.getOrDefault(ch, 0) + 1); 
			   
			   if(map1.getOrDefault(ch, 0) <= map2.getOrDefault(ch, 0)) {
				   mct++;
			   }
			   f1 = true;
		   }
		   
		   //collect answers and release
		   while(j < i && mct == dmct) {
			   String pans = s1.substring(j + 1, i + 1);
			   if(ans.length() == 0 || pans.length() < ans.length()) {
				   ans = pans;
			   }
			   
			   j++;
			   char ch = s1.charAt(j);
			   if(map1.get(ch) == 1) {
				   map1.remove(ch);
			   } else {
				   map1.put(ch, map1.get(ch) - 1);
			   }
			   
			   if(map1.getOrDefault(ch, 0) < map2.getOrDefault(ch, 0)) {
				   mct--;
			   }
			   f2 = true;
		   }
		   if(f1 == false && f2 == false) {
			   break;
		   }
		   
	   }
	   return ans;
	}

}


8. MINIMUM WINDOW SUBSTRING 2 ( smallest substring of a string containing all unique character of itself )

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static int solution(String str){
		int len = str.length();
		
	    HashSet<Character> set = new HashSet<>();
	    for(int i = 0 ; i < str.length(); i++){
	        char ch = str.charAt(i);
	        set.add(ch);
	    }
	    
	    int i = -1;
	    int j = -1;
	    HashMap<Character, Integer> map = new HashMap<>();
	    while(true) {
	    	boolean f1 = false;
	    	boolean f2 = false;
	    	// acquire till it is invalid 
	    	while(i < str.length() - 1 && map.size() < set.size()) {
	    		i++;
	    		char ch = str.charAt(i);
	    		map.put(ch, map.getOrDefault(ch, 0) + 1);
	    		f1 = true;
	    	}
	    	
	    	// collect and release
	    	while(j < i && map.size() == set.size()) {
	    		int plen = i - j;
	    		if(plen < len) {
	    			len = plen;
	    		}
	    		
	    		j++;
	    		char ch = str.charAt(j);
	    		if(map.get(ch) == 1) {
	    			map.remove(ch);
	    		} else {
	    			map.put(ch, map.get(ch) - 1);
	    		}
	    		f2 = true;
	    	}
	    	if(f1 == false && f2 == false) {
	    		break;
	    	}
	    }
	    return len;
	
	}

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String str = scn.next();
		System.out.println(solution(str));
   }
}



9. LONGEST SUBSTRING WITHOUT REPEATING CHARACTERS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static int solution(String str) {
  int ans = 0;
  
  int i = -1;
  int j = -1;
  HashMap<Character, Integer> map = new HashMap<>();
  while(true) {
	  boolean f1 = false;
    	boolean f2 = false;
	  // acquire
	  while(i < str.length() - 1) {
		  f1 = true;
		  i++;
		  char ch = str.charAt(i);
		  map.put(ch, map.getOrDefault(ch, 0) + 1);
		  
		  if(map.get(ch) == 2) {
			  break;
		  } else {
			  int len = i - j;
			  if(len > ans) {
				  ans = len;
			  }
		  }
	  }
	  
	  // release
	  while(j < i) {
		  f2 = true;
		  j++;
		  char ch = str.charAt(j);
		  map.put(ch, map.get(ch) - 1);
		  
		  if(map.get(ch) == 1) {
			  break;
		  }
	  }
	  if(f1 == false && f2 == false) {
  		break;
  	}
}
  return ans;
}



	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String str = scn.next();
		System.out.println(solution(str));
   }
}



10. COUNT OF SUBSTRINGS WITHOUT REPEATING CHARACTERS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static int solution(String str) {
  int ans = 0;
  
  int i = -1;
  int j = -1;
  HashMap<Character, Integer> map = new HashMap<>();
  while(true) {
	  boolean f1 = false;
    	boolean f2 = false;
	  // acquire
	  while(i < str.length() - 1) {
		  f1 = true;
		  i++;
		  char ch = str.charAt(i);
		  map.put(ch, map.getOrDefault(ch, 0) + 1);
		  
		  if(map.get(ch) == 2) {
			  break;
		  } else {
			 ans += i - j;
		  }
	  }
	  
	  // release
	  while(j < i) {
		  f2 = true;
		  j++;
		  char ch = str.charAt(j);
		  map.put(ch, map.get(ch) - 1);
		  
		  if(map.get(ch) == 1) {
			  ans += i - j;
			  break;
		  }
	  }
	  if(f1 == false && f2 == false) {
  		break;
  	}
}
  return ans;
}



	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String str = scn.next();
		System.out.println(solution(str));
   }
}



11. LONGEST SUBSTRING WITH EXACTLY K DISTINCT CHARACTERS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
        String str = scn.next();
        int k = scn.nextInt();
		System.out.println(solution(str,k));
	}

	public static int solution(String str, int k){
	   int ans = 0;
	   
	   int i = -1;
	   int j = -1;
	   HashMap<Character, Integer> map = new HashMap<>();
	   while(true) {
		   boolean f1 = false;
		   boolean f2 = false;
		   
		   while(i < str.length() - 1) {
			   f1 = true;
			   
			   i++;
			   char ch = str.charAt(i);
			   map.put(ch, map.getOrDefault(ch, 0) + 1);
			   
			   if(map.size() < k) {
				   continue;
			   } else if(map.size() == k) {
				   int len = i - j;
				   if(len > ans) {
					   ans = len;
				   }
			   } else {
				   break;
			   }
		   }
		   while(j < i) {
			   f2 = true;
			   
			   j++;
			   char ch = str.charAt(j);
			   if(map.get(ch) == 1) {
				   map.remove(ch);
			   } else {
				   map.put(ch, map.get(ch) - 1);
			   }
			   if(map.size() > k) {
				   continue;
			   } else if(map.size() == k) {
				   int len = i - j;
				   if(len > ans) {
					   ans = len;
				   }
				   break;
			   } 
		   }
		   if(f1 == false && f2 == false) {
			   break;
		   }
	   }
	   return ans;
	}

}



12. COUNT SUBSTRINGS WITH K DISTINCT CHARACTERS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		 String str = scn.next();
	        int k = scn.nextInt();
			System.out.println(solution(str,k));
		}

	
	public static int solutionfork1(String str) {
		int ans = 0;
		
		 HashMap<Character, Integer> map = new HashMap<>();
		 int i = -1;
		 int j = -1;
		 while(true) {
			 boolean f1 = false;
			   boolean f2 = false;
			 while(i < str.length() - 1) {
				 f1 = true;
				 i++;
				 char ch = str.charAt(i);
				   map.put(ch, map.getOrDefault(ch, 0) + 1);
				   
				   if(map.size() == 2) {
					   removeInMap(map, ch);
					   i--;
					   break;
				   }
			 }
			 
			 while (j < i) {
				 f2 = true;
				 if(map.size() == 1) {
					 ans += i - j;
				 }
				 j++;
				 char ch = str.charAt(i);
				   removeInMap(map, ch);
				   
				   if(map.size() == 0) {
					   break;
				   }
			 }
			 
			 if(f1 == false && f2 == false) {
				 break;
			 }
		 }
		
		return ans;
	}
	public static int solution(String str, int k){
	   int ans = 0;
	   
	 if(k == 1) {
		 return solutionfork1(str);
	 }
	   HashMap<Character, Integer> mapb = new HashMap<>();
	   HashMap<Character, Integer> maps = new HashMap<>();
	   int is = -1;
	   int ib = -1;
	   int j = -1;
	   
	   while(true) {
		   boolean f1 = false;
		   boolean f2 = false;
		   boolean f3 = false;
		   
		   while(ib < str.length() - 1) {
			   f1 = true;
			   
			   ib++;
			   char ch = str.charAt(ib);
			   mapb.put(ch, mapb.getOrDefault(ch, 0) + 1);
			   
			   if(mapb.size() > k) {
				   removeInMap(mapb, ch);
				   ib--;
				   break;
			   }
		   }
		   
		   while(is < ib) {
			   f2 = true;
			   
			   is++;
			   char ch = str.charAt(is);
			   maps.put(ch, maps.getOrDefault(ch, 0) + 1);
			   
			   if(maps.size() == k) {
				   removeInMap(maps, ch);
				   is--;
				   break; 
			   }
		   }
		   
		   while(j < is) {
			   f3 = true;
			   
			   if(mapb.size() == k && maps.size() == k - 1) {
				   ans += ib - is;
			   }
			   
			   j++;
			   char ch = str.charAt(j);
			   removeInMap(maps, ch);
			   removeInMap(mapb, ch);
			   
			   if(maps.size() < k - 1 || mapb.size() < k) {
				   break;
			   }
			   
		   }
		   if(f1 == false && f2 == false && f3 == false) {
			   break;
		   }
	   }
	   return ans;
	}
	
	public static void removeInMap(HashMap<Character, Integer> map, char ch) {
		if(map.get(ch) == 1) {
			map.remove(ch);
		} else {
			map.put(ch, map.get(ch) - 1);
		}
	}

}




class Solution {
    
    public static int solutionfork1(int[] arr) {
		int ans = 0;
		
		 HashMap<Integer, Integer> map = new HashMap<>();
		 int i = -1;
		 int j = -1;
		 while(true) {
			 boolean f1 = false;
			   boolean f2 = false;
			 while(i < arr.length - 1) {
				 f1 = true;
				 i++;
				 int ch = arr[i];
				   map.put(ch, map.getOrDefault(arr[i], 0) + 1);
				   
				   if(map.size() == 2) {
					   removeInMap(map, ch);
					   i--;
					   break;
				   }
			 }
			 
			 while (j < i) {
				 f2 = true;
				 if(map.size() == 1) {
					 ans += i - j;
				 }
				 j++;
				 int ch = arr[j];
				   removeInMap(map, ch);
				   
				   if(map.size() == 0) {
					   break;
				   }
			 }
			 
			 if(f1 == false && f2 == false) {
				 break;
			 }
		 }
		
		return ans;
	}
    
    
    public int subarraysWithKDistinct(int[] nums, int k) {
        int ans = 0;
	   
	  if(k == 1) {
	  return solutionfork1(nums);
	  }
	   HashMap<Integer, Integer> mapb = new HashMap<>();
	   HashMap<Integer, Integer> maps = new HashMap<>();
	   int is = -1;
	   int ib = -1;
	   int j = -1;
	   
	   while(true) {
		   boolean f1 = false;
		   boolean f2 = false;
		   boolean f3 = false;
		   
		   while(ib < nums.length - 1) {
			   f1 = true;
			   
			   ib++;
			  
			   mapb.put(nums[ib], mapb.getOrDefault(nums[ib], 0) + 1);
			   
			   if(mapb.size() > k) {
                   int ch = nums[ib];
				   removeInMap(mapb, nums[ib]);
				   ib--;
				   break;
			   }
		   }
		   
		   while(is < ib) {
			   f2 = true;
			   
			   is++;
			   
			   maps.put(nums[is], maps.getOrDefault(nums[is], 0) + 1);
			   
			   if(maps.size() == k) {
                    int ch = nums[is];
				   removeInMap(maps, nums[is]);
				   is--;
				   break; 
			   }
		   }
		   
		   while(j < is) {
			   f3 = true;
			   
			   if(mapb.size() == k && maps.size() == k - 1) {
				   ans += ib - is;
			   }
			   
			   j++;
			   
               int ch = nums[j];
			   removeInMap(maps, nums[j]);
			   removeInMap(mapb, nums[j]);
			   
			   if(maps.size() < k - 1 || mapb.size() < k) {
				   break;
			   }
			   
		   }
		   if(f1 == false && f2 == false && f3 == false) {
			   break;
		   }
	   }
	   return ans;
	}
	
	public static void removeInMap(HashMap<Integer, Integer> map, int ch) {
		if(map.get(ch) == 1) {
			map.remove(ch);
		} else {
			map.put(ch, map.get(ch) - 1);
		}
    }
}



13. COUNT OF EQUIVALENT SUBARRAYS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
        int n = scn.nextInt();
        int[] arr = new int[n];
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0 ; i  < n; i++){
            arr[i] = scn.nextInt();
            set.add(arr[i]);
        }
        
        int k = set.size();
        
        int ans = 0;
        int i = -1;
        int j = -1;
        HashMap<Integer, Integer> map = new HashMap<>();
        while(true) {
        	boolean f1 = false;
        	boolean f2 = false;
        	while(i < arr.length - 1) {
        		f1 = true;
        		
        		i++;
        		map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
        		
        		if(map.size() == k) {
        			ans += arr.length - i;
        			break;
        		}
        	}
        	while(j < i) {
        		f2 = true;
        		
        		j++;
        		if(map.get(arr[j]) == 1){
        			map.remove(arr[j]);
        		} else {
        			map.put(arr[i], map.get(arr[i] - 1));
        		}
        		
        		if(map.size() == k) {
        			ans += arr.length - i;
        		} else {
        			break;
        		}
        	}
        	
        	if(f1 == false && f2 == false) {
        		break;
        	}
        }
        
        System.out.println(ans);
        
	}

	
}


14. MAXIMUM CONSECUTIVE ONES FOR GIVEN K

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0 ; i  < n; i++){
            arr[i] = scn.nextInt();
        }
        int k = scn.nextInt();
        System.out.println(solution(arr,k));
	}

	public static int solution(int[] arr, int k){
      
        int ans = 0;
        
        int j = -1;
        int count = 0;
        for(int i = 0 ;i < arr.length; i++){
            if(arr[i] == 0){
                count++;
            }
            
                while(count > k){
                	j++;
                    if(arr[j] == 0){
                        count--;
                    }
                }
                int len = i - j;
                if(len > ans) {
                	ans = len;
            }
        }
          
        return ans;
    }

}


15. MAXIMUM CONSECUTIVE ONE FOR K = 1

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0 ; i  < n; i++){
            arr[i] = scn.nextInt();
        }
        int k = scn.nextInt();
        System.out.println(solution(arr,k));
	}

	public static int solution(int[] arr, int k){
      
        int ans = 0;
        
        int j = -1;
        int count = 0;
        for(int i = 0 ; i < arr.length; i++){
            if(arr[i] == 0){
                count++;
            }
            
                while(count > 1){
                	j++;
                    if(arr[j] == 0){
                        count--;
                    }
                }
                int len = i - j;
                if(len > ans) {
                	ans = len;
            }
        }
          
        return ans;
    }

}



16. LENGTH OF LARGEST SUBARRAY WITH CONTINUOUS ELEMENT

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int[] arr = new int[scn.nextInt()];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	public static int solution(int[] arr) {
		int ans = 0;
		
		for (int i = 0; i < arr.length - 1; i++) {
			int min = arr[i];
			int max = arr[i];
			
			HashSet<Integer> checkduplicacy = new HashSet<Integer>();
			checkduplicacy.add(arr[i]);
			
			for (int j = i + 1; j < arr.length; j++) {
				if (checkduplicacy.contains(arr[j])) {
					break;
				}
				checkduplicacy.add(arr[j]);
				
				min = Math.min(min, arr[j]);
				max = Math.max(max, arr[j]);
				if (max - min == j - i) {
					int len = j - i + 1;
					if(len > ans) {
						ans = len;
					}
				}
			}
		}

		return ans;
	}

}



17. LONGEST SUBSTRING WITH ATMOST K UNIQUE CHARACTERS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
        String str = scn.next();
        int k = scn.nextInt();
		System.out.println(solution(str,k));
	}

	public static int solution(String str, int k){
	   int ans = 0;
	   
	   int i = -1;
	   int j = -1;
	   HashMap<Character, Integer> map = new HashMap<>();
	   while(true) {
		   boolean f1 = false;
		   boolean f2 = false;
		   
		   while(i < str.length() - 1) {
			   f1 = true;
			   
			   i++;
			   char ch = str.charAt(i);
			   map.put(ch, map.getOrDefault(ch, 0) + 1);
			   
			   if(map.size() <= k) {
				   int len = i - j;
				   if(len > ans) {
					   ans = len;
				   }
			   } else {
				   break;
			   }
		   }
		   
		   while(j < i) {
			   f2 = true;
			   
			   j++;
			   char ch = str.charAt(j);
			   if(map.get(ch) == 1) {
				   map.remove(ch);
			   } else {
				   map.put(ch, map.get(ch) - 1);
			   }
			   
			   if(map.size() > k) {
				   continue;
			   } else {
				   int len = i - j;
				   if(len > ans) {
					   ans = len;
				   }
				   break;
			   } 
		   }
		   if(f1 == false && f2 == false) {
			   break;
		   }
	   }
	   return ans;
	}

}


                        
18. COUNT OF SUBSTRINGS WITH ATMOST K DISTINCT CHARACTER

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
        String str = scn.next();
        int k = scn.nextInt();
		System.out.println(solution(str,k));
	}

	public static int solution(String str, int k) {
		int ans = 0;
		
		 HashMap<Character, Integer> map = new HashMap<>();
		 int i = -1;
		 int j = -1;
		 while(true) {
			
			 while(i < str.length() - 1) {
				
				 i++;
				 char ch = str.charAt(i);
				   map.put(ch, map.getOrDefault(ch, 0) + 1);
				   
				   if(map.size() <= k) {
					  ans += i - j;
				   } else {
					   break;
				   }
			 }
			 
			 if(i == str.length() - 1 && map.size() <= k) {
				 break;
			 }
			 
			 while (j < i) {
				j++;
				 char ch = str.charAt(j);
				  if(map.get(ch) == 1) {
					  map.remove(ch);
				  } else {
					  map.put(ch, map.get(ch) - 1);
				  }
				  
				  if(map.size() > k) {
					  continue;
				  } else {
					  ans += i - j;
					  break;
				  }
		 }
			
	}
		 return ans;

	}
}



19. COUNT SUBARRAYS WITH SUM EQUALS K

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
		public static void main(String[] args) {
			Scanner scn = new Scanner(System.in);
			System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for(int i = 0 ; i < n; i++){
	            arr[i] = scn.nextInt();
	        }
	        int target = scn.nextInt();
	        System.out.println(solution(arr,target));
		}

		public static int solution(int[] arr, int target){
	        int ans = 0;
	        
	        HashMap<Integer,Integer> map = new HashMap<>();
	        map.put(0,1);
	        int sum = 0;
	        
	        for(int i = 0 ; i < arr.length; i++){
	            sum += arr[i];
	            if(map.containsKey(sum - target)){
	                ans += map.get(sum - target);
	            }
	            map.put(sum,map.getOrDefault(sum,0) + 1);
	        }
	        return ans;
	    }

	}

LONGEST SUBARRAYS WITH SUM EQUALS TOTAL - X
class Solution {
    public int minOperations(int[] arr, int x) {
         int ans = -1;
        int target = 0;
          target = target - x;
        for(int val : arr){
            target += val;
        } 
        
        if(target == 0) return arr.length;
      
	        
	        HashMap<Integer,Integer> map = new HashMap<>();
	        map.put(0,-1);
	        int sum = 0;
	        
	        for(int i = 0 ; i < arr.length; i++){
	            sum += arr[i];
	            if(map.containsKey(sum - target)){
	                ans = Math.max(ans, i - map.get(sum - target));
	            }
	            map.put(sum,i);
	        }
	        return ans == -1 ? -1 : arr.length - ans;
    }
}

                        
20. FIND ALL ANAGRAMS IN A STRING

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static boolean compare(HashMap<Character, Integer> pmap, HashMap<Character, Integer> smap) {
		for(char sch: smap.keySet()) {
			if(pmap.getOrDefault(sch, 0) != smap.get(sch)) {
				return false;
			}
		}
		return true;
	}
	public static void findAnagrams(String s, String p) {
		HashMap<Character, Integer> smap = new HashMap<>();
		HashMap<Character, Integer> pmap = new HashMap<>();
		
		for(int i = 0; i < p.length(); i++) {
			char ch = p.charAt(i);
			pmap.put(ch, pmap.getOrDefault(ch, 0) + 1);
		}
		
		for(int i = 0; i < p.length(); i++) {
			char ch = s.charAt(i);
			smap.put(ch, smap.getOrDefault(ch, 0) + 1);
		}
		
		
		int i = p.length();
		int count = 0;
		
		String ans = "";
		while(i < s.length()) {
			if(compare(pmap, smap) == true) {
				count++;
				ans += (i - p.length()) + " ";
			}
			
			char cha = s.charAt(i);
			smap.put(cha, smap.getOrDefault(cha, 0) + 1);
			
			char chr = s.charAt(i - p.length());
			if(smap.get(chr) == 1) {
				smap.remove(chr);
			} else {
				smap.put(chr, smap.get(chr) - 1);
			}
			i++;
			
		}
		if(compare(pmap, smap) == true) {
			count++;
			ans += (i - p.length()) + " ";
		}
		System.out.println(count);
		System.out.println(ans);
	}
		

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String s = scn.next();
		String p = scn.next();
		findAnagrams(s, p);
	}

}


21. CHECK IF TWO STRINGS ARE K ANAGRAMS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static boolean areKAnagrams(String str1, String str2, int k) {
		if (str1.length() != str2.length()) {
			return false;
		}
		HashMap<Character, Integer> map = new HashMap<>();
		for(int i = 0; i < str1.length(); i++) {
			char ch = str1.charAt(i);
			map.put(ch, map.getOrDefault(ch, 0) + 1);
		}
		
		for(int i = 0; i < str2.length(); i++) {
			char ch = str2.charAt(i);
			if(map.getOrDefault(ch, 0) > 0) {
				map.put(ch, map.get(ch) - 1);
			}
		}
		
		int count = 0;
		for(char ch: map.keySet()) {
			count += map.get(ch);
		}
		
		if(count > k) {
			return false;
		} else {
			return true;
		}
	}
		
		

	public static void main(String[] args) {

		Scanner s = new Scanner(System.in);
		System.out.println("Enter the value");
		String str1 = s.next();
		String str2 = s.next();
		int k = s.nextInt();
		System.out.println(areKAnagrams(str1, str2, k));

	}

}

22. FIND ANAGRAM MAPPING

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static class Pair{
		int idx = 0;
		ArrayList<Integer> list = new ArrayList<>();
	}
	
	
	public static int[] anagramMappings(int[] arr1, int[] arr2) {
		HashMap<Integer, Pair> map = new HashMap<>();
		for(int i = 0 ;i < arr2.length ;i++) {
			if(map.containsKey(arr2[i])){
				Pair p = map.get(arr2[i]);
				p.list.add(i);
			}else{
				Pair p = new Pair();
				p.list.add(i);
				map.put(arr2[i],p);
			}
		}
		
		int[] ans = new int[arr1.length];
		for(int i = 0 ; i < arr1.length; i++) {
			Pair p = map.get(arr1[i]);
			ans[i] = p.list.get(p.idx);
			p.idx++;
		}
		
		return ans;
	}

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		System.out.println("Enter the value");
		int n = s.nextInt();
		int[] a = new int[n];
		int[] b = new int[n];
		for (int i = 0; i < a.length; i++) {
			a[i] = s.nextInt();
		}
		for (int j = 0; j < b.length; j++) {
			b[j] = s.nextInt();
		}
		int[] res = anagramMappings(a, b);
		for (int j = 0; j < res.length; j++) {
			System.out.print(res[j] + " ");
		}
	}

}

23. VALID ANAGRAMS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static boolean solution(String s1, String s2){
		HashMap<Character,Integer> map = new HashMap<>();
		for(int i = 0 ; i < s1.length(); i++){
			char ch = s1.charAt(i);
			map.put(ch,map.getOrDefault(ch, 0) + 1);
		}
		for(int i = 0 ; i < s2.length(); i++){
			char ch = s2.charAt(i);
			
			if(map.containsKey(ch) == false){
				return false;
			} 
			else if(map.get(ch) == 1){
				map.remove(ch);
			}
			else {
				map.put(ch, map.get(ch) - 1);
			}
		}
		return map.size() == 0;
	}
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1,s2));
	}

}


24. GROUP ANAGRAMS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static ArrayList<ArrayList<String>> groupAnagrams(String[] strs) {
		HashMap<HashMap<Character, Integer>, ArrayList<String>> bmap = new HashMap<>();

		for (String str : strs) {
			HashMap<Character, Integer> fmap = new HashMap<>();
			for (int i = 0; i < str.length(); i++) {
				char ch = str.charAt(i);
				fmap.put(ch, fmap.getOrDefault(ch, 0) + 1);
			}
			if (bmap.containsKey(fmap)== false) {
				ArrayList<String> al = new ArrayList<String>();
				al.add(str);
				bmap.put(fmap, al);
			} else {
				ArrayList<String> al = bmap.get(fmap);
				al.add(str);
				
			}

		}
		ArrayList<ArrayList<String>> ans = new ArrayList<>();
		for (ArrayList<String> al : bmap.values()) {
			ans.add(al);
		}
		return ans;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the value");
		int N = sc.nextInt();
		String[] arr = new String[N];
		for (int i = 0; i < N; i++) {
			arr[i] = sc.next();
		}
		ArrayList<ArrayList<String>> anagramsGrouped = groupAnagrams(arr);
		for (ArrayList<String> lst : anagramsGrouped) {
			Collections.sort(lst);
		}
	//	anagramsGrouped.sort(new ListComparator());
		display(anagramsGrouped);
	}

	// it is used to make the result unique
//	static class ListComparator implements Comparator<List<String>> {
//		@Override
//		public int compare(List<String> l1, List<String> l2) {
//			if (l1.size() != l2.size()) {
//				return l2.size() - l1.size();
//			}
//
//			String l1str = l1.get(0);
//			String l2str = l2.get(0);
//			return l1str.compareTo(l2str);

//		}
//	}

	public static void display(ArrayList<ArrayList<String>> list) {
		for (int i = 0; i < list.size(); i++) {
			ArrayList<String> currList = list.get(i);
			for (int j = 0; j < currList.size(); j++) {
				System.out.print(currList.get(j) + " ");
			}
			System.out.println();
		}
	}

}

25. GROUP SHIFTED STRINGS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static String getKey(String str) {
		String key = "";
		
		for(int i = 1; i < str.length(); i++) {
			char curr = str.charAt(i);
			char prev = str.charAt(i - 1);
			int diff = curr - prev;
			
			if(diff < 0) {
				diff += 26;
			}
			
			key += diff + "#";
		}
		key += ".";
		
		return key;
	}
	
	public static ArrayList<ArrayList<String>> groupShiftedStrings(String[] strs) {
		
		HashMap<String, ArrayList<String>> map = new HashMap<>();
		
		for(String str: strs) {
			String key = getKey(str);
			if(map.containsKey(key) == false) {
				ArrayList<String> list = new ArrayList<>();
				list.add(str);
				map.put(key, list);
			} else {
				ArrayList<String> list = map.get(key);
				list.add(str);
			}
			
		}

		ArrayList<ArrayList<String>> ans = new ArrayList<>();
		for (ArrayList<String> al : map.values()) {
			ans.add(al);
		}
		return ans;
	}

	public static String generatecode(String str) {
		String ans = "";
		for(int i = 1; i < str.length() ; i++) {
			char ch1 = str.charAt(i);
			char ch2 = str.charAt(i - 1);
			int diff = ch1 - ch2;
			if(diff < 0) {
				diff += 26;
			}
			ans += 'a' + diff;
		}
		
		return ans;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the value");
		int N = sc.nextInt();
		String[] arr = new String[N];
		for (int i = 0; i < N; i++) {
			arr[i] = sc.next();
		}
		ArrayList<ArrayList<String>> shiftedGroup = groupShiftedStrings(arr);
		for (ArrayList<String> lst : shiftedGroup) {
			Collections.sort(lst);
		}
		shiftedGroup.sort(new ListComparator());
		display(shiftedGroup);
	}

	// it is used to make the result unique
	static class ListComparator implements Comparator<List<String>> {
		@Override
		public int compare(List<String> l1, List<String> l2) {
			if (l1.size() != l2.size()) {
				return l2.size() - l1.size();
			}

			String l1str = l1.get(0);
			String l2str = l2.get(0);
			return l1str.compareTo(l2str);

		}
	}

	public static void display(ArrayList<ArrayList<String>> list) {
		for (int i = 0; i < list.size(); i++) {
			ArrayList<String> currList = list.get(i);
			for (int j = 0; j < currList.size(); j++) {
				System.out.print(currList.get(j) + " ");
			}
			System.out.println();
		}
	}

}


26. WORD PATTERNS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		String pattern = scn.nextLine();
		String words = scn.nextLine();
		System.out.println(wordPattern(pattern,words));
	}

	public static boolean wordPattern(String pattern, String str) {
        String[] words = str.split(" ");
		if(words.length != pattern.length()){
		    return false;
		}
		HashMap<Character, String> map = new HashMap<>();
		HashMap<String, Boolean> used = new HashMap<>();
		
		
	    for(int i=0; i < pattern.length(); i++){
	        char ch = pattern.charAt(i);
	        
	        if(map.containsKey(ch) == false){
	        	if(used.containsKey(words[i]) == true) {
	        		return false;
	        	} else {
	        		used.put(words[i], true);
	        		map.put(ch, words[i]);
	        	}
	        } else {
	        	String mwidth = map.get(ch);
	        	if(mwidth.equals(words[i]) == false) {
	        		return false;
	        	}
	        }
	     }
		return true;
    }

}



27. LONGEST SUBARRAY WITH EQUALS 0'S AND 1'S

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        System.out.println(solution(arr));
	    }

	    public static int solution(int[] arr) {
	      
			int ans = 0;
			
			HashMap<Integer, Integer> map = new HashMap<>();
			map.put(0, -1);
			int sum = 0;
			
			for(int i = 0; i < arr.length; i++) {
				if(arr[i] == 0) {
					sum += -1;
				} else if(arr[i] == 1) {
					sum += +1;
				}
				
				if(map.containsKey(sum)) {
					int idx = map.get(sum);
					int len = i - idx;
					if(len > ans) {
						ans = len;
					}
				} else {
					map.put(sum, i);
				}
			}
			return ans;
	    }

	}



28. COUNT OF SUBARRAYS WITH EQUAL 0'S AND 1'S

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        System.out.println(solution(arr));
	    }

	    public static int solution(int[] arr) {
	      
			int ans = 0;
			
			HashMap<Integer, Integer> map = new HashMap<>();
			map.put(0, 1);
			int sum = 0;
			
			for(int i = 0; i < arr.length; i++) {
				if(arr[i] == 0) {
					sum += -1;
				} else if(arr[i] == 1) {
					sum += +1;
				}
				
				if(map.containsKey(sum)) {
				ans += map.get(sum);
				map.put(sum, map.get(sum) + 1);
				} else {
					map.put(sum, 1);
				}
			}
			return ans;
	    }

	}




29. PAIRS WITH EQUAL SUM

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        System.out.println(solution(arr));
	    }

	    public static boolean solution(int[] arr) {
	        HashSet<Integer> set = new HashSet<>();
			for(int i = 0 ; i < arr.length ; i++) {
				for(int j = i + 1; j < arr.length ; j++) {
					int sum = arr[i] + arr[j];
					if(set.contains(sum)){
					    return true;
					}else{
					    set.add(sum);
					}
				}
			}
			return false;
	    }

	}



30. CHECK ARITHMETIC SEQUENCE

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	    	int n = scn.nextInt();
			int[] arr = new int[n];
			for(int i = 0 ; i < n; i++){
				arr[i] = scn.nextInt();
			}
			System.out.println(solution(arr));
		}

		public static boolean solution(int[] arr) {
			if(arr.length == 1) {
				return true;
			}
			HashSet<Integer> set = new HashSet<>();
			int min =  Integer.MAX_VALUE;
			int max = Integer.MIN_VALUE;
			for(int val: arr) {
				min = Math.min(min, val);
				max = Math.max(max, val);
				set.add(val);
			}
			int diff = (max - min) / (arr.length - 1);
			for(int i = 0 ; i < arr.length; i++) {
				int ai = min + i * diff;
				if(set.contains(ai) == false) {
					return false;
				}
		}
			return true;

	}
}


31. LONGEST SUBARRAY WITH SUM DIVISIBLE BY K

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        int k = scn.nextInt();
	        System.out.println(solution(arr, k));
	    }

	    public static int solution(int[] arr, int k) {
	    	int ans = 0;
	    
	      HashMap<Integer, Integer> map = new HashMap<>();
	      
	        int sum = 0;
	        int rem = 0;
	        map.put(0, -1);
	        
	      
	        for (int i = 0; i < arr.length; i++) {
	            sum = sum + arr[i];
	            rem = sum % k;
	            
	            if(rem < 0) {
	            	rem += k;
	            }
	        

	       if(map.containsKey(rem)) {
	    	   int idx = map.get(rem);
	    	   int len = i - idx;
	    	   if(len > ans) {
	    		   ans = len;
	    	   }
	       } else {
	    	   map.put(rem, i);
	       }
	      }
	        return ans;
	}
}


	                 
32. LONGEST SUBARRAY WITH EQUAL 0S, 1S, AND 2S

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        System.out.println(solution(arr));
	    }

	    public static int solution(int[] arr) {
			int ans = 0;
			
			HashMap<String, Integer> map = new HashMap<>();
			int zcount = 0 ;
			int ocount = 0;
			int tcount = 0;
			int delta10 = ocount - zcount;
			int delta21 = tcount - ocount;
			String key = delta10 + "#" + delta21;
			
			map.put(key, -1);
			for(int i = 0 ; i  < arr.length ;i++) {
				if(arr[i] == 1) {
					ocount++;
				}else if(arr[i] == 0) {
					zcount++;
				}else {
					tcount++;
				}
				
				delta10 = ocount - zcount;
			    delta21 = tcount - ocount;
			    key = delta10 + "#" + delta21;
			    
			    if(map.containsKey(key)) {
			    	   int idx = map.get(key);
			    	   int len = i - idx;
			    	   if(len > ans) {
			    		   ans = len;
			    	   }
			       } else {
			    	   map.put(key, i);
			       }
			      }
				
			return ans;
	    }

	}


33. COUNT OF SUBARRAYS WITH EQUAL 0S, 1S AND 2S

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        System.out.println(solution(arr));
	    }

	    public static int solution(int[] arr) {
			int ans = 0;
			
			HashMap<String, Integer> map = new HashMap<>();
			int zcount = 0 ;
			int ocount = 0;
			int tcount = 0;
			int delta10 = ocount - zcount;
			int delta21 = tcount - ocount;
			String key = delta10 + "#" + delta21;
			
			map.put(key, -1);
			for(int i = 0 ; i  < arr.length ;i++) {
				if(arr[i] == 1) {
					ocount++;
				}else if(arr[i] == 0) {
					zcount++;
				}else {
					tcount++;
				}
				
				delta10 = ocount - zcount;
			    delta21 = tcount - ocount;
			    key = delta10 + "#" + delta21;
			    
			    if(map.containsKey(key)) {
			    	  ans += map.get(key);
			    	  map.put(key, map.get(key) + 1);
			       } else {
			    	   map.put(key, 1);
			       }
			   }
				
			return ans;
	    }

	}


34. ISOMORPHIC STRINGS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	    	String A = scn.next();
			String B = scn.next();
			System.out.print(isIsomorphic(A, B));
		}

		public static boolean isIsomorphic(String s, String t) {
			if(s.length() != t.length()) {
				return false;
			}
			
			HashMap<Character, Character> map1 = new HashMap<>();
			HashMap<Character, Boolean> map2 = new HashMap<>();
			
			for(int i = 0 ; i < s.length() ;i++) {
				char ch1 = s.charAt(i);
				char ch2 = t.charAt(i);
				
				if(map1.containsKey(ch1) == true) {
					if(map1.get(ch1) != ch2) {
						return false;
					}
				} else {
					if(map2.containsKey(ch2) == true) {
						return false;
					} else {
						map1.put(ch1, ch2);
						map2.put(ch2, true);
					}
				}
			}
			return true;
		}

	}


35. TASK COMPLETION

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
    public static void completeTask(int n, int m, int[] arr) {
		HashSet<Integer> set = new HashSet<>();
		for(int i = 0 ; i < arr.length; i++){
		    set.add(arr[i]);
		}
		
		ArrayList<Integer> al1 = new ArrayList<>();
		ArrayList<Integer> al2 = new ArrayList<>();
		int counter = 0;
		for(int i = 1; i <= n; i++){
		    if(!set.contains(i)){
		        if(counter % 2 == 0){
		            al1.add(i);
		        }else{
		            al2.add(i);
		        }
		        counter++;
		    }
		}
		
		for(int a : al1){
		    System.out.print(a + " ");
		}
		System.out.println();
		
		for(int a : al2){
		    System.out.print(a + " ");
		}
		System.out.println();
	}

	// Don't make changes here
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int n = scn.nextInt();
		int m = scn.nextInt();
		int[] num = new int[m];
		for (int i = 0; i < m; i++) {
			num[i] = scn.nextInt();
		}
		completeTask(n, m, num);
	}

}

36. FIRST NON REPEATING CHARACTER

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
    public static void completeTask(int n, int m, int[] arr) {
    	Scanner scn = new Scanner(System.in);
    	System.out.println("Enter the value");
    	String s= scn.next();
		System.out.print(solution(s));
	}
	
	public static int solution(String s) {
	  HashMap<Character, Integer> map = new HashMap<>();
	  for(int i = 0 ; i < s.length() ;i++) {
		  char ch = s.charAt(i);
		  map.put(ch, map.getOrDefault(ch, 0) + 1);
	  }
	  for(int i = 0 ; i< s.length() ;i++) {
		  char ch = s.charAt(i);
		  if(map.get(ch) == 1) {
			  return i;
		  }
	  }
	  return -1;
  }

}


37. PAIRS WITH GIVEN SUM IN TWO SORTED MATRICES

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static int solve(int[][] num1, int[][] num2, int k) {
			HashMap<Integer, Integer> map = new HashMap<>();
		
			for(int i = 0 ; i < num1.length ;i++) {
				for(int j = 0; j < num1[0].length ;j++) {
					map.put(num1[i][j], map.getOrDefault(num1[i][j], 0) + 1);
				}
			}
            int ans = 0;
			
			for(int i = 0 ;i < num2.length ;i++) {
				for(int j = 0 ;j < num2[0].length ;j++) {
					int val = num2[i][j];
					int com = k - val;
					if(map.containsKey(com)) {
						ans += map.get(com);
					}
				}
			}
			return ans;
		}

		public static void main(String[] args) {
			Scanner sc = new Scanner(System.in);
			System.out.println("Enter the value");
			int N = sc.nextInt();
			int[][] mat1 = new int[N][N];
			
			for (int i = 0; i < mat1.length; i++) {
				for (int j = 0; j < mat1[0].length; j++) {
					mat1[i][j] = sc.nextInt();
				}
			}

			int[][] mat2 = new int[N][N];
			for (int i = 0; i < mat2.length; i++) {
				for (int j = 0; j < mat2[0].length; j++) {
					mat2[i][j] = sc.nextInt();
				}
			}
			int K = sc.nextInt();
			System.out.println(solve(mat1, mat2, K));

		}

	}



2nd OPTIMAL APPROACH

import java.util.*;

public class Main {
    
    public static int firstIndex(int[][] arr, int data){
        int n = arr.length, si = 0, ei = n*n - 1;
        int idx = -1;
        while(si <= ei){
            int mid = (si + ei)/2;
            int midEle = arr[mid /n][mid % n];
            if(midEle == data){
                idx = mid;
                ei = mid - 1;
            } else if(midEle > data) {
                ei = mid - 1;
            } else si = mid + 1;
        } 
        
        return idx;
    }
    
    
    public static int lastIndex(int[][] arr, int data){
        int n = arr.length, si = 0, ei = n*n - 1;
        int idx = -1;
        while(si <= ei){
            int mid = (si + ei)/2;
            int midEle = arr[mid /n][mid % n];
            if(midEle == data){
                idx = mid;
                si = mid + 1;
            } else if(midEle > data) {
                ei = mid - 1;
            } else si = mid + 1;
        } 
        
        return idx;
    }
	
    public static int solve(int[][] num1, int[][] num2, int k) {
		// write your code here
		if(num1.length == 0 || num1[0].length == 0 || num2.length == 0 || num2[0].length == 0)
		return 0;
		int count = 0;
		
		for(int[] ar : num2){
		    for(int ele : ar){
		        int fi = firstIndex(num1, k - ele);
		        
		        if(fi == -1) continue;
		        
		        int li = lastIndex(num1, k - ele);
		        
		        int numberofelements = (li - fi + 1);
		        count += numberofelements;
		        
		        
		    }
		}

		return count;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[][] mat1 = new int[N][N];
		for (int i = 0; i < mat1.length; i++) {
			for (int j = 0; j < mat1[0].length; j++) {
				mat1[i][j] = sc.nextInt();
			}
		}

		int[][] mat2 = new int[N][N];
		for (int i = 0; i < mat2.length; i++) {
			for (int j = 0; j < mat2[0].length; j++) {
				mat2[i][j] = sc.nextInt();
			}
		}
		int K = sc.nextInt();
		System.out.println(solve(mat1, mat2, K));

	}

}



37. COUNT PAIRS PAIRS WHOSE SUM IS EQUAL TO GIVEN NUMBER

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	 public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	        int target = scn.nextInt();
	        System.out.println(solution(arr, target));
	    }

	 public static int solution(int[] num1,  int k) {
			HashMap<Integer, Integer> map = new HashMap<>();
		
			for(int i = 0 ; i < num1.length ;i++) {
					map.put(num1[i], map.getOrDefault(num1[i], 0) + 1);
				}
			
         int ans = 0;
			
			for(int i = 0 ;i < num1.length ;i++) {
					int val = num1[i];
					int com = k - val;
					if(map.containsKey(com)) {
						ans += map.get(com);
					}
				}
			return ans/2;    // pair two times aata hai
		}
}



38. SMALLEST SUBARRAY WITH HIGHEST FREQUENCY ELEMENT

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static void main(String[] args) {
			Scanner scn = new Scanner(System.in);
			System.out.println("Enter the value");
			int n = scn.nextInt();
			int[] arr = new int[n];
			for(int i = 0 ; i < n; i++){
				arr[i] = scn.nextInt();
			}
			solution(arr);
		}

		public static void solution(int[] arr) {
			HashMap<Integer,Integer> fmap = new HashMap<>();
			HashMap<Integer,Integer> stmap = new HashMap<>();
			
			int hfreq = 0;
			int si = 0;
			int ei = 0;
			int len = ei - si + 1;

			for(int i = 0 ; i < arr.length; i++){
				//if element is not coming for the first time
				if(fmap.containsKey(arr[i])) {
					fmap.put(arr[i], fmap.getOrDefault(arr[i], 0) + 1);
				} else {
					fmap.put(arr[i], 1);
					stmap.put(arr[i], i);
				}
				
				if(fmap.get(arr[i]) > hfreq) {
					hfreq = fmap.get(arr[i]);
					si = stmap.get(arr[i]);
					ei = i;
					len = ei - si + 1;
				} else if(fmap.get(arr[i]) == hfreq) {
					int clen = i - stmap.get(arr[i]) + 1;
					if(clen < len) {
						hfreq = fmap.get(arr[i]);
						si = stmap.get(arr[i]);
						ei = i;
						len = ei - si + 1;
					}
				}
		}
			System.out.println(arr[si]);
			System.out.println(si);
			System.out.println(ei);
		}
			

	}





39. RECURRING SEQUENCE IN A FRACTION

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static String solution(int num, int den) {
	        StringBuilder sb = new StringBuilder();
	        
	        int quo = num / den;
	        int rem = num % den;
	        sb.append(quo);
	        
	        if(rem == 0){
	            return sb.toString();
	        } else {
	            sb.append(".");
	        }
	        
	        HashMap<Integer, Integer> map = new HashMap<>();
	        while(rem != 0){
	            if(map.containsKey(rem) == false){
	                map.put(rem, sb.length());
	            
	                rem *= 10;
	                quo = rem / den;
	                rem = rem % den;
	                sb.append(quo);
	            } else {
	                int pos = map.get(rem);
	                sb.insert(pos, "(");
	                sb.append(")");
	                break;
	            }
	        }
	        
	        return sb.toString();
	    }
	    
	    public static void main(String[] args) {
			Scanner scn = new Scanner(System.in);
			System.out.println("Enter the value");
			int num = scn.nextInt();
			int den = scn.nextInt();
			System.out.println(solution(num , den));
		}

	}


40. RABBITS IN A FOREST

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static void main(String[] args) {
			Scanner scn = new Scanner(System.in);
			System.out.println("Enter the value");
			int n = scn.nextInt();
			int[] arr = new int[n];
			for(int i = 0 ; i < n; i++){
				arr[i] = scn.nextInt();
			}
			System.out.println(solution(arr));
		}

		private static int solution(int[] arr) {
			HashMap<Integer, Integer> map = new HashMap<>();
			for(int i = 0 ;i < arr.length ;i++) {
				map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
			}
			
			
			int ans = 0;
			for(int key: map.keySet()) {
				int gs = key + 1;
				int reportees = map.get(key);
				int ng = (int)Math.ceil(reportees * 1.0 / gs * 1.0);
				ans += ng * gs;
			}
			
			return ans;
		}

	}
	                 


41. POWERFUL NUMBERS

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println("Enter the value");
		int x = scn.nextInt();
		int y = scn.nextInt();
		int bound = scn.nextInt();
		ArrayList<Integer> ret = new ArrayList<>();
		ret = powerfulIntegers(x, y, bound);
		Collections.sort(ret);
		for (int i = 0; i < ret.size(); i++) {
			System.out.print(ret.get(i) + " ");
		}
	}

	public static ArrayList<Integer> powerfulIntegers(int x, int y, int bound) {
		
		HashSet<Integer> set = new HashSet<Integer>();
		for(int i = 1; i < bound; i *= x) {
			for(int j = 1; i + j <= bound; j *= y) {
					set.add(i + j);
					if(y == 1) {
						break;
					}
			}
			if(x == 1) {
				break;
			}
		}
		
		return new ArrayList<>(set);
	}

}                        


                        
42. DOUBLE PAIR ARRAY

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	 public static void main(String[] args) {
			Scanner scn = new Scanner(System.in);
			System.out.println("Enter the value");
			int n = scn.nextInt();
			int[] arr = new int[n];
			for(int i = 0 ; i < n; i++){
				arr[i] = scn.nextInt();
			}
			System.out.println(solution(arr));
		}

		public static boolean solution(int[] arr) {
			if(arr.length == 0) {
				return true;
			}
			
			HashMap<Integer, Integer> freqMap = new HashMap<>();
			for(int ele : arr) {
				freqMap.put(ele, freqMap.getOrDefault(ele, 0) + 1);
			}
			
			Integer[] ar = new Integer[arr.length];
			for(int i = 0; i < arr.length; i++) {
				ar[i] = arr[i];
			}
			
			Arrays.sort(ar,(a,b)->{
				return Math.abs(a) - Math.abs(b);
			});
			
			for(Integer ele : ar) {
				if(freqMap.get(ele) == 0) {
					continue;
				}
				
				if(freqMap.getOrDefault(2*ele, 0) == 0) {
					return false;
				}
				
				freqMap.put(ele, freqMap.get(ele) - 1);
				freqMap.put(2*ele, freqMap.get(2*ele) - 1);
			}
		
       return true;
   }
}


43. QUADRUPLET 2

package automate;
import java.io.*;
import java.util.*;

public class MyClass { 
	
	  public static int fourSumCount(int[] A, int[] B, int[] C, int[] D) {

			HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
            int count = 0;
            
			for(int e1 : A) {
				for(int e2 : B) {
					map.put(e1 + e2, map.getOrDefault(e1+e2, 0) + 1);
				}
			}

			int target = 0;
			for(int e1 : C) {
				for(int e2 : D) {
					count += map.getOrDefault(target - (e1 + e2), 0);
				}
			}
			
			return count;
		}

		public static void main(String[] args) {
			Scanner sc = new Scanner(System.in);
			System.out.println("Enter the value");
			int n = sc.nextInt();
			int[] arr1 = new int[n];
			int[] arr2 = new int[n];
			int[] arr3 = new int[n];
			int[] arr4 = new int[n];
			for (int i = 0; i < n; i++) {
				arr1[i] = sc.nextInt();
			}
			for (int i = 0; i < n; i++) {
				arr2[i] = sc.nextInt();
			}
			for (int i = 0; i < n; i++) {
				arr3[i] = sc.nextInt();
			}
			for (int i = 0; i < n; i++) {
				arr4[i] = sc.nextInt();
			}
			System.out.println(fourSumCount(arr1, arr2, arr3, arr4));
		}

	}

                        


44. MAX FREQUENCY STACK

class FreqStack {

    HashMap<Integer, Stack<Integer>> st;
    HashMap<Integer, Integer> fmap;
    int maxfreq;
    public FreqStack() {
        st = new HashMap<>();
        fmap = new HashMap<>();
        maxfreq = 0;
    }
    
    public void push(int val) {
        int cfreq = fmap.getOrDefault(val, 0);
        cfreq++;
        fmap.put(val, cfreq);
        
        if(st.containsKey(cfreq) == false){
            st.put(cfreq, new Stack<Integer>());
        }
        
        st.get(cfreq).push(val);
        maxfreq = Math.max(maxfreq, cfreq);
    }
    
    public int pop() {
        int ans = st.get(maxfreq).pop();
        
        int cfreq = fmap.get(ans);
        cfreq--;
        fmap.put(ans, cfreq);
        
        if(st.get(maxfreq).size() == 0){
            maxfreq--;
        }
        
        
        return ans;
    }
}

/**
 * Your FreqStack object will be instantiated and called as such:
 * FreqStack obj = new FreqStack();
 * obj.push(val);
 * int param_2 = obj.pop();
 */
                        


45. PAIRS OF NON-COINCIDING POINTS

class Solution {
    static int numOfPairs(int[] X, int[] Y, int N) {
        HashMap<Integer, Integer> xmap = new HashMap<>();
          HashMap<Integer, Integer> ymap = new HashMap<>();
            HashMap<String, Integer> xymap = new HashMap<>();
            
            int sum = 0;
            for(int i=0; i < X.length; i++){
                int x = X[i];
                int y = Y[i];
                
                String xy = "" + x + "*" + y ;
                
                int xfreq = xmap.getOrDefault(x,0);
                int yfreq = ymap.getOrDefault(y,0);
                int xyfreq = xymap.getOrDefault(xy,0);
                
                sum += xfreq + yfreq - 2*xyfreq;
                
                xmap.put(x, xfreq + 1);
                 ymap.put(y, yfreq + 1);
                  xymap.put(xy, xyfreq + 1);
            }
            
            return sum;
    }
};


45. AVOID FLOOD FILL

class Solution {
    public int[] avoidFlood(int[] rains) {
        HashMap<Integer, Integer> lastRain = new HashMap<>();
        TreeSet<Integer> dry = new TreeSet<>();
        
        int n = rains.length;
        int[] ans = new int[n];
        
        for(int i=0; i<n; i++){
            int x = rains[i];
            
            if(x == 0){
                dry.add(i);
                ans[i] = 1;
            } else {
                
                Integer id = lastRain.get(x);
                if(id == null){
                    lastRain.put(x, i);
                }else {
                  Integer drythisday = dry.higher(id);
                    
                    if(drythisday == null){
                        return new int[0];
                    }
                    ans[drythisday] = x;
                    dry.remove(drythisday);
                    
                    lastRain.put(x, i);
                }
                 ans[i] = -1;
            }    
        }
         return ans;
    }
    
   
}


ENCODE AND DECODE TINY URL

public class Codec {

    HashMap<String, String> map = new HashMap<>();
    
    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        StringBuilder sb = new StringBuilder();
        sb.append((char)(Math.floor(Math.random()*100)));
        
        while(map.containsKey(sb.toString())){
             sb.append((char)Math.floor(Math.random()*100));
        }
        map.put(sb.toString(), longUrl);
        return sb.toString();
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        return map.get(shortUrl);
    }
}

46. SKYLINE

class Solution {
    public class Pair implements Comparable<Pair> {
        int x;
        int ht;
        
        public Pair(int x, int ht ){
            this.x = x;
            this.ht = ht;
        }
        
        @Override
        public int compareTo(Pair o){
            if(this.x != o.x) {
              return  this.x - o.x;
            } else {
              return  this.ht - o.ht;
            }
        }
    }
    public List<List<Integer>> getSkyline(int[][] buildings) {
        List<Pair> list = new ArrayList<>();
        
        for(int i=0; i< buildings.length; i++){
            int sp = buildings[i][0];
             int ep = buildings[i][1];
             int ht = buildings[i][2];
            list.add(new Pair(sp, -ht));
             list.add(new Pair(ep, ht));
        }
        
        Collections.sort(list);
        
        List<List<Integer>> ans = new ArrayList<>();
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        
        int cht = 0;
        pq.add(0);
        
        
        for(int i=0; i < list.size(); i++){
            int x = list.get(i).x;
            int ht = list.get(i).ht;
            
            if(ht < 0){
                pq.add(-ht);
            }else {
                pq.remove(ht);
            }
            
            if(cht != pq.peek()){
                List<Integer> temp = new ArrayList<>();
                temp.add(x);
                temp.add(pq.peek());
                
                ans.add(temp);
                cht = pq.peek();
            }
        }
        
        return ans;
    }
}



47. SUBDOMAIN VISIT COUNT
Input: cpdomains = ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
Output: ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]

class Solution {
    public List<String> subdomainVisits(String[] cpdomains) {
        HashMap<String, Integer> map = new HashMap<>();
        
		for (String str : cpdomains) {
            String tmp[] = str.split(" ");
            int visitCount = Integer.parseInt(tmp[0]);
            
            String words[] = tmp[1].split("\\.");
            
            
			StringBuilder sb = new StringBuilder();
			
            for(int idx = words.length-1; idx >= 0; idx--){
                if(idx == words.length-1){
                    sb.append(words[idx]);
                }else {
                    sb.insert(0,".");
                    sb.insert(0,words[idx]);
                }
                
                String subdomain = sb.toString();
                
                if(map.containsKey(subdomain) == true){
                    int csf = map.get(subdomain);
                    map.put(subdomain, csf+visitCount);
                } else {
                    map.put(subdomain, visitCount);
                }
            }
        }
            
            ArrayList<String> res = new ArrayList<>();
            
            for(String subdomains: map.keySet()){
                StringBuilder sb = new StringBuilder();
                sb.append(map.get(subdomains));
                sb.append(" ");
                sb.append(subdomains);
                res.add(sb.toString());
            }
		
        
        return res;
    }     
    
}


                        


                        

48. INSERT DELETE GETRANDOM(1)

class RandomizedSet {

    HashMap<Integer, Integer> map;
    List<Integer> list;
    Random r;
    public RandomizedSet() {
       map = new HashMap<>();
       list = new ArrayList<>();
        r = new Random();
    }
    
    public boolean insert(int val) {
        if(map.containsKey(val)){
            return false;
        }
        
        map.put(val, list.size());
        list.add(val);
        return true;
    }
    
    public boolean remove(int val) {
        if(!map.containsKey(val)){
            return false;
        }
        
        int remidx = map.get(val);
        map.remove(val);
        
        if(remidx == list.size() - 1){
            list.remove(list.size() - 1);
            return true;
        }
        
        list.set(remidx, list.get(list.size() - 1));
        list.remove(list.size() - 1);
        
        map.put(list.get(remidx), remidx);
        return true;
    }
    
    public int getRandom() {
        int randomidx = r.nextInt(list.size());
        return list.get(randomidx);
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
                        

15. BRICK WALL

class Solution {
    public int leastBricks(List<List<Integer>> wall) {
         HashMap<Integer, Integer> map = new HashMap<>();
        
        int max = 0;
        for(List<Integer> list : wall){
            int ps = 0;
            for(int i = 0 ; i < list.size() - 1; i++){
            int val = list.get(i);
            ps += val;
            map.put(ps, map.getOrDefault(ps, 0) + 1);
            max = Math.max(max, map.get(ps));
          
        }
        }
        return wall.size() - max;
    }
}


16. PANCAKE SORTING

class Solution {
    public void reverse(int[] arr, int l, int r){
        while(l < r){
        int temp = arr[l];
        arr[l] = arr[r];
        arr[r] = temp;
            l++;
            r--;
        }
    }
    public List<Integer> pancakeSort(int[] arr) {
        List<Integer> ans = new ArrayList<Integer>();
        
        int n = arr.length;
        
        for(int i = n - 1; i >= 0; i--){
            int maxIdx = i;
            for(int j = i - 1; j >= 0; j--) maxIdx = (arr[maxIdx] < arr[j] ? j : maxIdx);
            
            if(maxIdx != i){
                reverse(arr, 0, maxIdx);
                ans.add(maxIdx + 1);
                
                reverse(arr, 0, i);
                ans.add(i + 1);
            }
        }
        
        return ans;
    }
}
                       


                        
14. X OF A KIND IN A DEC CARD

class Solution {
    public boolean hasGroupsSizeX(int[] deck) {
        HashMap<Integer, Integer> map = new HashMap<>();
        
        for(int i = 0; i < deck.length; i++){
            map.put(deck[i], map.getOrDefault(deck[i], 0) + 1);
        }
        
        int ans = 0;
        for(int key : map.keySet()){
            ans = gcd(ans, map.get(key));
        }
        
        if(ans >= 2){
            return true;
        } else {
            return false;
        }
    }
    
    public int gcd(int a, int b){
	 if(b == 0) {
   		return a;
        }
       return gcd(b, a%b);
    }
}




                        


                        







