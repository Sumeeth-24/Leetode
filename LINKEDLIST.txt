NO OF INCREASING PATH IN A GRID

class Solution {
    private int[][] directions = {{1,0}, {0,1}, {-1,0}, {0,-1}};
    private int mod = 1000000007;
    public int countPaths(int[][] matrix) {
        if(matrix == null){
            return 0;
        }
           
        int m = matrix.length;
        if(m == 0){
            return 0;
        }
        int n = matrix[0].length;
        if(n == 0){
            return 0;
        }
           
        long[][] cache = new long[m][n];
        long countOfLongestIncreasingPath = 0;
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
               // longestIncreasingPath = Math.max(longestIncreasingPath, dfs(matrix, i, j, cache)); LC -> 329 exact code
                countOfLongestIncreasingPath = (countOfLongestIncreasingPath + dfs(matrix, i, j, cache)) % mod;   
            }
        }
        return (int)countOfLongestIncreasingPath;
    }
    
    public long dfs(int[][] matrix, int i, int j, long[][] cache) {
        if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[i].length) {
            return 0;
        }
        
        if (cache[i][j] > 0) {
            return cache[i][j];
        }
        
        long currentLen = 1;
        
        for(int[] direction : directions){
            int neighbX = i + direction[0];
            int neighbY = j + direction[1];
            
            if(neighbX < 0 || neighbY < 0 || neighbX >= matrix.length || neighbY >= matrix[i].length){
                continue;
            }
            
            if(matrix[i][j] >= matrix[neighbX][neighbY]){
                continue;
            }
        //  currentLen = Math.max(currentLen, 1 + dfs(matrix, neighbX, neighbY, cache)); 
            currentLen = (currentLen  + dfs(matrix, neighbX, neighbY, cache))%mod; 
        }
        
        cache[i][j] = currentLen;
        return currentLen;
    }
}


SHIFT 2D GRID

class Solution {
    public List<List<Integer>> shiftGrid(int[][] grid, int k) {
        int row = grid.length;
        int col = grid[0].length;
        int size = row*col;
         k = k % size;
        
       List<List<Integer>> res = new ArrayList<>();
        
        
        for(int i=0; i<row; i++){
            List<Integer> temp = new ArrayList<>();
            for(int j=0; j<col; j++){
                int newIndex = ((gridIndexToOneDimIndex(i, j, col, k, size)));
               temp.add(grid[newIndex/col][newIndex%col]);
            }
            res.add(temp);
        }
        
        return res;
        
        
    }
    
    public int gridIndexToOneDimIndex(int i, int j, int col, int k, int ele){
        return (i*col+j + ele - k) % ele;
    }
    
     
}


REMOVE ZERO SUM CONSECUTIVE NODE FROM LINKEDLIST

class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
         HashMap<Integer, ListNode> sumNodeMap = new HashMap<>();
        
        ListNode dummyPreHead = new ListNode(0);
        dummyPreHead.next = head;
        
        sumNodeMap.put(0, dummyPreHead);                                    //Init the stack with prehead.
        
        ListNode currNode = head;

        int sum = 0;
        
        while(currNode!=null){
            
            sum += currNode.val;
            
            if(sumNodeMap.containsKey(sum)){
                
                ListNode oldNodeWithSameSum = sumNodeMap.get(sum);          //Old node with same sum
                
                ListNode toBeRemovedNode = oldNodeWithSameSum.next;         //Remove zero-sum in-between nodes from sumNodeMap
                int toBeRemovedSum = sum;
                while(toBeRemovedNode != currNode){
                    toBeRemovedSum = toBeRemovedSum + toBeRemovedNode.val;
                    sumNodeMap.remove(toBeRemovedSum);
                    toBeRemovedNode = toBeRemovedNode.next;
                }
                oldNodeWithSameSum.next = currNode.next;                    //Point old node to current next node
            }
            else{
                sumNodeMap.put(sum, currNode);
            }
            
            currNode = currNode.next;
        }
        
        return dummyPreHead.next;
    }
}

LINKEDLIST IN BINARY TREE


class Solution {

    public boolean isSubPath(ListNode head, TreeNode root) {
        return dfs(head, root);
    }
    
    public boolean dfs(ListNode head, TreeNode root){
        if(root == null) return false;
        
        if(CheckSubPath(head, root)) return true;
        
        
         return dfs(head, root.left) || CheckSubPath(head, root.right);
        
    }
    
    public boolean CheckSubPath(ListNode head, TreeNode root){
        if(head == null) return true;
        if(root == null || root.val != head.val ) return false;
              
            return CheckSubPath(head.next, root.left) || CheckSubPath(head.next, root.right);
        
    }
}

REVERSE EVEN LENGTH GROUPS

class Solution {
    public ListNode reverseEvenLengthGroups(ListNode head) {
         // Check corner case with null.
        if (head == null) {
            return null;
        }
        
        // Count number of nodes in total.
        ListNode ptr = head;
        int total = 0;
        while (ptr != null) {
            total++;
            ptr = ptr.next;
        }
        
        int numOfNodes = 1;
        ListNode cur = head, pre = null;
        while (cur != null) {
            numOfNodes = Math.min(numOfNodes, total);
            total -= numOfNodes;
            if (numOfNodes % 2 == 1) {
                // Odd: Move pointers.
                int cnt = 0;
                while (cur != null && cnt++ < numOfNodes) {
                    pre = cur;
                    cur = cur.next;
                }
            } else {
                // Even: Reverse List
                ListNode[] res = reverseList(cur, numOfNodes);
                pre.next = res[0];
                pre = cur;
                cur = res[1];
            }
            numOfNodes++;
        }
        return head;
    }
    
    // Reverse from node with n nodes.
    private ListNode[] reverseList(ListNode node, int n) {
        ListNode pre = null, cur = node, post = null;
        while (n-- > 0) {
            post = cur.next;
            cur.next = pre;
            pre = cur;
            cur = post;
        }
        node.next = cur;
        return new ListNode[]{pre, post};
    }
    
}


COPY LIST WITH RANDOM POINTER

class Solution {
    public static void copyList(Node head){
        Node curr = head;
        while(curr != null){
            Node forw = curr.next;
            
            Node node = new Node(curr.val);
            curr.next = node;
            node.next = forw;
            
            curr = forw;
        }
    }
    
    public static void copyRandompointer(Node head){
        Node curr = head;
        while(curr != null){
            Node random = curr.random;
            if(random != null)
                curr.next.random = random.next;
            
            curr = curr.next.next;
        }
    }
    
    public static Node extractDeepCopy(Node head){
        Node dummy = new Node(-1);
        Node prev = dummy, curr = head;
        
        while(curr != null){
            prev.next = curr.next;
            curr.next = curr.next.next;
            
            prev = prev.next;
            curr = curr.next;
        }
        
        return dummy.next;
    }
    public static Node copyRandomList(Node head) {
        copyList(head);
        copyRandompointer(head);
        return extractDeepCopy(head);
        
    }
}

MERGE TWO SORTED LIST

class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
		if(l2 == null) return l1;
		
        ListNode dummynode = new ListNode(0);
        ListNode prev = dummynode;
        ListNode c1 = l1, c2 = l2;
        
        while(c1 != null && c2 != null){
            if(c1.val < c2.val){
                prev.next = c1;
                c1 = c1.next;
            } else {
                prev.next = c2;
                c2 = c2.next;
            }
            prev = prev.next;
        }
        prev.next = c1 != null ? c1 : c2;
        return dummynode.next;
}
}


MERGE K SORTED LISTS

class Solution {
     public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
		if(l2 == null) return l1;
		
        ListNode dummynode = new ListNode(0);
        ListNode prev = dummynode;
        ListNode c1 = l1, c2 = l2;
        
        while(c1 != null && c2 != null){
            if(c1.val < c2.val){
                prev.next = c1;
                c1 = c1.next;
            } else {
                prev.next = c2;
                c2 = c2.next;
            }
            prev = prev.next;
        }
        prev.next = c1 != null ? c1 : c2;
        return dummynode.next;
}
    
    public  ListNode mergeKlists(ListNode[] lists, int si, int ei){
        if(si > ei) return null;
        if(si == ei) return lists[si];
        int mid = (si + ei)/2;
        
        ListNode l1 = mergeKlists(lists, si, mid);
        ListNode l2 = mergeKlists(lists, mid+1, ei);
        
        return mergeTwoLists(l1, l2);
    }
    
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;
        return mergeKlists(lists, 0, lists.length-1);
    }
}
nklogk

PARTITION LISTS
Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode small = new ListNode(0);
        ListNode higher = new ListNode(0);
        
        ListNode smallHead = small, higherHead = higher;
        
        while(head != null){
            if(head.val < x){
                smallHead.next = head;
                smallHead = smallHead.next;
            }
            else {
                higherHead.next = head;
                higherHead = higherHead.next; 
            }
            head = head.next;
        }
        
        higherHead.next = null;
        smallHead.next = higher.next;
        
        return small.next;
        
    }
}

class Solution {
    public static Node partition(Node head, int x) {
        Node smallerHead = null, smallerLast = null;
    Node greaterLast = null, greaterHead = null;
    Node equalHead = null, equalLast =null;
 
    // Now iterate original list and connect nodes
    // of appropriate linked lists.
    while (head != null)
    {
        // If current node is equal to x, append it
        // to the list of x values
        if (head.data == x)
        {
            if (equalHead == null)
                equalHead = equalLast = head;
            else
            {
                equalLast.next = head;
                equalLast = equalLast.next;
            }
        }
 
        // If current node is less than X, append
        // it to the list of smaller values
        else if (head.data < x)
        {
            if (smallerHead == null)
                smallerLast = smallerHead = head;
            else
            {
                smallerLast.next = head;
                smallerLast = head;
            }
        }
        else // Append to the list of greater values
        {
            if (greaterHead == null)
                greaterLast = greaterHead = head;
            else
            {
                greaterLast.next = head;
                greaterLast = head;
            }
        }
        head = head.next;
    }
 
    // Fix end of greater linked list to NULL if this
    // list has some nodes
    if (greaterLast != null)
        greaterLast.next = null;
 
    // Connect three lists
 
    // If smaller list is empty
    if (smallerHead == null)
    {
        if (equalHead == null)
            return greaterHead;
        equalLast.next = greaterHead;
        return equalHead;
    }
 
    // If smaller list is not empty
    // and equal list is empty
    if (equalHead == null)
    {
        smallerLast.next = greaterHead;
        return smallerHead;
    }
 
    // If both smaller and equal list
    // are non-empty
    smallerLast.next = equalHead;
    equalLast.next = greaterHead;
    return smallerHead;
    }
}

REVERSE LINKEDLIST II
Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if(head==null || head.next==null){
            return head;
        }
        
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode it = dummy;
        ListNode prevIt = null;
        for(int i=0; i< left; i++){
            prevIt = it;
            it = it.next;
        }
        everse
        ListNode itR = it;
        ListNode prevR = prevIt;
        
        //reversing a linkedlist list
        for(int i=left; i<=right; i++){
            ListNode forward = itR.next;
            itR.next = prevR;
            prevR = itR;
            itR = forward;
        }
        
        prevIt.next = prevR;
        it.next = itR;
        
        return dummy.next;
    }
}

CONVERT LIST TO BST

class Solution {
    public ListNode mid(ListNode head){
        ListNode fast = head;
        ListNode slow = head;
        ListNode prev = head;
        while(fast != null && fast.next != null){
           prev=slow;
            slow=slow.next;
            fast=fast.next.next;
        }
        if(prev != null){
            prev.next = null;
        }
        return slow;
    }
    
    public TreeNode sortedListToBST(ListNode head) {
        if(head == null) return null;
        
        ListNode mid = mid(head);
        TreeNode root = new TreeNode(mid.val);
        
        if(head==mid) return root;
        
        root.left = sortedListToBST(head);
        root.right = sortedListToBST(mid.next);
        return root;
    }
}

CONVERT BINARY NUMBER IN LIST TO INTEGER
1*2*2 + 0*2 + 1*1 = 5
class Solution {
    public int getDecimalValue(ListNode head) {
        int num = 0;                // Initialise num to 0
	while(head!=null) {         // Iteratore over the linked list until head is null    
		num = num*2;              // Left shift num by 1 position to make way for next bit
		num += head.val;        // Add next bit to num at least significant position
		head = head.next;       // Update head
	}
	return num;
    }
}


REMOVE DUPLICATE FROM SORTED LIST II

class Solution {
    public ListNode deleteDuplicates(ListNode head) {
       new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        while(head != null){
            if(head.next != null && head.val == head.next.val){
                //skip nodes equal to head val
                while(head.next != null && head.val == head.next.val){
                    head = head.next;
                }
                prev.next = head.next;
            }
            else{
                prev = prev.next;
            }
            head = head.next;
        }
        return dummy.next;
    }
}

REMOVE LINKEDLIST ELEMENT EQUAL TO VALUE

class Solution {
    public ListNode removeElements(ListNode head, int val) {
         ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode cur = dummy;
    
    while(cur.next != null) {
        if(cur.next.val == val) {
            cur.next = cur.next.next;
        }
        else
            cur = cur.next;
    }
    return dummy.next;
    }
}

ADD TWO NUMBERS IN LINKEDLIST

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    int carry = 0;
    ListNode dummy = new ListNode();
    ListNode temp = dummy;
   
    while (l1 != null || l2 != null || carry != 0) {
        int sum = 0;
        if (l1 != null) {
            sum += l1.val;
            l1 = l1.next;
        }
        if (l2 != null) {
            sum += l2.val;
            l2 = l2.next;
        }
        sum += carry;
        carry = sum/10;
        ListNode node = new ListNode(sum%10);
        temp.next = node;
        
        temp = temp.next;
    }
    return dummy.next;
    }
}


ADD TWO NUMBERS II IN LINKEDLIST

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<Integer> s1 = new Stack<Integer>();
        Stack<Integer> s2 = new Stack<Integer>();
        
        while(l1 != null) {
            s1.push(l1.val);
            l1 = l1.next;
        };
        while(l2 != null) {
            s2.push(l2.val);
            l2 = l2.next;
        }
        
        int carry = 0;
        ListNode result = null;
        while (!s1.empty() || !s2.empty()) {
            int a = 0, b = 0;
            if (!s1.empty()) a = s1.pop();
            if (!s2.empty()) b = s2.pop();
            int total = a+b+carry;
           
            ListNode temp = new ListNode(total % 10);
            carry = total/10;
            
            if(result == null){
                result = temp;
            } else {
                temp.next = result;
                result = temp;
            }
           
        }
        if(carry != 0){
            ListNode temp = new ListNode(carry); 
            temp.next = result;
                result = temp;
        }
        return result;
    }
}

SUM OF TWO INTEGERS

class Solution {
    public int getSum(int a, int b) {
        if (a == 0) return b;
	if (b == 0) return a;

	while (b != 0) {
		int carry = a & b;
		a = a ^ b;
		b = carry << 1;
	}
	
	return a;
    }
}


FIND MIN AND MAX NUMBER OF NODES BETWEEN CRITICAL POINT

Input: head = [5,3,1,2,5,1,2]
Output: [1,3]
Explanation: There are three critical points:
- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.
- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.
- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.
The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.
The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.

class Solution {
    public int[] nodesBetweenCriticalPoints(ListNode head) {
        if(head == null || head.next == null || head.next.next == null || head.next.next.next == null){
            return new int[]{-1, -1};
        }
        List<Integer> indices = new ArrayList<>();
        ListNode itr = head.next;
        ListNode prev = head;
        ListNode nxt = itr.next;
        int i=1;
        while(itr.next!=null){
            if((prev.val > itr.val && itr.val < nxt.val) || (prev.val < itr.val && itr.val > nxt.val)){
                indices.add(i);
            }
            prev = itr;
            itr = nxt;
            nxt = nxt.next;
            i++;
        }
        for(int ind : indices){
            System.out.print(ind + "  ");
        }
        Collections.sort(indices);
        
        int[] ans = new int[2];
        if(indices.size()<=1){
            return new int[]{-1,-1};
        }
        int min = Integer.MAX_VALUE;
        for(int ind=0;ind<indices.size()-1;ind++){
            min = Math.min(min, indices.get(ind+1) - indices.get(ind));
        }
        ans[0] = min;
        ans[1] = indices.get(indices.size()-1)-indices.get(0);
        return ans;
        
    }
}


 REORDER LIST



class Solution {
    // 1-> 2 -> 3 -> 4 -> 5-> 6-> 7 -> 8
    //op 1-> 8 -> 2 -> 7 -> 3-> 6-> 4 -> 5
    
    // middle 1-> 2 -> 3 -> 4 -> null
   //  5-> 6 -> 7 -> 8 -> null  then reverse this  8-> 7-> 6 -> 5
    
    public void reorderList(ListNode head) {
        if (head == null || head.next == null)
          return;
      
      // step 1. cut the list to two halves
      // prev will be the tail of 1st half
      // slow will be the head of 2nd half
      ListNode prev = null, slow = head, fast = head, l1 = head;
      
      while (fast != null && fast.next != null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
      }
      
      prev.next = null;
      
      // step 2. reverse the 2nd half
      ListNode l2 = reverse(slow);
      
      // step 3. merge the two halves
      merge(l1, l2);
    }
    
    ListNode reverse(ListNode head) {
      ListNode prev = null, curr = head, next = null;
      
      while (curr != null) {
        next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
      }
      
      return prev;
    }
 // middle 1-> 2 -> 3 -> 4 -> null
     8-> 7-> 6 -> 5  
 //op 1-> 8 -> 2 -> 7 -> 3-> 6-> 4 -> 5 
    void merge(ListNode l1, ListNode l2) {
      while (l1 != null) {
        ListNode l1_next = l1.next, l2_next = l2.next;
        l1.next = l2;
        
        if (l1_next == null)
          break;
            
        l2.next = l1_next;
          
        l1 = l1_next;
        l2 = l2_next;
      }
    }
}



SPLIT LINKEDLIST INTO PARTS
Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3
Output: [[1,2,3,4],[5,6,7],[8,9,10]]

class Solution {
    // total = 15, k= 4,  hence 15/4 = 3 i.e minimum 3 in each (3,3,3,3) and 15%4 = 3 we need to fill in 3 therefore 4,4,4,3
    public ListNode[] splitListToParts(ListNode head, int k) {
        ListNode[] ans = new ListNode[k];
        
        int totalLen = 0;
        ListNode itr = head;
        
        while(itr != null){
            totalLen++;
            itr = itr.next;
        }
        
        int len = totalLen/k;
        int distribute = totalLen%k;
        
        ListNode node = head;
        ListNode prev = null;
        
        int i = 0;
        
        while(node != null && i < k) {
            ans[i] = node;
            
            for(int j=0; j<len+(distribute > 0 ? 1 : 0); j++){
                
                prev = node;
                node = node.next;
            }
            
            prev.next = null;
            i++;
            distribute--;
        }
        
        return ans;
    }
}


                                                 LINKEDLIST
1. ADD LAST IN LINKEDLIST
package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		printList(node.next);
	}
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
               Node firstNode = node;

               while(node.next != null) {
                 node = node.next;
}
                node.next = getNewNode(i);
                 return firstNode;
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	  
	  a.printList(root);
	  
  }
}


2. ADD FIRST IN LINKEDLIST
package automate;


package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public Node insertFront(int i, Node node) {
		
		Node a = getNewNode(i);
		a.next = node;
		
		return a;
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		printList(node.next);
	}
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	  root = a.insertFront(5, root);
	  
	  a.printList(root);
	  
  }
}






3. INSERT ELEMENT AT GIVEN POSITION

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}


class Linked {
	
	
	public Node insertAtPosition(int i, int position,  Node node) {
		
		if(position < 1) {
			System.out.println("Position can't be less than 1");
			return node;
		}
		
		if(node == null && position > 1) {
			System.out.println("Position is greater than element exists");
			return node;
		}
		
		if(node == null && position == 1) {
			return getNewNode(i);
		}
		
		if(position == 1) {
			Node newNode = getNewNode(i);
			newNode.next = node;
			return newNode;
		}
		
		node.next = insertAtPosition(i, position - 1, node.next);
		return node;
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	  root = a.insertAtPosition(5, 7, root);
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	  root = a.insertAtPosition(5, 2, root);
	  
	  
	  a.printList(root);
	  System.out.println();
	  
  }
}





4. DELETE LAST NODE OF LIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public Node deleteendnode( Node node) {
		
		
		if(node == null || node.next == null ) {
			return null;
		}
		
		Node tmp = node;
		
		while(tmp.next.next != null) {
			tmp = tmp.next;
		}
		
		tmp.next = null;
		return node;
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	 root = a.deleteendnode(root);
	  
	  
	  a.printList(root);
	  System.out.println();
	  
  }
}






5. DELETE FRONT NODE OF LIST
package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public Node deletefrontnode( Node node) {
		
		
		if(node == null) {
			return node;
		}
		
		return node.next;
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	 root = a.deletefrontnode(root);
	  
	  
	  a.printList(root);
	  System.out.println();
	  
  }
}




 	                   
6. DELETE ELEMENT AT GIVEN POSITION

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public Node deleteAtPosition(int position, Node node) {
		
		
		if(position < 0) {
			System.out.println("Not a valid position");
			return node;
		}
		
		if(node == null && position > 1) {
			System.out.println("Not valid Position");
			return node;
		}
		
		if(position == 1) {
			return node.next;
		}
		
		Node firstNode = node;
                Node prev = null;

                while(node.next != null && position > 1) {
                 prev = node;
                 node = node.next;
                 position--;
          }

                if(position != 1){System.out.println("Position greater than number of elements exists"); return firstNode;}
                 prev.next = node.next;
                 return firstNode;
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	 root = a.deleteAtPosition(2, root);
	  
	  
	  a.printList(root);
	  System.out.println();
	  
  }
}





7. GET SIZE OF LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public int getsizeofList( Node node) {
		
		
		if(node == null) {
			return 0;
		}
		
		return getsizeofList(node.next) + 1;
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	 int size = a.getsizeofList(root);
	  System.out.println("Size: " + size);
	  
	  a.printList(root);
	  System.out.println();
	  
  }
}





8. IF NODE EXISTS

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public boolean ifNodeExists(int val, Node node) {
		
		
		if(node == null) {
			return false;
		}
		
		while(node != null) {
			if(node.data == val) {
				return true;
			}
			
			node = node.next;
		}
		
		return false;
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	 boolean ifExist = a.ifNodeExists(123, root);
	  System.out.println(ifExist);
	  
	  a.printList(root);
	  System.out.println();
	  
  }
}



9. GET MIDDLE NODE OF LINKEDLIST 

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public Node middleNode(Node node) {
		
		
		if(node == null) {
			return null;
		}
		
	                    Node slow, fast;
			    slow = fast = node;
			    
			    while(fast.next != null && fast.next.next != null) {
			      slow = slow.next;
			      fast = fast.next.next;
			    }
		
		return slow;
		
		
	}

 public ListNode deleteMiddle(ListNode head) {
        if(head == null || head.next == null) return null;
        
        ListNode slow, fast, prev;
        slow = fast = prev = head;
        
        while(fast != null && fast.next != null){
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
       
        
        prev.next = slow.next;
        return head;
        
    }
}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node root = null;
	  Linked a = new Linked();
	  
	
	  
	  root = a.insert(12, root);
	  root = a.insert(99, root);
	  root = a.insert(37, root);
	  
	  
	  a.printList(root);
	  System.out.println();
	  
	  Node middle = a.middleNode(root);
	  System.out.println(middle.data);
	  
  }
}




10. REVERSE LINKEDLIST RECURSIVELY 

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public Node reverse(Node node) {
		
		
		if(node == null || node.next == null) {
			return node;
		}
		
	  Node temp = reverse(node.next);
	  node.next.next = node;
	  node.next = null;
	  
	  return temp;
	  
	 
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  Linked a = new Linked();
	  
	  Node root1 = null;
	  
	  root1 = a.insert(37, root1);
	  root1 = a.insert(8, root1);
	  root1 = a.insert(13, root1);
	  root1 = a.insert(18, root1);
	  
	  
	  a.printList(root1);
	  System.out.println();
	  
	 
	  
	  Node reverseList = a.reverse(root1);
      a.printList(reverseList);
	  System.out.println();
  }
}



11. ROTATE LINKEDLIST CLOCKWISE BY K

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public int getSizeOfList(Node node) {
		 if(root == null){
            return 0;
        }
        
        int count = 0;
        
        while(root != null){
            root = root.next;
            count++;
        }
        
        return count;
	}
	
	
	public Node rotateclockwise(int k, Node node) {
		
		
		if(node == null || k < 0) {
			return node;
		}
		
	  int sizeoflinkedlist = getSizeOfList(node);
	  k = k % sizeoflinkedlist;
	  if(k == 0) {
		  return node;
	  }
	  
	  Node tmp = node;
	  int i = 1;
	  
	  while(i < sizeoflinkedlist - k) {
		  tmp = tmp.next;
		  i++;
	  }
	  
	  Node temp = tmp.next;
	  Node head = temp;
	  tmp.next = null;
	  
	  i = 1;
	  while(temp.next != null) {
		  temp = temp.next;
	  }
	  
	  temp.next = node;
	  return head;
	  
	 
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  Linked a = new Linked();
	  
	  Node root1 = null;
	  
	  root1 = a.insert(12, root1);
	  root1 = a.insert(99, root1);
	  root1 = a.insert(37, root1);
	  root1 = a.insert(8, root1);
	  root1 = a.insert(18, root1);
	  
	  
	  a.printList(root1);
	  System.out.println();
	  
	 
	  
      root1 = a.rotateclockwise(2, root1);
      a.printList(root1);
	  System.out.println();
  }
}



12. ROTATE ANTICLOCKWISE BY K

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public int getSizeOfList(Node node) {
		if(node == null) {
			return 0;
		}
		
		return getSizeOfList(node.next)  + 1;
	}
	
	
	public Node rotateAnticlockwise(int k, Node node) {
		
		
		if(node == null || k < 0) {
			return node;
		}
		
	  int sizeoflinkedlist = getSizeOfList(node);
	  k = k % sizeoflinkedlist;
	  if(k == 0) {
		  return node;
	  }
	  
	  Node tmp = node;
	  int i = 1;
	  
	  while(i < k) {
		  tmp = tmp.next;
		  i++;
	  }
	  
	  Node temp = tmp.next;
	  Node head = temp;
	  tmp.next = null;
	  
	  i = 1;
	  while(temp.next != null) {
		  temp = temp.next;
	  }
	  
	  temp.next = node;
	  return head;
	  
	 
		
		
	}
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  Linked a = new Linked();
	  
	  Node root1 = null;
	  
	  root1 = a.insert(12, root1);
	  root1 = a.insert(99, root1);
	  root1 = a.insert(37, root1);
	  root1 = a.insert(8, root1);
	  root1 = a.insert(18, root1);
	  
	  
	  a.printList(root1);
	  System.out.println();
	  
	 
	  
      root1 = a.rotateAnticlockwise(2, root1);
      a.printList(root1);
	  System.out.println();
  }
}



13. SORT THE LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	   
	  public Node mergeSort(Node node) {
	    if(node == null || node.next == null) {
	      return node;
	    }
	    
	    Node middle = middleNode(node);
	    Node secondHalf = middle.next;
	    middle.next = null;
	    
	    return merge(mergeSort(node), mergeSort(secondHalf));
	  }
	  
	  /*
	   * It'll find the middle node of the linked list
	   */
	  public Node middleNode(Node node) {
	    if(node == null) {
	      return null;
	    }
	    
	    Node a = node;
	    Node b = node.next;
	    
	    while(b != null && b.next != null) {
	      a = a.next;
	      b = b.next.next;
	    }
	    
	    return a;
	  }
	  
	  /*
	   * It'll merge both linked list
	   */
	  public Node merge(Node a, Node b) {
	    Node temp = new Node();
	    Node finalList = temp;
	    
	    while(a != null && b != null) {
	      if(a.data < b.data) {
	        temp.next = a;
	        a = a.next;
	      } else if (a.data > b.data){
	        temp.next = b;
	        b = b.next;
	      } else {
	    	  temp.next = a;
	    	  a = a.next;
	    	  b = b.next;  // common element
	      }
	      temp = temp.next;
	    }
	    temp.next = (a == null) ? b : a;
	    return finalList.next;
	  }
	  
	  
	
          public Node mergeSort(Node a, Node b) {
              return merge(mergeSort(a), mergeSort(b);
          }

	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  Linked a = new Linked();
	  
	  Node root1 = null;
	  
	  root1 = a.insert(12, root1);
	  root1 = a.insert(99, root1);
	  root1 = a.insert(37, root1);
	  root1 = a.insert(8, root1);
	  root1 = a.insert(18, root1);
	  
	  Node root2 = null;
	  
	  root2 = a.insert(45, root1);
	  root2 = a.insert(17, root1);
	  
	  a.printList(root1);
	  System.out.println();

          a.printList(root2);
	  System.out.println();
	  
	 
	  Node sorted = a.mergeSort(root1, root2);
          a.printList(sorted);
	  System.out.println();
  }
}



14. UNION OF TWO LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	public Node getUnionOfTwoLinkedList(Node node1, Node node2) {
	    if(node1 == null && node2 == null) {
	      return null;
	    }
	    
	    if(node1 == null || node2 == null) {
	      return node1 != null ? node1 : node2; 
	    }
	    
	    Set<Integer> s = new HashSet<>();
	    
	    Node temp = new Node();
	    Node result = temp;
	    
	    while(node1 != null) {
	      if(!s.contains(node1.data)) {
	        temp.next = node1;
	        temp = temp.next;
	        s.add(node1.data);
	      }
	      node1 = node1.next;
	    }
	    
	    while(node2 != null) {
	      if(!s.contains(node2.data)) {
	        temp.next = node2;
	        temp = temp.next;
	        s.add(node2.data);
	      }
	      node2 = node2.next;
	    }
	    temp.next = null;
	    
	    return result.next;
	  }
	  
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  Linked a = new Linked();
	  
	  Node head1 = null;
	    
	    head1 = a.insert(22, head1);
	    head1 = a.insert(3, head1);
	    head1 = a.insert(10, head1);
	    head1 = a.insert(3, head1);
	    head1 = a.insert(13, head1);
	    
	    Node head2 = null;
	    
	    head2 = a.insert(2, head2);
	    head2 = a.insert(13, head2);
	    head2 = a.insert(10, head2);
	    head2 = a.insert(27, head2);
	    head2 = a.insert(36, head2);
	    
	    Node unionOfLinkedList = a.getUnionOfTwoLinkedList(head1, head2);
	    a.printList(unionOfLinkedList);
  }
}







15. INTERSECTION OF TWO LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	 public Node getIntersectionOfTwoLinkedList(Node node1, Node node2) {
		    if(node1 == null || node2 == null) {
		      return null;
		    }
		    
		    Node a = node1;
                    Node b = node2;

                    while(a != b){
                     a = a == null ? node2 : a.next;
                     b = b == null ? node1 : b.next;
                 }
		    
		    return a;
		  }
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  Linked a = new Linked();
	  
	  Node head1 = null;
	    
	    head1 = a.insert(22, head1);
	    head1 = a.insert(3, head1);
	    head1 = a.insert(10, head1);
	    head1 = a.insert(3, head1);
	    head1 = a.insert(13, head1);
	    
	    Node head2 = null;
	    
	    head2 = a.insert(2, head2);
	    head2 = a.insert(13, head2);
	    head2 = a.insert(10, head2);
	    head2 = a.insert(27, head2);
	    head2 = a.insert(36, head2);
	    
	    Node intersectionOfLinkedList = a.getIntersectionOfTwoLinkedList(head1, head2);
	    a.printList(intersectionOfLinkedList);
  }
}







	  
	  
	
	
	


17. REMOVE DUPLICATE FROM UNSORTED LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	
	public Node removeDuplicateUsingHashMap(Node node) {
	    if(node == null) {
	      return null;
	    }
	    
	    HashMap<Integer, Integer> s = new HashMap<>();
	     
	    Node head = node;
	    Node prev = null;
	    while(node != null) {
	      if(!s.containsKey(node.data)) {
	        s.put(node.data, 1);
	        prev = node;
	        node = node.next;
	      } else {
	        prev.next = node.next;
	        node = node.next;
	      }
	    }
	    	    return head;
	  }
	  
	  
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node head = null;
	    Linked a = new Linked();

	    head = a.insert(18, head);
	    head = a.insert(8, head);
	    head = a.insert(34, head);
	    head = a.insert(13, head);
	    head = a.insert(34, head);
	    head = a.insert(8, head);
	    head = a.insert(37, head);
	    head = a.insert(8, head);
	    
	    a.printList(head);
	    System.out.println();
	    
	    head = a.removeDuplicateUsingHashMap(head);
	    
	    a.printList(head);
	    System.out.println();
  }
}



2ND APPROACH

package linkedlist;

class Node {
  Node next;
  int data;
}

class Linked {
  /*
   * It'll remove duplicate from linked list
   */
  public Node removeDuplicate(Node node) {
    if(node == null) {
      return node;
    }
    
    node = mergeSort(node);
    return removeDuplicateSortedList(node);
  }
  
  private Node removeDuplicateSortedList(Node node) {
    if(node == null || node.next == null) {
      return node;
    }
    
    if(node.data == node.next.data) {
      node.next = node.next.next;
      removeDuplicateSortedList(node);
    } else {
      removeDuplicateSortedList(node.next);
    }
    
    return node;
  }
  
  /*
   * It'll sort the linked list
   */
  public Node mergeSort(Node node) {
    if(node == null || node.next == null) {
      return node;
    }
    
    Node middle = middleNode(node);
    Node secondHalf = middle.next;
    middle.next = null;
    
    return merge(mergeSort(node), mergeSort(secondHalf));
  }
  
  /*
   * It'll return the middle node of linked list
   */
  public Node middleNode(Node node) {
    if(node == null) {
      return null;
    }
    
    Node a = node;
    Node b = node.next;
    
    while(b != null && b.next != null) {
      a = a.next;
      b = b.next.next;
    }
    
    return a;
  }
  
  /*
   * It'll merge two linked list
   */
  public Node merge(Node a, Node b) {
    Node temp = new Node();
    Node finalList = temp;
    
    while(a != null && b != null) {
      if(a.data < b.data) {
        temp.next = a;
        a = a.next;
      } else {
        temp.next = b;
        b = b.next;
      }
      temp = temp.next;
    }
    temp.next = (a == null) ? b : a;
    return finalList.next;
  }
  
  /*
   * getNewNode() method to generate a new node
   */
  public Node getNewNode(int key) {
    Node a = new Node();
    a.next = null;
    a.data = key;
    return a;
  }

  /*
   * insert method is used to insert the element in Linked List
   */
  public Node insert(int key, Node node) {

    if (node == null)
      return getNewNode(key);
    else
      node.next = insert(key, node.next);

    return node;
  }

  /*
   * It'll print the complete linked list
   */
  public void printList(Node node) {
    if (node == null) {
      return;
    }

    System.out.print(node.data + " ");
    printList(node.next);
  }
}

public class LinkedListApp {

  public static void main(String[] args) {

    Node head = null;
    Linked a = new Linked();

    head = a.insert(18, head);
    head = a.insert(8, head);
    head = a.insert(34, head);
    head = a.insert(13, head);
    head = a.insert(34, head);
    head = a.insert(8, head);
    head = a.insert(37, head);
    head = a.insert(8, head);
    
    a.printList(head);
    System.out.println();
    
    head = a.removeDuplicate(head);
    
    a.printList(head);
    System.out.println();
  }
}



18. DELETE N NODE AFTER M NODE

package automate;
import java.io.*;
import java.util.*;

class Node {
	int data;
	Node next;
}

class Linked {
	
	 /*
	   * When list is null
	   * When n & m are greater than 0
	   * When m is 0 (Delete after No traversing)
	   * When n is 0 (Delete 0 element
	   * 
	   * When n is greater than number of element after traversing m nodes
	   */
	  public Node deleteNNodesPostMNodes(int n, int m, Node node) {
	    if(node == null) {
	      return node;
	    }
	    
	    Node tmp1 = node;
	    Node tmp2 = node;
	    int i = 0, j = 0;
	    // 12 8 34 13 7  n=1 m=2
           //12 8 13 37
	    while(i++ < m - 1) {
	      tmp1 = tmp1.next;
	    }
	    
	    tmp2 = (m == 0) ? tmp1 : tmp1.next;
	    
	    while(j++ < n) {
	      if(tmp2 == null) {
	        System.out.println("Not enough elements to delete");
	        return node;
	      }
	      tmp2 = tmp2.next;
	    }
	    
	    if(m == 0) {
	      return tmp2;
	    } else {
	      tmp1.next = tmp2;  
	    }
	  
	    
	    return node;
	  }
	
	
	public void printList(Node node) {
		if (node == null) {
			return;
		}
		
		System.out.print(node.data + " ");
		
		printList(node.next);
	}
	
	
	private Node getNewNode(int i) {
		Node a = new Node();
		a.data = i;
		a.next = null;
		return a;
	}
	
	public Node insert(int i, Node node) {
		if(node == null) {
			return getNewNode(i);
		} else {
			node.next = insert(i, node.next);
		}
		
		return node;
	}
	
	
}

public class MyClass {
	
  public static void main (String[] args) {
	  
	  Node head = null;
	    Linked a = new Linked();

	    head = a.insert(18, head);
	    head = a.insert(8, head);
	    head = a.insert(34, head);
	    head = a.insert(13, head);
	    head = a.insert(36, head);
	    head = a.insert(8, head);
	    head = a.insert(37, head);
	    head = a.insert(8, head);
	    
	    a.printList(head);
	    System.out.println();
	    

	    head = a.deleteNNodesPostMNodes(2, 3, head);
	    
	    a.printList(head);
	    System.out.println();
  }
}




19. FLATTEN A SORTED MULTILEVEL LINKEDLIST


class GfG
{
     Node mergeSortTwoLists(Node a, Node b){
	      Node temp = new Node(0);
	      Node res = temp;
	      
	      while(a != null && b != null){
	          if(a.data < b.data){
	              temp.bottom = a;
	              a = a.bottom;
	          }
	          else {
	              temp.bottom = b;
	              b = b.bottom;
	          }
	          temp = temp.bottom;
	      }
	      
	      if(a!= null) temp.bottom = a;
	  else temp.bottom = b;
	  return res.bottom;
 }
	  
	  
    Node flatten(Node head)
    {
	   if(head == null || head.next == null) return head;
	   
	   head.next = flatten(head.next);
	   
	   head = mergeSortTwoLists(head, head.next);
	   
	   return head;
    }
}



20. GET KTH NODE FROM LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
	  /*
	   * Return kth node of linked list
	   */
	  public int returnKthNode(Node node, int k) {
	    if(node == null) {
	      System.out.println("Linked list is empty");
	      return -1;
	    }
	    
	    for(int i = 1; i < k; i++) {
	      node = node.next;
	      if(node == null) {
	        System.out.println("k is greater than total node present in list");
	        return -1;
	      }
	    }
	    
	    return node.data;
	  }
	  
	  /*
	   * getNewNode() method to generate a new node
	   */
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	  /*
	   * insert method is used to insert the element in Linked List
	   */
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	  /*
	   * It'll print the complete linked list
	   */
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(12, head);
	    head = a.insert(99, head);
	    head = a.insert(12, head);
	    head = a.insert(8, head);
	    head = a.insert(8, head);
	    
	    a.printList(head);
	    System.out.println();
	    
	    System.out.println("Kth Node: " + a.returnKthNode(head, 2));
	  }
	}




21. GET KTH LAST NODE OF LINKED LIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}
1->2->3->4->5->6->7->8->9 k=2
Output: 8
	class Linked {
		
		  public int returnKthLastNode(Node node, int k) {
		    if(node == null) {
		      System.out.println("Linked list is empty");
		      return -1;
		    }
		    
		    Node ptr1, ptr2;
		    ptr1 = ptr2 = node;
		    for(int i = 1; i < k; i++) {
		      ptr2 = ptr2.next;
		      if(ptr2 == null) {
		        System.out.println("k is greater than total node present in list");
		        return -1;
		      }
		    }
		    
		    while(ptr2.next != null) {
		      ptr1 = ptr1.next;
		      ptr2 = ptr2.next;
		    }
		    
		    return ptr1.data;
		  }
		  
	
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(8, head);
	    head = a.insert(18, head);
	    head = a.insert(17, head);
	    head = a.insert(28, head);
	    head = a.insert(6, head);
	    
	    a.printList(head);
	    System.out.println();
	    
	    int kthlast = a.returnKthLastNode(head, 3); 
	    System.out.println(kthlast); 
	    

	  }
	}

22. DETECT LOOP IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		  public boolean ifLoopPresent(Node head) {
		        if(head == null || head.next == null)
		            return false;
		        
		        Node fast = head;
		        Node slow = head;
		        
		        while(fast.next != null && fast.next.next != null){
		            fast = fast.next.next;
		            slow = slow.next;
		            if(fast.data == slow.data)
		                return true;
		        }
		        return false;
		    }
		
		  
	
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(8, head);
	    head = a.insert(18, head);
	    head = a.insert(17, head);
	    head = a.insert(28, head);
	    head = a.insert(6, head);
	    
	    head.next.next.next.next.next = head.next;
	    
	
	    
	    boolean hascycle = a.ifLoopPresent(head); 
	    System.out.println(hascycle); 
	    

	  }
	}

23. DETECT LENGTH OF LOOP IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		  public int lengthofloop(Node head) {
		        if(head == null || head.next == null)
		            return -1;
		        
		        Node fast = head;
		        Node slow = head;
		        int length = 0;
		        
		        while(fast.next != null && fast.next.next != null){
		            fast = fast.next.next;
		            slow = slow.next;
		            if(fast.data == slow.data)
		               break;
		        }
		      if(slow == fast) {
		    	  while(slow.next != fast) {
		    		  slow = slow.next;
		    		  length++;	
	    	  }
		    	  length++;
		      }
		      return length;
		  }
		
		  
	
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(8, head);
	    head = a.insert(18, head);
	    head = a.insert(17, head);
	    head = a.insert(28, head);
	    head = a.insert(6, head);
	    
	    head.next.next.next.next.next = head.next;
	    
	
	    
	    int length = a.lengthofloop(head); 
	    System.out.println(length); 
	    

	  }
	}


24. STARTING POINT OF LOOP IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		  public Node startingpointofloop(Node head) {
		        if(head == null || head.next == null)
		            return null;
		        
		        Node fast = head;
		        Node slow = head;
		        Node entry = head;
		        
		        while(fast.next != null && fast.next.next != null){
		            fast = fast.next.next;
		            slow = slow.next;
		            if(fast.data == slow.data) {
		                while(slow != entry){
		                    slow = slow.next;
		                    entry = entry.next;
		                }
		            return entry;
		        }
		    }
		        return null;
		  }
		
		  
	
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(8, head);
	    head = a.insert(18, head);
	    head = a.insert(17, head);
	    head = a.insert(28, head);
	    head = a.insert(6, head);
	    
	    head.next.next.next.next.next = head.next;
	    
	
	    
	    head  = a.startingpointofloop(head); 
	    a.printList(head); 
	    

	  }
	}

25. DETECT AND REMOVE LOOP IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public void detectAndRemoveLoopPresent(Node head) {
		    if(head == null) {
		      return;
		    }
		    
		    Node slow, fast;
		    
		    slow = fast = head;
		    while(fast.next != null && fast.next.next != null) {
		      slow = slow.next;
		      fast = fast.next.next;
		      if(slow.data == fast.data) {
		        break;
		      }
		    }
		    
		    if(slow == fast) {
		      if(fast == head) {
		        while(slow.next != fast) {
		          slow = slow.next;
		        }
		        
		        slow.next = null;
		      } else {
		        slow = head;
		        while(slow.next != fast.next) {
		          slow = slow.next;
		        }
		        
		        fast.next = null;
		      }
		    }
		    
		    return;
		  }

	
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }
	  
	  
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(8, head);
	    head = a.insert(18, head);
	    head = a.insert(17, head);
	    head = a.insert(28, head);
	    head = a.insert(6, head);
	    
	    head.next.next.next.next.next = head.next;
	    
	
	    
	    a.detectAndRemoveLoopPresent(head);
	    
	    a.printList(head);
	    

	  }
	}


26. DELETE MIDDLE NODE OF LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node deleteMiddleNode(Node node) {
		    if(node == null || node.next == null) {
		      return null;
		    }
		    
		    Node slow, fast, prev;
		    
		    slow = fast = prev = node;
		    
		    while(fast != null && fast.next != null) {
		      prev = slow;
		      slow = slow.next;
		      fast = fast.next.next;
		    }
		    
		    prev.next = slow.next;
		    return node;
		  }
	
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }
	  
	  
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(8, head);
	    head = a.insert(18, head);
	    head = a.insert(17, head);
	    head = a.insert(28, head);
	    head = a.insert(6, head);
	    
	
	    a.printList(head);
	    System.out.println();
	    
	    a.deleteMiddleNode(head);
	    
	    a.printList(head);
	    

	  }
	}


27. CHECK IF FIRST AND SECOND HALF ELEMENTS ARE MATCHING

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public boolean ifFirstSecondHalfMatching(Node node) {
			    if(node == null || node.next == null) {
			      return true;
			    }
			    
			    Node slow, fast;
			    slow = fast = node;
			    
			    while(fast.next != null && fast.next.next != null) {
			      slow = slow.next;
			      fast = fast.next.next;
			    }
			    
			    Node secondHalf = slow.next;
			    
			    while(secondHalf != null) {
			      if(node.data != secondHalf.data) {
			        return false;
			      }
			      
			      node = node.next;
			      secondHalf = secondHalf.next;
			    }
			    
			    return true;
			  }
	  
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(8, head);
	    head = a.insert(18, head);
	    head = a.insert(17, head);
	    head = a.insert(28, head);
	    head = a.insert(6, head);
	    
	
	    a.printList(head);
	    System.out.println();
	    
	    System.out.println(a.ifFirstSecondHalfMatching(head));
	    

	  }
	}


28. DELETE LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node deletelist(Node node) {
			return null;
		}
	  
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(8, head);
	    head = a.insert(18, head);
	    head = a.insert(17, head);
	    head = a.insert(28, head);
	    head = a.insert(6, head);
	    
	
	    a.printList(head);
	    System.out.println();
	    
	   head = a.deletelist(head);
	    

	  }
	}
	                        	                    


29. CHECK IF LINKEDLIST IS PALINDROME

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public boolean isPalindrome(Node node) {
			  if(node == null || node.next == null) {
			      return true;
			    }
			    
			    Node slow, fast;
			    slow = fast = node;
			    
			    while(fast.next != null && fast.next.next != null) {
			      slow = slow.next;
			      fast = fast.next.next;
			    }
			    
			    slow.next = reverse(slow.next);
			    
			    Node secondHalf = slow.next;
			    
			    while(secondHalf != null) {
			      if(node.data != secondHalf.data) {
			        return false;
			      }
			      
			      node = node.next;
			      secondHalf = secondHalf.next;
			    }
			    
			    return true;
			  }
	  
		
		public Node reverse(Node node) {
			
			
			if(node == null || node.next == null) {
				return node;
			}
			
		  Node temp = reverse(node.next);
		  node.next.next = node;
		  node.next = null;
		  
		  return temp;
		  
		 
			
			
		}
		
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(1, head);
	    head = a.insert(2, head);
	    head = a.insert(2, head);
	    head = a.insert(1, head);
	    
	    
	
	    a.printList(head);
	    System.out.println();
	    
	  boolean palin = a.isPalindrome(head);
	  System.out.println(palin);
	    

	  }
	}


30. DELETE NODE WHICH HAVE GREATER VALUES ON RIGHT

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node deleteGreaterValuesOnRight(Node node) {
		    if(node == null || node.next == null) {
		      return node;
		    }
		    
		    Node reverse = this.reverse(node);
		    Node tmp = reverse;
		    int max = tmp.data;
		    
		    while(tmp.next != null) {
		      if(tmp.next.data > max) {
		        max = tmp.next.data;
		        tmp = tmp.next;
		      } else {
		        tmp.next = tmp.next.next;
		      }
		    }
		    
		    node = this.reverse(reverse);
		    
		    return node;
		  }

		
		public Node reverse(Node node) {
			
			
			if(node == null || node.next == null) {
				return node;
			}
			
		  Node temp = reverse(node.next);
		  node.next.next = node;
		  node.next = null;
		  
		  return temp;
		  
		 
			
			
		}
		
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

	    Node head = null;
	    Linked a = new Linked();

	    head = a.insert(1, head);
	    head = a.insert(2, head);
	    head = a.insert(2, head);
	    head = a.insert(1, head);
	    
	    
	
	    a.printList(head);
	    System.out.println();
	    
	    head = a.deleteGreaterValuesOnRight(head);
	    
	    a.printList(head);
	    

	  }
	}

class Solution {
    public int[] nextLargerNodes(ListNode head) {
        ArrayList<Integer> A = new ArrayList<>();
        for (ListNode node = head; node != null; node = node.next)
            A.add(node.val);
        int[] res = new int[A.size()];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < A.size(); ++i) {
            while (!stack.isEmpty() && A.get(stack.peek()) < A.get(i))
                res[stack.pop()] = A.get(i);
            stack.push(i);
        }
        return res;
    }
}


31. CHECK IF TWO LINKEDLIST ARE IDENTICAL

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public boolean ifIdenticalLists(Node node1, Node node2) {
			    while(node1 != null && node2 != null) {
			      if(node1.data != node2.data) {
			        return false;
			      }
			      
			      node1 = node1.next;
			      node2 = node2.next;
			    }
			    
			    return (node1 == null && node2 == null);
			  }

		
		
		
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head1 = null;
		    Linked a = new Linked();

		    head1 = a.insert(12, head1);
		    head1 = a.insert(99, head1);
		    head1 = a.insert(8, head1);
		    head1 = a.insert(39, head1);
		    head1 = a.insert(5, head1);
		    
		    a.printList(head1);
		    System.out.println();
		    
		    Node head2 = null;
		    
		    head2 = a.insert(12, head2);
		    head2 = a.insert(99, head2);
		    head2 = a.insert(8, head2);
		    head2 = a.insert(39, head2);
		    head2 = a.insert(5, head2);
		    
		    a.printList(head2);
		    System.out.println();
		    
		    System.out.println(a.ifIdenticalLists(head1, head2));

	  }
	}


32. PAIRWISE SWAP ELEMENTS OF LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node pairwiseSwapElements(Node node) {
		    if(node == null || node.next == null) {
		      return node;
		    }
		    
		    Node head = node;
		    
		    while(node != null && node.next != null) {
		      int t = node.data;
		      node.data = node.next.data;
		      node.next.data = t;
		      
		      node = node.next.next; 
		    }
		    
		    return head;
		  }
		
		
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		    head = a.pairwiseSwapElements(head);
		    
		    a.printList(head);

	  }
	}


33. COUNT OCCURENCE OF A VALUE

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public int getCountofValue(Node node, int val) {
		    if(node == null ) {
		      return -1;
		    }
		    
		int count = 0;
		    
		    while(node != null) {
		     if(node.data == val) {
		    	 count++;
		     }
		     
		     node = node.next;
		    }
		    
		    return count;
		  }
		
		
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		   System.out.println(a.getCountofValue(head, 5));

	  }
	}

	                        	                    

34. DELETE ALTERNATE NODES IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node deletealternatenode(Node node) {
		    if(node == null || node.next == null ) {
		      return node;
		    }
		    
		Node head = node;
		
		 while(node != null && node.next != null) {
		      
		      node.next = node.next.next;
		      node = node.next;
		      
		      
		    }
		    
		    return head;
		  }
		
		
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		  head = a.deletealternatenode(head);
		  a.printList(head);

	  }
	}



35. MOVE LAST NODE TO THE FRONT

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node moveLastNodeToFront(Node node) {
		    if(node == null || node.next == null ) {
		      return node;
		    }
		    
		Node head = node;
		
		 while( node.next.next != null) {
		      node = node.next;
		    }
		    
		  node.next.next = head;
		  head = node.next;
		  
		  node.next = null;
		  return head;
		  }
		
		
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		  head = a.moveLastNodeToFront(head);
		  a.printList(head);

	  }
	}


36. SWAP NODES OF GIVEN VALUE WITHOUT SWAPPING DATA

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node swapNodes(Node node, int a, int b) {
		    if(node == null || node.next == null ) {
		      return node;
		    }
		    
		Node t1, t2, head, prev1, prev2;
		prev1 = prev2 = t1 = t2 = null;
		
		head = node;
		
		 while( node != null) {
		     if(node.data == a) {
		    	 t1 = node;
		    	 break;
		     }
		     prev1 = node;
		     node = node.next;
		    }
		 
		 node = head;
		    
		 
		  
		  while( node != null) {
			     if(node.data == b) {
			    	 t2 = node;
			    	 break;
			     }
			     prev2 = node;
			     node = node.next;
			    }
		
		  if(t1 == null || t2 == null) {
			  return head;
		  }
		  
		  if(prev1 != null) {
			  prev1.next = t2;
		  } else {
			  head = t2;
		  }
		  
		  if(prev2 != null) {
			  prev2.next = t1;
		  } else {
			  head = t1;
		  }
		  
		  Node tmp = t1.next;
		  t1.next = t2.next;
		  t2.next = tmp;
		  
		  return head;
		  
		}
	  
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		  head = a.swapNodes(head, 99, 39);
		  a.printList(head);

	  }
	}


SWAPPING NODES IN LINKEDLIST

class Solution {
    public ListNode swapNodes(ListNode head, int k) {
        ListNode first = head;
        ListNode second = head;
        ListNode nodeK = new ListNode(0);
        
        for (int i = 1; i < k; i++) first = first.next; // 2
        nodeK = first;  // 2 to store the data for swapping in future.
        
        first = first.next;  // 3
        while (first != null) {
            first = first.next;
            second = second.next;
        }
        
        int temp = nodeK.val;
        nodeK.val = second.val;
        second.val = temp;
        return head;
    }
}


37. INTERSECTION POINT OF TWO LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public int getIntersectionOfLists(Node node1, Node node2) {
		    if(node1 == null || node2 == null) {
		      return -1;
		    }
		    
		    Node head1 = node1, head2 = node2;
		    
		    int count1 = 0, count2 = 0;
		    while(node1 != null) {
		      count1++;
		      node1 = node1.next;
		    }
		    
		    while(node2 != null) {
		      count2++;
		      node2 = node2.next;
		    }
		    
		    int v = count1 - count2;
		    while(v > 0) {
		      head1 = head1.next;
		      v--;
		    }
		    
		    while(v < 0) {
		      head2 = head2.next;
		      v++;
		    }
		    
		    while(head1 != null && head2 != null) {
		      if(head1.data == head2.data) {
		        return head1.data;
		      } 
		      
		      head1 = head1.next;
		      head2 = head2.next;
		    }
		    
		    return -1;
		  }
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head1 = null;
		    Linked a = new Linked();

		    head1 = a.insert(1, head1);
		    head1 = a.insert(24, head1);
		    head1 = a.insert(34, head1);
		    head1 = a.insert(9, head1);
		    head1 = a.insert(8, head1);
		    head1 = a.insert(37, head1);
		    head1 = a.insert(5, head1);
		    
		    a.printList(head1);
		    System.out.println();
		    
		    Node head2 = null;
		    
		    head2 = a.insert(12, head2);
		    head2 = a.insert(99, head2);
		    head2 = a.insert(8, head2);
		    head2 = a.insert(37, head2);
		    head2 = a.insert(5, head2);
		    
		    a.printList(head2);
		    System.out.println();
		    
		    System.out.println(a.getIntersectionOfLists(head1, head2));

	  }
	}

38. REVERSE LINKEDLIST ITERATIVELY

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node reverseIteratively(Node node) {
		    if(node == null || node.next == null) {
		      return node;
		    }
		    
		    Node prev, next;
		    prev = next = null;
		    
		    while(node != null) {
		      next = node.next;
		      node.next = prev;
		      prev = node;
		      node = next;
		    }
		  
		    return prev;
		  }
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		    head = a.reverseIteratively(head);

		    a.printList(head);

	  }
	}


39. REVERSE LIST IN GROUP OF K ELEMENTS

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node reverseInGroup(Node head, int k) {
		    Node prev, next;
		    prev = next = null;
		    
		    Node node = head;
		    
		    int i = 0;
		    
		    while(node != null && i < k) {
		      next = node.next;
		      node.next = prev;
		      prev = node;
		      node = next;
		      i++;
		    }
		    
		    if(next != null) {
		      head.next = reverseInGroup(next, k);
		    }
		    
		    return prev;
		  }
		    
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		    head = a.reverseInGroup(head, 3);

		    a.printList(head);

	  }
	}

LEETCODE REVERSE

class Solution {
     static ListNode tt = null;
    static ListNode th = null;

    public static void addFirst(ListNode node) {
        if (th == null) {
            th = node;
            tt = node;
        } else {
            node.next = th;
            th = node;
        }
    }

    public static int length(ListNode node) {
        int len = 0;
        while (node != null) {
            node = node.next;
            len++;
        }
        return len;
    }
    
    public ListNode reverseKGroup(ListNode head, int k) {
         if (head == null || head.next == null || k <= 1)
            return head;

        int len = length(head);

        ListNode oh = null;
        ListNode ot = null;
        ListNode curr = head;

        while (curr != null && len >= k) {
            int tempK = k;
            while (tempK-- > 0) {
                ListNode forw = curr.next;

                curr.next = null;
                addFirst(curr);

                curr = forw;
            }

            len -= k;
            if (oh == null) {
                oh = th;
                ot = tt;
            } else {
                ot.next = th;
                ot = tt;
            }

            th = null;
            tt = null;
        }

        ot.next = curr;
        return oh;
    }
}



40. REVERSE ALTERNATIVELY IN GROUP OF K

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node reverseInGroupalternatively(Node head, int k) {
			if(k <= 1 || head == null || head.next == null) {
				return head;
			}
			
		    Node prev, next;
		    prev = next = null;
		    
		    Node node = head;
		    
		    int i = 0;
		    
		    while(node != null && i < k) {
		      next = node.next;
		      node.next = prev;
		      prev = node;
		      node = next;
		      i++;
		    }
		    
		    i = 0;
		    if(next != null) {
		      head.next = next;
		      node = next;
		      while(node != null && i < k - 1) {
		        node = node.next;
		        i++;
		      }
		      if(node != null) {
		        node.next = reverseInGroupalternatively(node.next, k);
		      }
		    }
		    
		    return prev;
		  }
		    
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		    head = a.reverseInGroupalternatively(head, 2);

		    a.printList(head);

	  }
	}


41. SEPARATE EVEN AND ODD LIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node seperateOddEven(Node node) {
		    if(node == null || node.next == null) {
		      return node;
		    }
		    
		    Node evenStartingNode, evenEndNode, oddStartingNode, oddEndNode;
		    
		    evenStartingNode = evenEndNode = oddStartingNode = oddEndNode = null;
		    
		    while(node != null) {
		      if(node.data % 2 == 0) {
		        if(evenStartingNode == null) {
		          evenStartingNode = node;
		          evenEndNode = evenStartingNode;
		        } else {
		          evenEndNode.next = node;
		          evenEndNode = evenEndNode.next;
		        }
		      } else {
		        if(oddStartingNode == null) {
		          oddStartingNode = node;
		          oddEndNode = oddStartingNode;
		        } else {
		          oddEndNode.next = node;
		          oddEndNode = oddEndNode.next;
		        }
		      }
		      
		      node = node.next;
		    }

		    evenEndNode.next = oddStartingNode;
		    oddEndNode.next = null;
		    return evenStartingNode;
		  }
		    
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    head = a.insert(70, head);
		    head = a.insert(25, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		    head = a.seperateOddEven(head);

		    a.printList(head);

	  }
	}


ODDEVEN LINKEDLIST
Input: head = [2,1,3,5,6,4,7]
Output: [2,3,6,7,1,5,4]
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head != null) {
    
        ListNode odd = head, even = head.next, evenHead = even; 
    
        while (even != null && even.next != null) {
            odd.next = odd.next.next; 
            even.next = even.next.next; 
            odd = odd.next;
            even = even.next;
        }
        odd.next = evenHead; 
    }
    return head;
    }
}


42. ALTERNATE SPLITTING OF LIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		Node firstHead, secondHead;
		  public void alternateSplit(Node node) {
		    if(node == null || node.next == null) {
		      return;
		    }
		    
		    Node firstTemp;
		    Node secondTemp;
		    
		    firstHead = firstTemp = node;
		    secondHead = secondTemp = node.next;
		    node = node.next.next;
		    
		    while(node != null && node.next != null) {
		      firstTemp.next = node;
		      secondTemp.next = node.next;
		      
		      firstTemp = firstTemp.next;
		      secondTemp = secondTemp.next;
		      
		      node = node.next.next;
		    }
		    
		    if(node != null) {
		      firstTemp.next = node;
		      firstTemp = firstTemp.next;
		    }
		    
		    firstTemp.next = null;
		    secondTemp.next = null;
		    
		    return;
		  }
		    
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(12, head);
		    head = a.insert(99, head);
		    head = a.insert(8, head);
		    head = a.insert(39, head);
		    head = a.insert(5, head);
		    head = a.insert(70, head);
		    head = a.insert(25, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		    a.alternateSplit(head);

		    a.printList(a.firstHead);
		    System.out.println();
		    
		    a.printList(a.secondHead);

	  }
	}


43.  MERGE TWO LINKEDLIST ALTERNATIVELY

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		Node first, second; 
		  public void mergeTwoListAlternatively(Node node1, Node node2) {
		    
		    Node node1next, node2next;
		    first = node1;
		    second = node2;
		    
		    while(node1 != null && node2 != null) {
		      node1next = node1.next;
		      node1.next = node2;
		      node1 = node1next;
		      
		      node2next = node2.next;
		      node2.next = node1next;
		      node2 = node2next;
		    }
		    
		    second = node2;
		  }
		    
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head1 = null;
		    Linked a = new Linked();

		    head1 = a.insert(12, head1);
		    head1 = a.insert(99, head1);
		    head1 = a.insert(8, head1);
		    head1 = a.insert(39, head1);
		    
		    Node head2 = null;
		    head2 = a.insert(5, head2);
		    head2 = a.insert(70, head2);
		    
		    a.printList(head1);
		    System.out.println();
		    
		    a.printList(head2);
		    System.out.println();
		    
		    a.mergeTwoListAlternatively(head1, head2);
		    
		    a.printList(a.first);

	  }
	}


44. SORT 0, 1, 2 IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node sortListOfZeroOneTwos(Node node) {
		 if(node == null || node.next == null) {
		      return node;
		    }
		    
		    Node head = node;
		    
		    int count_0, count_1, count_2;
		    
		    count_0 = count_1 = count_2 = 0;
		    
		    while(node != null) {
		      if(node.data == 0) {
		        count_0++;
		      } else if(node.data == 1) {
		        count_1++;
		      } else {
		        count_2++;
		      }
		      
		      node = node.next;
		    }
		    
		    node = head;
		    
		    while(count_0 > 0) {
		      node.data = 0;
		      node = node.next;
		      count_0--;
		    }
		    
		    while(count_1 > 0) {
		      node.data = 1;
		      node = node.next;
		      count_1--;
		    }
		    
		    while(count_2 > 0) {
		      node.data = 2;
		      node = node.next;
		      count_2--;
		    }
		    
		    return head;
		  }
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		    Linked a = new Linked();

		    head = a.insert(2, head);
		    head = a.insert(1, head);
		    head = a.insert(0, head);
		    head = a.insert(1, head);
		    head = a.insert(2, head);
		    head = a.insert(1, head);
		    
		    head = a.sortListOfZeroOneTwos(head);
		    
		    a.printList(head);

	  }
	}



45. ADD 1 TO LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		
		public int addOneToList(Node node) {
			if(node == null)
				return 1;
			
			int res = node.data + addOneToList(node.next);
			
			node.data = res % 10;
			return res / 10;
		}
		
		public Node addOne(Node node) {
		int c = addOneToList(node);
		
		if(c == 1) {
			Node head = this.getNewNode(1);
			head.next = node;
			return head;
		}
		
		return node;
		  }
		
		
		 public Node insert(int key, Node node) {

			    if (node == null)
			      return getNewNode(key);
			    else
			      node.next = insert(key, node.next);

			    return node;
			  }
		 
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Node head = null;
		  
		    Linked a = new Linked();

		    head = a.insert(1, head);
		    head = a.insert(9, head);
		    head = a.insert(9, head);
		    head = a.insert(9, head);
		    head = a.insert(9, head);
		  
		    
		    head = a.addOne(head);
		    
		    a.printList(head);

	  }
	}


46. CHECK IF TRIPLET EXISTS

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public boolean isTripletExistForSum(Node node1, Node node2, Node node3, int val) {
		    
		    Node head2, head3;
		    head2 = node2;
		    head3 = node3;
		    
		    while(node1 != null) {
		      while(node2 != null && node3 != null) {
		        
		        int s = node1.data + node2.data + node3.data;
		        
		        if(s == val) {
		          return true;
		        } else if (s > val) {
		          node3 = node3.next;
		        } else {
		          node2 = node2.next;
		        }
		      }
		      
		      node1 = node1.next;
		      node2 = head2;
		      node3 = head3;
		    }
		    
		    return false;
		  }
		
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();
		    
		    Node head1 = null;
		    head1 = a.insert(5, head1);
		    head1 = a.insert(2, head1);
		    head1 = a.insert(9, head1);
		    
		    a.printList(head1);
		    System.out.println();
		    
		    Node head2 = null;
		    head2 = a.insert(2, head2);
		    head2 = a.insert(3, head2);
		    head2 = a.insert(7, head2);
		    
		    a.printList(head2);
		    System.out.println();
		    
		    Node head3 = null;
		    head3 = a.insert(12, head3);
		    head3 = a.insert(8, head3);
		    head3 = a.insert(4, head3);
		    
		    a.printList(head3);
		    System.out.println();
		    
		    System.out.println(a.isTripletExistForSum(head1, head2, head3, 13));
		    System.out.println(a.isTripletExistForSum(head1, head2, head3, 14));

	  }
	}


47. MAKE MIDDLE NODE AS HEAD OF LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public Node makeMiddleNodeHead(Node node) {
			    if(node == null || node.next == null) {
			      return node;
			    }
			    
			    Node slow, fast, head, prev;
			    slow = fast = head = prev = node;
			    
			    while(fast.next != null && fast.next.next != null) {
			      prev = slow;
			      slow = slow.next;
			      fast = fast.next.next;
			    }
			    
			    prev.next = slow.next;
			    slow.next = head;
			    head = slow;
			    
			    return head;
			  }
		
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		 
		    
		  Linked a = new Linked();
		    
		    Node head = null;
		    head = a.insert(12, head);
		    head = a.insert(7, head);
		    head = a.insert(13, head);
		    head = a.insert(22, head);
		    head = a.insert(8, head);
		    
		    a.printList(head);
		    System.out.println();
		        
		    head = a.makeMiddleNodeHead(head);
		    
		    a.printList(head);
	  }
	}
 

48. INSERT NODE INTO MIDDLE OF LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node insertNodeInMiddle(Node node, int val) {
		    if(node == null) {
		      return node;
		    }
		    
		    Node slow, fast, head;
		    slow = fast = head = node;
		    
		    while(fast.next != null && fast.next.next != null) {
		      slow = slow.next;
		      fast = fast.next.next;
		    }
		    
		    Node newNode = getNewNode(val);
		    newNode.next = slow.next;
		    slow.next = newNode;
		    
		    return head;
		  }
		
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();
		    
		    Node head = null;
		    head = a.insert(12, head);
		    head = a.insert(7, head);
		    head = a.insert(13, head);
		    head = a.insert(22, head);
		    head = a.insert(8, head);
		    
		    a.printList(head);
		    System.out.println();
		        
		    head = a.insertNodeInMiddle(head, 100);
		    
		    a.printList(head);
	  }
	}


49. COUNT ROTATION IN SORTED AND ROTATED LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public int countRotationInSortedRotatedList(Node node) {
			    if(node == null || node.next == null) {
			      return 0;
			    }
			    
			    int count = 0;
			    while(node.next != null) {
			      if(node.data < node.next.data) {
			        count++;
			      } else {
			        break;
			      }
			      
			      node = node.next;
			    }
			    
			    if(node.next == null) {
			      return 0;
			    } else{
			      return count + 1;  
			    }
			    
			  }
		
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();
		    
		  Node head = null;
		    head = a.insert(22, head);
		    head = a.insert(38, head);
		    head = a.insert(1, head);
		    head = a.insert(7, head);
		    head = a.insert(13, head);
		    
		    a.printList(head);
		    System.out.println();
		        
		    System.out.println(a.countRotationInSortedRotatedList(head));
	  }
	}


50. ADD TWO NUMBERS IN LINKEDLIST RECURSIVELY


1ST APPROACH

package linkedlist;

class Node {
  Node next;
  int data;
}

class Linked {
  /*
   * It adds two linked list numbers which're presented as single digit element
   */
  public Node addTwoNumbers(Node node1, Node node2) {
    node1 = this.reverse(node1);
    node2 = this.reverse(node2);
    
    Node newListHead = null;
    Node prev = null;
    int sum, c = 0;
    
    while(node1 != null || node2 != null) {
      sum = c + (node1 != null ? node1.data : 0)
          + (node2 != null ? node2.data: 0);
      
      c = sum / 10;
      
      Node node = getNewNode(sum % 10);
      if(newListHead == null) {
        newListHead = node;
      } else {
        prev.next = node;
      }
      
      prev = node;
      
      if(node1 != null) {
        node1 = node1.next;
      }
      
      if(node2 != null) {
        node2 = node2.next;
      }
    }
    
    if(c != 0) {
      prev.next = getNewNode(c);
    }
    
    newListHead = this.reverse(newListHead);
    
    return newListHead;
  }
  
  /*
   * It reverses the linked list
   */
  public Node reverse(Node node) {
    if(node == null || node.next == null) {
      return node;
    }
    
    Node temp = reverse(node.next);
    node.next.next = node;
    node.next = null;
    
    return temp;
  }
  
  /*
   * getNewNode() method to generate a new node
   */
  public Node getNewNode(int key) {
    Node a = new Node();
    a.next = null;
    a.data = key;
    return a;
  }

  /*
   * insert method is used to insert the element in Linked List
   */
  public Node insert(int key, Node node) {

    if (node == null)
      return getNewNode(key);
    else
      node.next = insert(key, node.next);

    return node;
  }

  /*
   * It'll print the complete linked list
   */
  public void printList(Node node) {
    if (node == null) {
      return;
    }

    System.out.print(node.data + " ");
    printList(node.next);
  }
}

public class LinkedListApp {
  public static void main(String[] args) {
    Linked a = new Linked();
    
    Node head1 = null;
    head1 = a.insert(1, head1);
    head1 = a.insert(7, head1);
    head1 = a.insert(8, head1);
    head1 = a.insert(2, head1);
    head1 = a.insert(5, head1);
    
    a.printList(head1);
    System.out.println();
    
    Node head2 = null;
    head2 = a.insert(5, head2);
    head2 = a.insert(6, head2);
    head2 = a.insert(7, head2);
    
    a.printList(head2);
    System.out.println();
    
    Node addLists = a.addTwoNumbers(head1, head2);
    a.printList(addLists);
    
  }
}



2ND APPROACH
package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		Node result, tempNode;
		  int carry;
		  public void addSumOfTwoLists(Node node1, Node node2) {

		    int count1 = 0, count2 = 0;
		    Node head1 = node1, head2 = node2;
		    
		    while(node1 != null) {
		      count1++;
		      node1 = node1.next;
		    }
		    
		    while(node2 != null) {
		      count2++;
		      node2 = node2.next;
		    }
		    
		    if(count1 == count2) {
		      calSum(head1, head2);
		    } else {
		      if(count1 < count2) {
		        Node tmp = head1;
		        head1 = head2;
		        head2 = tmp;
		      }
		      
		      int d = Math.abs(count2 - count1);
		      
		      node1 = head1;
		      node2 = head2;
		      
		      while(d > 0) {
		        node1 = node1.next;
		        tempNode = node1;
		        d--;
		      }
		      
		      this.calSum(node1, node2);
		      
		      this.addRestSum(head1);
		    }
		    
		    if(carry > 0) {
		      Node a = getNewNode(carry);
		      a.next = result;
		      result = a;
		    }
		  }
		  
		  public void calSum(Node node1, Node node2) {
		    if(node1 == null) {
		      return;
		    }

		    calSum(node1.next, node2.next);
		    int s = node1.data + node2.data + carry;
		    
		    carry = s / 10;
		    if(result == null) {
		      result = getNewNode(s % 10);
		    } else {
		      Node a = getNewNode(s % 10);
		      a.next = result;
		      result = a;
		    }
		    
		  }
		  
		  public void addRestSum(Node node) {
		    if(node == null) {
		      return;
		    }
		    
		    if(node != tempNode) {
		      addRestSum(node.next);
		      int s = node.data + carry;
		      carry = s / 10;
		      Node a = getNewNode(s % 10);
		      a.next = result;
		      result = a;
		    }
		  }
		  
		
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();
		    
		    Node head1 = null;
		    head1 = a.insert(1, head1);
		    head1 = a.insert(7, head1);
		    head1 = a.insert(8, head1);
		    head1 = a.insert(2, head1);
		    head1 = a.insert(5, head1);
		    
		    a.printList(head1);
		    System.out.println();
		    
		    Node head2 = null;
		    head2 = a.insert(5, head2);
		    head2 = a.insert(6, head2);
		    head2 = a.insert(7, head2);
		    
		    a.printList(head2);
		    System.out.println();
		    
		    a.addSumOfTwoLists(head1, head2);
		    a.printList(a.result);
		    
	  }
	}



51. SUBTRACT TWO NUMBERS IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node substactTwoNumbers(Node node1, Node node2) {
		    Node head1 = node1;
		    Node head2 = node2;
		    
		    int count1 = 0, count2 = 0;
		    
		    while(node1 != null) {
		      node1 = node1.next;
		      count1++;
		    }
		    
		    while(node2 != null) {
		      node2 = node2.next;
		      count2++;
		    }
		    
		    node1 = head1;
		    node2 = head2;
		    
		    if((count1 < count2) || (count1 == count2 && node2 == getBiggerList(node1, node2))) {
		      Node t = node1;
		      node1 = node2;
		      node2 = t;
		    }
		    
		    node1 = this.reverse(node1);
		    node2 = this.reverse(node2);
		    
		    Node newListHead = null;
		    Node prev = null;
		    int diff;
		    boolean borrow = false;
		    
		    while(node1 != null || node2 != null) {
		      if(borrow) {
		        node1.data = node1.data - 1;
		        borrow = false;
		      }
		      
		      
		      if(node1 != null && node2 != null && node1.data < node2.data) {
		        node1.data = node1.data + 10;
		        borrow = true;
		      }
		      
		      diff = (node1 != null ? node1.data : 0) - (node2 != null ? node2.data: 0);
		      
		      Node node = getNewNode(diff);
		      if(newListHead == null) {
		        newListHead = node;
		      } else {
		        prev.next = node;
		      }
		      
		      prev = node;
		      
		      if(node1 != null) {
		        node1 = node1.next;
		      }
		      
		      if(node2 != null) {
		        node2 = node2.next;
		      }
		      
		    }
		    
		    newListHead = this.reverse(newListHead);
		    
		    return newListHead;
		  }
		  
		  /*
		   * It gives the bigger node list
		   */
		  public Node getBiggerList(Node node1, Node node2) {
		    Node head1 = node1;
		    Node head2 = node2;
		    while(node1 != null) {
		      if(node1.data > node2.data) {
		        return head1;
		      } else if(node1.data < node2.data) {
		        return head2;
		      }
		      
		      node1 = node1.next;
		      node2 = node2.next;
		    }
		    
		    return head1;
		  }
		  
		  public Node reverse(Node node) {
		    if(node == null || node.next == null) {
		      return node;
		    }
		    
		    Node temp = reverse(node.next);
		    node.next.next = node;
		    node.next = null;
		    
		    return temp;
		  }
		  
		
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();
		    
		    Node head1 = null;
		    head1 = a.insert(1, head1);
		    head1 = a.insert(7, head1);
		    head1 = a.insert(8, head1);
		    head1 = a.insert(2, head1);
		    head1 = a.insert(5, head1);
		    
		    a.printList(head1);
		    System.out.println();
		    
		    Node head2 = null;
		    head2 = a.insert(5, head2);
		    head2 = a.insert(6, head2);
		    head2 = a.insert(7, head2);
		    
		    a.printList(head2);
		    System.out.println();
		    
		    Node substract = a.substactTwoNumbers(head1, head2);
		    a.printList(substract);
		    
	  }
	}


52. MERGE K SORTED LINKEDLIST
nklogk
package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public Node mergeKSortedLists(Node[] arr, int last) {
			    while(last != 0) {
			      int i = 0;
			      int j = last;
			      
			      while(i < j) {
			        arr[i] = mergeTwoSortedLinkedList(arr[i], arr[j]);
			        
			        i++;
			        j--;
			        
			        if(i >= j) {
			          last = j;
			          break;
			        }
			      }
			    }
			    
			    return arr[0];
			  }
			  
			  /*
			   * It merges two sorted linked list
			   */
			  public Node mergeTwoSortedLinkedList(Node node1, Node node2) {
			    if(node1 == null && node2 == null) {
			      return null;
			    }
			    
			    if(node1 == null || node2 == null) {
			      return node1 != null ? node1 : node2;
			    }
			    
			    return mergeTwoList(node1, node2);
			  }
			  
			  /*
			   * Helper function to merge two sorted linked list
			   */
			  public Node mergeTwoList(Node first, Node second) {
			    if(first == null && second == null) {
			      return null;
			    }
			    
			    Node tmp = new Node();
			    Node finalList = tmp;
			    while(first != null && second != null) {
			      if(first.data < second.data) {
			        tmp.next = first;
			        first = first.next;
			      } else  {
			        tmp.next = second;
			        second = second.next;
			      }
			      
			      tmp = tmp.next;
			    }
			    
			    tmp.next = (first != null) ? first : second;
			    
			    return finalList.next;
			  }
		
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();
		    
		    Node arr[] = new Node[5];
		    
		    arr[0] = a.getNewNode(1);
		    arr[0].next = a.getNewNode(3);
		    arr[0].next.next = a.getNewNode(5);
		    arr[0].next.next.next = a.getNewNode(7);
		    
		    arr[1] = a.getNewNode(2);
		    arr[1].next = a.getNewNode(4);
		    arr[1].next.next = a.getNewNode(6);
		    arr[1].next.next.next = a.getNewNode(8);
		    
		    arr[2] = a.getNewNode(0);
		    arr[2].next = a.getNewNode(9);
		    arr[2].next.next = a.getNewNode(10);
		    arr[2].next.next.next = a.getNewNode(11);
		    
		    arr[3] = a.getNewNode(12);
		    arr[3].next = a.getNewNode(14);
		    arr[3].next.next = a.getNewNode(16);
		    arr[3].next.next.next = a.getNewNode(18);
		    
		    arr[4] = a.getNewNode(0);
		    arr[4].next = a.getNewNode(19);
		    arr[4].next.next = a.getNewNode(20);
		    arr[4].next.next.next = a.getNewNode(31);
		    
		    Node mergedList = a.mergeKSortedLists(arr, arr.length - 1);
		    a.printList(mergedList);
		    
	  }
	}


53. COUNT PAIRS EQUAL TO GIVEN SUM IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public int getSumOfPairs(Node node1, Node node2, int sum) {
		    if(node1 == null || node2 == null) {
		      return 0;
		    }
		    
		    HashSet<Integer> s = new HashSet<>();
		    int countPairs = 0;
		    
		    while(node1 != null) {
		      s.add(node1.data);
		      node1 = node1.next;
		    }
		    
		    while(node2 != null) {
		      if(s.contains(sum - node2.data)) {
		        countPairs++;
		      }
		      
		      node2 = node2.next;
		    }
		    
		    return countPairs;
		  }
		
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    Node head1 = null;

		    head1 = a.insert(22, head1);
		    head1 = a.insert(3, head1);
		    head1 = a.insert(10, head1);
		    head1 = a.insert(13, head1);
		    head1 = a.insert(23, head1);

		    Node head2 = null;

		    head2 = a.insert(2, head2);
		    head2 = a.insert(14, head2);
		    head2 = a.insert(10, head2);
		    head2 = a.insert(27, head2);
		    head2 = a.insert(21, head2);

		    System.out.println(a.getSumOfPairs(head1, head2, 24));
	  }
	}


54. SUM OF ALL NODES OF LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public int getSumOfNodes(Node node) {
			    if(node == null) {
			      return 0;
			    }
			    
			    int sum = 0;
			    while(node != null) {
			      sum = sum + node.data;
			      node = node.next;
			    }
			    
			    return sum;
			  }
		 
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    Node head = null;

		    head = a.insert(22, head);
		    head = a.insert(3, head);
		    head = a.insert(10, head);
		    head = a.insert(13, head);
		    head = a.insert(23, head);
		    head = a.insert(6, head);

		    System.out.println(a.getSumOfNodes(head));
		    
	  }
	}


55. SUM OF LAST N NODES

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public int getSumOfLastNNodes(Node node, int n) {
			    if(node == null || n <= 0) {
			      return 0;
			    }
			    
			    int sum = 0;
			    Node head = node;
			    
			    while(node != null && n > 0) {
			      sum = sum + node.data;
			      node = node.next;
			      n--;
			    }
			    
			    if(node == null) {
			      if(n > 0) {
			        System.out.println("N is greater than total nodes");
			        return 0;
			      } else {
			        return sum;
			      }
			    }
			    
			    while(node.next != null) {
			      node = node.next;
			      head = head.next;
			    }
			    
			    head = head.next;
			    sum = 0;
			    
			    while(head != null) {
			      sum = sum + head.data;
			      head = head.next;
			    }
			    
			    return sum;
			  }
		 
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    Node head = null;

		    head = a.insert(22, head);
		    head = a.insert(3, head);
		    head = a.insert(10, head);
		    head = a.insert(13, head);
		    head = a.insert(23, head);
		    head = a.insert(6, head);

		    System.out.println(a.getSumOfLastNNodes(head, 2));
		    
	  }
	}


56. CHECK IF LENGTH OF NODE IS EVEN 

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public boolean ifEvenNodes(Node node) {
			    if(node == null) {
			      return true;
			    }
			    
			    Node temp = node;
			    
			    while(temp.next != null && temp.next.next != null) {
			      temp = temp.next.next;
			    }
			    
			    if(temp.next == null) {
			      return false;
			    } else {
			      return true;
			    }
			  }
		 
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    Node head = null;

		    head = a.insert(22, head);
		    head = a.insert(3, head);
		    head = a.insert(10, head);
		    head = a.insert(13, head);
		    head = a.insert(23, head);
		    head = a.insert(6, head);

		    boolean ifEvenNodes = a.ifEvenNodes(head);
		    System.out.println(ifEvenNodes);
	  }
	}


57. REMOVE EVERY KTH NODE IN LINKED LIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public Node removeEveryKthNode(Node node, int k) {
			    if(node == null || k <= 1) {
			      return null;
			    }
			    
			    if(node.next == null && k > 1) {
			      System.out.println("Not a valid case");
			      return node;
			    }
			    
			    Node head = node;
			    int i = 1;
			    
			    while(node != null && node.next != null) {
			      if(i % (k - 1) == 0) {
			        node.next = node.next.next;
			      }
			      
			      node = node.next;
			      i++;
			     
			    }
			    
			    return head;
			  }
			  
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    Node head = null;

		    head = a.insert(22, head);
		    head = a.insert(3, head);
		    head = a.insert(10, head);
		    head = a.insert(13, head);
		    head = a.insert(23, head);
		    head = a.insert(6, head);

		    head = a.removeEveryKthNode(head, 3);
		    a.printList(head);
	  }
	}


58. DELETE NODE WHEN HEAD IS NOT GIVEN

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		 public void deleteOnlyGivenNode(Node node) {
			    if(node == null || node.next == null) {
			      return;
			    }
			    
			    node.data = node.next.data;
			    node.next = node.next.next;
			  }
			  
	
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
		 
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    Node head = null;

		    head = a.insert(22, head);
		    head = a.insert(3, head);
		    head = a.insert(10, head);
		    head = a.insert(13, head);
		    head = a.insert(23, head);
		    head = a.insert(6, head);

		    a.deleteOnlyGivenNode(head.next.next.next);
		    a.printList(head);
	  }
	}

59. DELETE LAST OCCURENCE OF ELEMENT

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node deleteLastOccurrenceOfItem(Node node, int val) {
		    if (node == null) {
		      return null;
		    }

		    Node head, temp;

		    head = node;
		    temp = null;

		    while (node != null) {
		      if (node.data == val) {
		        temp = node;
		      }

		      node = node.next;
		    }

		    if (temp == null) {
		      return head;
		    }

		    if (temp == head) {
		      return head.next;
		    }

		    if (temp.next == null) {
		      node = head;
		      while (node.next.next != null) {
		        node = node.next;
		      }
		      node.next = null;
		      return head;
		    }

		    temp.data = temp.next.data;
		    temp.next = temp.next.next;

		    return head;
		  }
		
		
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    Node head = null;

		    head = a.insert(22, head);
		    head = a.insert(3, head);
		    head = a.insert(10, head);
		    head = a.insert(13, head);
		    head = a.insert(13, head);
		    head = a.insert(6, head);

		    head = a.deleteLastOccurrenceOfItem(head, 13);
		    a.printList(head);
	  }
	}


60. SORT LINKEDLIST ON ABSOLUTE VALUE

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node sortWhichIsSortedOnAbsoluteValue(Node head) {
		    if(head == null || head.next == null) {
		      return head;
		    }
		    
		    Node node, next, prev;
		    
		    node = next = head;
		    prev = null;
		    
		    if(head.data < 0) {
		      prev = node;
		      node = node.next;
		    }
		    
		    while(node != null) {
		      if(node.data < 0) {
		        prev.next = node.next;
		        next = node.next;
		        node.next = head;
		        head = node;
		        node = next;
		      } else {
		        prev = node;
		        node = node.next;  
		      }
		    }
		    
		    return head;
		  }
		
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
		
	  public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    Node head = null;

		    head = a.insert(1, head);
		    head = a.insert(-3, head);
		    head = a.insert(10, head);
		    head = a.insert(-13, head);
		    head = a.insert(-23, head);
		    head = a.insert(16, head);
		    
		    head = a.sortWhichIsSortedOnAbsoluteValue(head);
		    a.printList(head);
	  }
	}


61. MERGE TWO SORTED LINKEDLIST IN REVERSE ORDER

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  Node random;
	  int data;
	}

	class Linked {
		
		public Node mergeTwoSortedLinkedListReverseOrder(Node node1, Node node2) {
		    if(node1 == null && node2 == null) {
		      return null;
		    }
		    
		    Node mergedList, next;
		    mergedList = null;
		    
		    while(node1 != null && node2 != null) {
		      if(node1.data < node2.data) {
		        next = node1.next;
		        node1.next = mergedList;
		        mergedList = node1;
		        node1 = next;
		      } else {
		        next = node2.next;
		        node2.next = mergedList;
		        mergedList = node2;
		        node2 = next;
		      }
		    }

		    Node temp = node1 != null ? node1 : node2;
		    while(temp != null) {
		      next = temp.next;
		      temp.next = mergedList;
		      mergedList = temp;
		      temp = next;
		    }
		    
		    return mergedList;
		  }
		  
			
		
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
	
		public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }
		

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		
		    
		    Node head1 = null;
		    
		    head1 = a.insert(1, head1);
		    head1 = a.insert(5, head1);
		    head1 = a.insert(9, head1);
		    head1 = a.insert(10, head1);
		    
		    Node head2 = null;
		    head2 = a.insert(7, head2);
		    head2 = a.insert(18, head2);
		    
		    Node mergedInReverse = a.mergeTwoSortedLinkedListReverseOrder(head1, head2);
		    a.printList(mergedInReverse);
	  }
	}


62. MOVE ALL OCCURENCE TO END

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  Node random;
	  int data;
	}

	class Linked {
		
		 public Node moveAllOccurrenceOfElementToEnd(Node head, int value) {
			    if(head == null || head.next == null) {
			      return head;
			    }
			    
			    Node node, tail, prev, next, temp;
			    node = head;
			    prev = null;
			    
			    while(node.next != null) {
			      node = node.next;
			    }
			    
			    tail = node;
			    temp = tail;
			    node = head;
			    
			    while(node != temp) {
			      if(node.data == value && prev == null) {
			        next = node.next;
			        tail.next = node;
			        tail = tail.next;
			        node.next = null;
			        node = head = next;
			      } else if(node.data == value && prev != null) {
			        next = node.next;
			        prev.next = node.next;
			        tail.next = node;
			        tail = tail.next;
			        node.next = null;
			        node = next;
			      } else {
			        prev = node;
			        node = node.next;
			      }
			    }
			    
			    return head;
			  }
		  
			
		
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
	
		public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }
		

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    
		    Node head = null;
		    
		    head = a.insert(3, head);
		    head = a.insert(2, head);
		    head = a.insert(4, head);
		    head = a.insert(3, head);
		    head = a.insert(5, head);
		    head = a.insert(2, head);
		    
		    head = a.moveAllOccurrenceOfElementToEnd(head, 2);
		    a.printList(head);
	  }
	}


63. REARRANGE A LINKEDLIST IN ZIGZAG MANNER

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  Node random;
	  int data;
	}

	class Linked {
		
		 public Node rearrangeLinkedListZigzag(Node head) {
			    if(head == null || head.next == null) {
			      return head;
			    }
			    
			    Node node = head;
			    boolean flag = true;
			    
			    while(node.next != null) {
			      if(flag) {
			    	  
					        if(node.data > node.next.data) {
					          int t = node.data;
					          node.data = node.next.data;
					          node.next.data = t;
					        }
			        
			        flag = !flag;
			      }
			      
			      else {
			        if(node.data < node.next.data) {
			          int t = node.data;
			          node.data = node.next.data;
			          node.next.data = t;
			        }
			        flag = !flag;
			      }
			      
			      node = node.next;
			    }
			    
			    return head;
			  }
			  
			
		
		public Node insert(int key, Node node) {

		    if (node == null)
		      return getNewNode(key);
		    else
		      node.next = insert(key, node.next);

		    return node;
		  }
		
	
		public Node getNewNode(int key) {
		    Node a = new Node();
		    a.next = null;
		    a.data = key;
		    return a;
		  }
		

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    
		    Node head = null;
		    
		    head = a.insert(2, head);
		    head = a.insert(3, head);
		    head = a.insert(5, head);
		    head = a.insert(9, head);
		    head = a.insert(11, head);
		    head = a.insert(12, head);
		    
		    a.printList(head);
		    System.out.println();
		    
		    Node zigZagList = a.rearrangeLinkedListZigzag(head);
		    a.printList(zigZagList);
	  }
	}


64. FLATTEN A MULTILEVEL LINKEDLIST LEVELWISE

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  Node child;
	  int data;
	}

	class Linked {
		
		 public Node flattenEasy(Node node) {
			    if (node == null) {
			      return node;
			    }

			    Node start, end;
			    start = end = node;

			    while (end.next != null) {
			      end = end.next;
			    }

			    while (start != null) {
			      if (start.child != null) {
			        end.next = start.child;
			        end = end.next;

			        while (end.next != null) {
			          end = end.next;
			        }
			      }
			      start = start.next;
			    }

			    return node;
			  }
			  
			
		 public Node insert(Node node, int i) {
			    if (node == null) {
			      return createNewNode(i);
			    }

			    node.next = insert(node.next, i);

			    return node;
			  }
		 
		
		 public Node createList(int arr[]) {
			    Node node = null;

			    for (int i = 0; i < arr.length; i++) {
			      node = insert(node, arr[i]);
			    }

			    return node;
			  }
		 
	
		 public Node createNewNode(int i) {
			    Node a = new Node();
			    a.data = i;
			    a.next = null;
			    a.child = null;
			    return a;
			  }
		

	 
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	  
	}

	public class MyClass {

	  public static void main(String[] args) {

		  Linked a = new Linked();

		    
		  Node root1, root2, root3, root4, root5;

		    int arr1[] = new int[] { 1, 2, 3, 4, 5 };
		    int arr2[] = new int[] { 6, 7, 8 };
		    int arr3[] = new int[] { 9, 10 };
		    int arr4[] = new int[] { 11 };
		    int arr5[] = new int[] { 12 };

		    root1 = a.createList(arr1);
		    root2 = a.createList(arr2);
		    root3 = a.createList(arr3);
		    root4 = a.createList(arr4);
		    root5 = a.createList(arr5);

		    root1.child = root2;
		    root1.next.next.next.child = root3;
		    root2.next.child = root4;
		    root3.child = root5;

		    root1 = a.flattenEasy(root1);
		    a.printList(root1);
		    
	  }
	}


65. FLATTEN MULTILEVEL DEPTH WISE

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  Node down;
	  int data;
	}

	class Linked {
		
		public Node newNode(int i) {
		    Node a = new Node();
		    a.data = i;
		    a.next = null;
		    a.down = null;
		    return a;
		  }

		  Node prev;

		  public Node flattenEasy(Node node) {
		    if (node == null) {
		      return null;
		    }

		    prev = node;

		    Node next = node.next;

		    if (node.down != null) {
		      node.next = flattenEasy(node.down);
		    }

		    if (next != null) {
		      prev.next = flattenEasy(next);
		    }
		    return node;
		  }

		  public void printList(Node node) {
		    if (node == null) {
		      return;
		    }

		    while (node != null) {
		      System.out.print(node.data + " ");
		      node = node.next;
		    }
		  }

		}

		public class MyClass {

		  public static void main(String[] args) {

		    Linked a = new Linked();

		    Node head = a.newNode(1);

		    head.next = a.newNode(2);
		    head.next.next = a.newNode(3);
		    
		    head.next.down = a.newNode(7);
		    head.next.down.down = a.newNode(11);
		    head.next.down.down.down = a.newNode(13);
		    
		    head.next.down.next = a.newNode(8);
		    head.next.down.next.down = a.newNode(12);
		    
		    a.flattenEasy(head);
		    a.printList(head);
		    
	  }
	}





67. REARRANGE ARRANGE A LIST AROUND A GIVEN VALUE KEEPING ORDER SAME

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		

		public Node rearrangeLinkedListAroundGivelValueKeepOrder(Node head, int val) {
		    if(head == null || head.next == null) {
		      return head;
		    }
		    
		    Node lessValueStartNode, lessValueEndNode, givenValueStartNode,
		    givenValueEndNode, greaterValuesStartNode, greaterValuesEndNode;
		    
		    lessValueEndNode = lessValueStartNode = null;
		    givenValueStartNode = givenValueEndNode = null;
		    greaterValuesStartNode = greaterValuesEndNode = null;
		    
		    Node node = head;
		    
		    while(node != null) {
		      if(node.data < val) {
		        if(lessValueStartNode == null) {
		          lessValueStartNode = lessValueEndNode = node;
		        } else {
		          lessValueEndNode.next = node;
		          lessValueEndNode = node;
		        } 
		      } else if(node.data == val) {
		        if(givenValueStartNode == null) {
		          givenValueStartNode = givenValueEndNode = node;
		        } else {
		          givenValueEndNode.next = node;
		          givenValueEndNode = node;
		        }
		      } else {
		        if(greaterValuesStartNode == null) {
		          greaterValuesStartNode = greaterValuesEndNode = node;
		        } else {
		          greaterValuesEndNode.next = node;
		          greaterValuesEndNode = node;
		        }
		      }
		      node = node.next;
		    }
		    
		    lessValueEndNode.next = givenValueStartNode;
		    givenValueEndNode.next = greaterValuesStartNode;
		    
		    greaterValuesEndNode.next = null;
		    
		    return lessValueStartNode;
		  }
		  
			  

			  public Node getNewNode(int key) {
				    Node a = new Node();
				    a.next = null;
				    a.data = key;
				    return a;
				  }

				  /*
				   * insert method is used to insert the element in Linked List
				   */
				  public Node insert(int key, Node node) {

				    if (node == null)
				      return getNewNode(key);
				    else
				      node.next = insert(key, node.next);

				    return node;
				  }

				  /*
				   * It'll print the complete linked list
				   */
				  public void printList(Node node) {
				    if (node == null) {
				      return;
				    }

				    System.out.print(node.data + " ");
				    printList(node.next);
				  }
				}
	
	

		public class MyClass {

		  public static void main(String[] args) {

			  Linked a = new Linked();
			    
			    Node head = null;
			    
			    head = a.insert(22, head);
			    head = a.insert(3, head);
			    head = a.insert(1, head);
			    head = a.insert(2, head);
			    head = a.insert(5, head);
			    head = a.insert(3, head);
			    
			    head = a.rearrangeLinkedListAroundGivelValueKeepOrder(head, 3);
			    a.printList(head);
		    
	  }
	}


68. POINT TO NEXT GREATER ELEMENT USING ARBITRARY POINTER

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  Node random;
	  int data;
	}

	class LinkedList {

	  public Node arbitraryPointToNextGreaterElement(Node head) {
	    if (head == null || head.next == null) {
	      return head;
	    }

	    Node node = head;
	    while (node != null) {
	      node.random = node.next;
	      node = node.next;
	    }

	    sortLinkedList(head);

	    return head;
	  }

	  public Node sortLinkedList(Node node) {
	    if (node == null || node.random == null) {
	      return node;
	    }

	    Node middle = getMiddleNode(node);
	    Node second = middle.random;
	    middle.random = null;

	    return mergeTwoList(sortLinkedList(node), sortLinkedList(second));
	  }

	  public Node getMiddleNode(Node node) {
	    if (node == null || node.random == null) {
	      return node;
	    }

	    Node slow, fast;
	    slow = fast = node;

	    while (fast.random != null && fast.random.random != null) {
	      slow = slow.random;
	      fast = fast.random.random;
	    }

	    return slow;
	  }

	  public Node mergeTwoList(Node first, Node second) {
	    if (first == null && second == null) {
	      return null;
	    }

	    Node tmp = new Node();
	    Node finalList = tmp;
	    while (first != null && second != null) {
	      if (first.data < second.data) {
	        tmp.random = first;
	        first = first.random;
	      } else {
	        tmp.random = second;
	        second = second.random;
	      }

	      tmp = tmp.random;
	    }

	    tmp.random = (first != null) ? first : second;

	    return finalList.random;
	  }

	  public Node createNewNode(int i) {
	    Node a = new Node();
	    a.data = i;
	    a.next = null;
	    a.random = null;
	    return a;
	  }

	}
	

		public class MyClass {

		  public static void main(String[] args) {

			  LinkedList a = new LinkedList();

			    Node head = a.createNewNode(22);
			    head.next = a.createNewNode(5);
			    head.next.next = a.createNewNode(3);
			    head.next.next.next = a.createNewNode(15);
			    head.next.next.next.next = a.createNewNode(37);

			    head = a.arbitraryPointToNextGreaterElement(head);

		    
	  }
	}


69. ALTERNATE ODD AND EVEN IN LIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
	  /*
	   * It rearrange linked list in alternate odd-even nodes
	   */
	  public Node alternateOddEvenNode(Node head) {
	    if(head == null || head.next == null) {
	      return head;
	    }
	    
	    Node odd = new Node();
	    Node oddHead = odd;
	    Node even = new Node();
	    Node evenHead = even;
	    
	    Node node = head;
	    
	    while(node != null) {
	      if(node.data % 2 == 0) {
	        even.next = node;
	        even = even.next;
	      } else {
	        odd.next = node;
	        odd = odd.next;
	      }
	      
	      node = node.next;
	    }
	    
	    odd.next = null;
	    even.next = null;
	    
	    odd = oddHead.next;
	    even = evenHead.next;
	    
	    Node curr = new Node();
	    Node finalList = curr;
	    
	    while(odd != null || even != null) {
	      if(odd != null) {
	        curr.next = odd;
	        curr = curr.next;
	        odd = odd.next;
	      }
	      
	      if(even != null) {
	        curr.next = even;
	        curr = curr.next;
	        even = even.next;
	      }
	    }
	    
	    curr.next = odd != null ? odd : even;
	    
	    return finalList.next;
	  }
	  
	  /*
	   * getNewNode() method to generate a new node
	   */
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	  /*
	   * insert method is used to insert the element in Linked List
	   */
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	  /*
	   * It'll print the complete linked list
	   */
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {
		
	  public static void main(String[] args) {
	    Linked a = new Linked();

	    Node head = null;

	    head = a.insert(3, head);
	    head = a.insert(5, head);
	    head = a.insert(32, head);
	    head = a.insert(12, head);
	    head = a.insert(37, head);
	    
	    a.printList(head);
	    System.out.println();

	    head = a.alternateOddEvenNode(head);
	    
	    a.printList(head);
	  }
	}

70. CHECK IF LINKEDLIST OF STRING FORMS A PALINDROME

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
	  /*
	   * It rearrange linked list in alternate odd-even nodes
	   */
		public boolean checkIfLinkedListOfStringFormsPalindrome(Node head) {
		    if(head == null) {
		      return false;
		    }
		    
		    if(head.next == null) {
		      return true;
		    }
		    
		    Node middle = getMiddleNode(head);
		    middle.next = reverse(middle.next);
		    Node secondHalf = middle.next;
		    Node second = secondHalf;
		    middle.next = null;
		    
		    boolean ifPalidrome = true;
		    while(head != null && second != null) {
		      if(head.data != second.data) {
		        return false;
		      }
		      
		      head = head.next;
		      second = second.next;
		    }
		    
		    if(head != null && second == null) {
		      ifPalidrome = true;
		    }
		    
		    middle.next = reverse(secondHalf);
		    
		    return ifPalidrome;
		  }
		  
		  public Node getMiddleNode(Node node) {
		    if(node == null || node.next == null) {
		      return node;
		    }
		    
		    Node slow, fast;
		    slow = fast = node;
		    
		    while(fast.next != null && fast.next.next != null) {
		      slow = slow.next;
		      fast = fast.next.next;
		    }
		    
		    return slow;
		  }
		  
		  public Node reverse(Node node) {
		    if(node == null || node.next == null) {
		      return node;
		    }
		    
		    Node tmp = reverse(node.next);
		    node.next.next = node;
		    node.next = null;
		    
		    return tmp;
		  }
	  
	  /*
	   * getNewNode() method to generate a new node
	   */
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	  /*
	   * insert method is used to insert the element in Linked List
	   */
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	  /*
	   * It'll print the complete linked list
	   */
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {
		
	  public static void main(String[] args) {
	    Linked a = new Linked();

	    Node head = null;

	    head = a.insert('e', head);
	    head = a.insert('v', head);
	    head = a.insert('a', head);
	    head = a.insert('v', head);
	    head = a.insert('e', head);

	    System.out.println(a.checkIfLinkedListOfStringFormsPalindrome(head));
	    
	    
	  }
	}


71. COMPARE TWO STRINGS IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		 public int compareString(Node head1, Node head2) {
			    if(head1 == null && head2 == null) {
			      return 0;
			    }
			        
			    while(head1 != null && head2 != null) {
			      if(head1.data < head2.data) {
			        return -1;
			      } else if(head1.data > head2.data) {
			        return 1;
			      }
			      
			      head1 = head1.next;
			      head2 = head2.next;
			    }
			    
			    if(head1 == null && head2 == null) {
			      return 0;
			    }
			    
			    return head1 != null ? 1 : -1;
			  }
	  
	  /*
	   * getNewNode() method to generate a new node
	   */
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	  /*
	   * insert method is used to insert the element in Linked List
	   */
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	  /*
	   * It'll print the complete linked list
	   */
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {
		
	  public static void main(String[] args) {
	    Linked a = new Linked();

	    Node head1 = null;

	    head1 = a.insert('e', head1);
	    head1 = a.insert('v', head1);
	    head1 = a.insert('a', head1);
	    
	    
	    Node head2 = null;

	    head2 = a.insert('e', head2);
	    head2 = a.insert('v', head2);
	    head2 = a.insert('b', head2);
	    

	    System.out.println(a.compareString(head1, head2));
	    
	    
	  }
	}


72. LENGTH OF LONGEST PALINDROME

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public int lengthOfLongestPalindrome(Node node) {
		    if (node == null) {
		      return 0;
		    }
		    
		    if (node.next == null) {
		      return 1;
		    }

		    Node next, prev;
		    prev = next = null;
		    int result = 1;

		    while (node != null) {
		      next = node.next;
		      node.next = prev;

		      result = Math.max(result, 2 * getCommonElementCount(prev, next) + 1);
		      result = Math.max(result, 2 * getCommonElementCount(node, next));

		      prev = node;
		      node = next;
		    }

		    return result;
		  }

		  public int getCommonElementCount(Node a, Node b) {
		    int count = 0;

		    while (a != null && b != null) {
		      if (a.data == b.data) {
		        count++;
		      } else {
		        break;
		      }

		      a = a.next;
		      b = b.next;
		    }

		    return count;
		  }
		  
		  
	  /*
	   * getNewNode() method to generate a new node
	   */
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	  /*
	   * insert method is used to insert the element in Linked List
	   */
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	  /*
	   * It'll print the complete linked list
	   */
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {
		
	  public static void main(String[] args) {
	    Linked a = new Linked();

	    Node head = null;
	    
	    head = a.insert('e', head);
	    head = a.insert('v', head);
	    head = a.insert('a', head);
	    head = a.insert('a', head);
	    head = a.insert('v', head);
	    head = a.insert('e', head);

	    System.out.println(a.lengthOfLongestPalindrome(head));
	    
	    
	  }
	}


73. LARGEST/SMALLEST ELEMENT IN LINKEDLIST

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		int max = Integer.MIN_VALUE;
		  int min = Integer.MAX_VALUE;
		  
		  public void getMaxMin(Node node) {
		    if(node == null) {
		      System.out.println("List is blank");
		      return;
		    }
		    
		    while(node != null) {
		      if(node.data > max) {
		        max = node.data;
		      }
		      
		      if(node.data < min) {
		        min = node.data;
		      }
		      
		      node = node.next;
		    }
		  }
		  
		  
	  /*
	   * getNewNode() method to generate a new node
	   */
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	  /*
	   * insert method is used to insert the element in Linked List
	   */
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	  /*
	   * It'll print the complete linked list
	   */
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {
		
	  public static void main(String[] args) {
	    Linked a = new Linked();

	    Node head = null;
	    
	    head = a.insert(1, head);
	    head = a.insert(7, head);
	    head = a.insert(8, head);
	    head = a.insert(2, head);
	    head = a.insert(-1, head);
	    
	    a.getMaxMin(head);
	    
	    System.out.println("Max element: " + a.max);
	    System.out.println("Min element: " + a.min);
	    
	    
	  }
	}


74. DELETE LARGEST ELEMENT IN LINKEDLIST
1->7->80->4->15
package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node deleteLargestElement(Node node) {
		    if(node == null || node.next == null) {
		      return null;
		    }
		    
		    Node prevLargest, largest, head, prev; 
		    head = largest = node;
		    prevLargest = null;
		    prev = node;
		    node = node.next;
		    
		    while(node != null) {
		      if(node.data > largest.data) {
		        prevLargest = prev;
		        largest = node;
		      }
		      
		      prev = node;
		      node = node.next;
		    }
		    
		    if(head == largest) {
		      head = head.next;
		    } else {
		      prevLargest.next = largest.next;
		    }
		    
		    return head;
		  }
		  
		  
		  
	  /*
	   * getNewNode() method to generate a new node
	   */
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	  /*
	   * insert method is used to insert the element in Linked List
	   */
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	  /*
	   * It'll print the complete linked list
	   */
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {
		
	  public static void main(String[] args) {
	    Linked a = new Linked();

	    Node head = null;
	    
	    
	    head = a.insert(10, head);
	    head = a.insert(7, head);
	    head = a.insert(6, head);
	    head = a.insert(80, head);
	    head = a.insert(8, head);
	    head = a.insert(-1, head);
	    
	    a.printList(head);
	    System.out.println();
	    
	    head = a.deleteLargestElement(head);
	    
	    a.printList(head);
	    
	    
	  }
	}


75. REVERSE A LINKEDLIST FROM GIVEN POSITION

package automate;
import java.io.*;
import java.util.*;

class Node {
	  Node next;
	  int data;
	}

	class Linked {
		
		public Node reverseFromGivenPositions(Node node, int p, int q) {
		    if(node == null || node.next == null || p >= q || p < 1 || q < 1) {
		      return node;
		    }
		    
		    Node head = node;
		    Node prev = null;
		    
		    for(int i = 1; node != null && i < p; i++) {
		      prev = node;
		      node = node.next;
		    }
		    
		    if(node == null) {
		      return head;
		    }
		    
		    Node firstPartLastNode = prev;
		    Node secondPartStartNode = node;
		    Node next = null;
		        
		    for(int i = 0; node != null && i <= q - p; i++) {
		      next = node.next;
		      node.next = prev;
		      prev = node;
		      node = next;
		    }
		  
		    if(p != 1) {
		      firstPartLastNode.next = prev;
		    }
		    
		    secondPartStartNode.next = node;
		    
		    return p == 1 ? prev : head;
		    
		  }
		  
		  
		  
	  /*
	   * getNewNode() method to generate a new node
	   */
	  public Node getNewNode(int key) {
	    Node a = new Node();
	    a.next = null;
	    a.data = key;
	    return a;
	  }

	  /*
	   * insert method is used to insert the element in Linked List
	   */
	  public Node insert(int key, Node node) {

	    if (node == null)
	      return getNewNode(key);
	    else
	      node.next = insert(key, node.next);

	    return node;
	  }

	  /*
	   * It'll print the complete linked list
	   */
	  public void printList(Node node) {
	    if (node == null) {
	      return;
	    }

	    System.out.print(node.data + " ");
	    printList(node.next);
	  }
	}

	public class MyClass {
		
	  public static void main(String[] args) {
	    Linked a = new Linked();

	    Node head = null;
	    
	    
	    head = a.insert(12, head);
	    head = a.insert(99, head);
	    head = a.insert(8, head);
	    head = a.insert(39, head);
	    head = a.insert(5, head);
	    head = a.insert(16, head);
	    head = a.insert(20, head);
	    
	    a.printList(head);
	    System.out.println();
	    
	    head = a.reverseFromGivenPositions(head, 2, 5);

	    a.printList(head);
	    
	    
	  }
	}



76. MERGE LINKEDLIST


package linkedlist;

class Node {
  Node next;
  int data;
}

class Linked {
  /*
   * It'll merge two linked list
   */
  public Node mergeList(Node a, Node b) {
    return merge(mergeSort(a), mergeSort(b));
  }
  
  /*
   * It'll sort linked list
   */
  public Node mergeSort(Node node) {
    if(node == null || node.next == null) {
      return node;
    }
    
    Node middle = middleNode(node);
    Node secondHalf = middle.next;
    middle.next = null;
    
    return merge(mergeSort(node), mergeSort(secondHalf));
  }
  
  /*
   * It'll find the middle node of the linked list
   */
  public Node middleNode(Node node) {
    if(node == null) {
      return null;
    }
    
    Node a = node;
    Node b = node.next;
    
    while(b != null && b.next != null) {
      a = a.next;
      b = b.next.next;
    }
    
    return a;
  }
  
  /*
   * It'll merge both linked list
   */
  public Node merge(Node a, Node b) {
    Node temp = new Node();
    Node finalList = temp;
    
    while(a != null && b != null) {
      if(a.data < b.data) {
        temp.next = a;
        a = a.next;
      } else {
        temp.next = b;
        b = b.next;
      }
      temp = temp.next;
    }
    temp.next = (a == null) ? b : a;
    return finalList.next;
  }
  
  /*
   * getNewNode() method to generate a new node
   */
  public Node getNewNode(int key) {
    Node a = new Node();
    a.next = null;
    a.data = key;
    return a;
  }

  /*
   * insert method is used to insert the element in Linked List
   */
  public Node insert(int key, Node node) {

    if (node == null)
      return getNewNode(key);
    else
      node.next = insert(key, node.next);

    return node;
  }

  /*
   * It'll print the complete linked list
   */
  public void printList(Node node) {
    if (node == null) {
      return;
    }

    System.out.print(node.data + " ");
    printList(node.next);
  }
}

public class LinkedListApp {

  public static void main(String[] args) {

    Node head1 = null;
    Linked a = new Linked();

    head1 = a.insert(12, head1);
    head1 = a.insert(9, head1);
    head1 = a.insert(37, head1);
    
    Node head2 = null;
    head2 = a.insert(45, head2);
    head2 = a.insert(8, head2);
    
    a.printList(head1);
    System.out.println();
    
    a.printList(head2);
    System.out.println();
    
    Node mergeList = a.mergeList(head1, head2);
    a.printList(mergeList);
    
  }
}