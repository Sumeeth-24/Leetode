LONGEST VALID PARENTHESIS

Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".

class Solution {
    public int longestValidParentheses(String s) {
        if(s.length() < 2 || s == null) return 0;
        
        Stack<Integer> st = new Stack<>();
        
        for(int i=0; i<s.length(); i++){
            
            if(s.charAt(i) == '('){
                st.push(i);
            }            
            else{
                
                if(!st.isEmpty() && s.charAt(st.peek()) == '('){
                st.pop();
                }
                else {
                st.push(i);
                }
           }
       }
        
        int maxLen = 0;
        int endTerminal = s.length();
        
        while(st.size() > 0){
            int startTerminal = st.pop();
            maxLen = Math.max(maxLen, endTerminal - startTerminal - 1);
            endTerminal = startTerminal;
        }
        
        return Math.max(maxLen, endTerminal);
    }
}

MIN INSERTION TO BALANCE A PARENTHESIS STRING

class Solution {
    public int minInsertions(String S) {
           Stack<Character> st = new Stack<>();
           int insertionsNeeded = 0;
        for(int i = 0; i < S.length(); i++){
            char ch = S.charAt(i);
            
            if(ch == '('){
                if(st.isEmpty()){
                    st.push(ch);
                }
                else {
                    if(st.peek() == '('){
                        st.push(ch);                    // "(("
                    }else {
                        insertionsNeeded++;            //if ch == '(' && st top = () => ()) => ( 
                        st.pop();
                        st.pop();
                        st.push(ch);
                    }
                }
            }
            
            else {
                if(st.isEmpty()){
                    insertionsNeeded++;
                    st.push('(');
                    st.push(ch);
                }
                else {
                    if(st.peek() == '('){    // ()
                        st.push(ch);
                    }
                    else {
                        st.pop();     // () => ""
                        st.pop();    
                    }
                }
            }
        }
            
            if(st.isEmpty()){
               return insertionsNeeded;
            }
            else{
                while(!st.isEmpty()){
                    char ch = st.pop();
                    if(ch == '('){
                        insertionsNeeded += 2;
                    }
                    else {
                        insertionsNeeded += 1;
                        st.pop();
                    }
                }
                return insertionsNeeded;
            }
            
           
    }
}


WORD LADDER

class Solution {
    //TC : O(n*n)/O(v+E)
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordSet = new HashSet<>();
        for(String el : wordList){
            wordSet.add(el);
        }
        
        wordSet.add(beginWord);
        
        Map<String, List<String>> map = new HashMap<>();
        
        buildGraph(map, wordSet);
        
        Set<String> visited = new HashSet<String>();
        
        Queue<String> qu = new LinkedList<>();
        
        qu.offer(beginWord);
        
        int level = 0;
        
        while(!qu.isEmpty()){
            int size = qu.size();
            
            while(size-- > 0){
                String head = qu.poll();
                if(head.equals(endWord)){
                    return level + 1;
                }
                
                if(visited.contains(head)){
                    continue;
                }
                
                for(String connection : map.getOrDefault(head, new ArrayList<>())){
                    if(!visited.contains(connection)){
                        qu.offer(connection);
                    }
                }
                visited.add(head);
            }
            level++;
        }
        
        if(visited.contains(endWord)){
            return level;
        }
        else {
            return 0;
        }
    }
    
    
    private void buildGraph(Map<String, List<String>> map, Set<String> wordSet){
        
        for(String el : wordSet){
            for(String innerEl : wordSet){

                if(el.equals(innerEl)){
                    continue;
                }
                else {
                    if(stringsdifferbyone(el, innerEl)){
                        // el to innerEl
                        List<String> connections = map.getOrDefault(el, new ArrayList<>());
                        connections.add(innerEl);
                        map.put(el, connections);
                        
                        // innerEl to el
                        List<String> connectionsIEL = map.getOrDefault(innerEl, new ArrayList<>());
                        connectionsIEL.add(el);
                        map.put(innerEl, connectionsIEL);                       
                    }
                }
            }
        }
    }
    
    private boolean stringsdifferbyone(String a, String b){
        if(a.length() != b.length()){
            return false;
        }
        else {
            boolean foundOnedifference = false;
            for(int i=0; i< a.length(); i++){
                char achar = a.charAt(i);
                char bchar = b.charAt(i);
                
                if(achar != bchar){
                    if(foundOnedifference){
                        return false;
                    }
                    foundOnedifference = true;
                }
            }
        }
        return true;
    }
}


KEYS AND ROOMS
[[1, 3], [3, 0, 1], [2], [0]] ans = false
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
          boolean[] visitedRooms = new boolean[rooms.size()]; // Boolean array to keep track which Room is visited
        visitedRooms[0] = true;
		
         Deque<Integer> queue = new ArrayDeque<Integer>();
        queue.add(0); // Added the first room in the queue
		
        while (!queue.isEmpty()) {
            int size = queue.size(); // This is required to determine the number of elements in every level
            for (int i=1; i<= size; i++) {
                int currentRoom = queue.poll();
                for (int room : rooms.get(currentRoom)) {
                    if (!visitedRooms[room]) { // If we haven't visited the room, making the room visited after obtaining that room's key, as if we've the key then we can definitely visit the room
                        visitedRooms[room] = true;
                        queue.add(room); // Adding the room to queue to visit and obtain the keys of this room
                    }
                }
            }
        }
        
        boolean canVisitAllRooms = true;
        for (boolean isVisitedRoom : visitedRooms) {
            if (!isVisitedRoom) { // Checking if any room isn't visited, then we can't visit all rooms
                canVisitAllRooms = false;
                break;
            }
        }
        
        return canVisitAllRooms;
    }
}

DECODE STRING
2[abc]3[cd]ef  ans = abcabccdcdcdef

class Solution {
    public String decodeString(String s) {
        if (s == null || s.length() == 0) {
        return s;
    }

    Stack<Integer> countStack = new Stack<>();  // freq
    Stack<String> resultStack = new Stack<>();
    char[] strArr = s.toCharArray();
    int count = 0;  // k
    String curResult = "";
    for (int i = 0; i < s.length(); i++) {
        //calculate repeat number
        if (Character.isDigit(strArr[i])) {
            count = count * 10 + (strArr[i] - '0');
        }
        //push previous decoded string into stack
        else if (strArr[i] == '[') {
            countStack.push(count);
            resultStack.push(curResult);
            count = 0;
            curResult = "";
        }
        //start to decode current string
        else if (strArr[i] == ']') {
            int repeat = countStack.pop();
            StringBuilder temp = new StringBuilder(resultStack.pop());
            for (int j = 0; j < repeat; j++) {
                temp.append(curResult);
            }
            curResult = temp.toString();
        }
        //normal character, concat to current string, preparing for decoding
        else {
            curResult += strArr[i];
        }
    }
    return curResult;
    }
}


                                                            STACKS AND QUEUES
1. NEXT GREATER ELEMENT ON RIGHT
                                                 
import java.io.*;
import java.util.*;

public class MyClass {

		  public static void display(int[] a) {
		    StringBuilder sb = new StringBuilder();

		    for (int val : a) {
		      sb.append(val + "\n");
		    }
		    System.out.println(sb);
		  }

		  public static void main(String[] args) throws Exception {
		   Scanner t = new Scanner(System.in);
	           System.out.println("Enter the number");
		    int n = t.nextInt();
		    int[] a = new int[n];
		    System.out.println("Enter the value");
		    for (int i = 0; i < n; i++) {
		      a[i] = t.nextInt();
		    }

		    int[] nge = solve(a);
		    display(nge);
		  }

		  public static int[] solve(int[] arr) {
			    System.out.println("Enter the number");
		    int[] nge = new int[arr.length];

		    Stack<Integer> st = new Stack<>();

		    st.push(0);
		    for(int i = 1; i < arr.length; i++){
		      while(st.size() > 0 && arr[i] > arr[st.peek()]){
                         int pos = st.peek();
                         nge[pos] = arr[i];
		             st.pop();
		         }  
                        st.push(i);   
		      }
                      while(st.size() > 0){
                       int pos = st.peek();
                         nge[pos] = -1;
                         st.pop();
                     }
		    return nge;
		  }

		}



1 B) NEXT GREATER ELEMENT II

import java.io.*;
import java.util.*;

public class Main {
    public static int[] nextGreaterElementII(int[] nums) {
        Stack<Integer> st = new Stack<>();
        
        int n = nums.length;
        int ans[] = new int[n];
        
        for(int i=n-2; i>=0;i--){
            
            while(st.size()>0&& st.peek() <= nums[i])
                st.pop();
             }
            st.push(nums[i]);
        }

        int ans[] = new int[n];
        
        for(int i=n-1; i>=0; i--){

            while(st.size()>0 && st.peek()<=nums[i]) st.pop();
            
            if(st.isEmpty())
                ans[i] = -1;
            else ans[i] = st.peek();
            
            st.push(nums[i]);
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(read.readLine());
        int nums[] = new int[n];
        for(int i=0;i<n;i++){
            nums[i] = Integer.parseInt(read.readLine());
        }
        
        int ans[] = nextGreaterElementII(nums);

        n = ans.length;

        System.out.println(n);
        for(int e: ans){
            System.out.println(e);
        }
        
    }
}
                        
                        
                        
                        
DAILY TEMPERATURE

Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]

class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
         Stack<Integer> stack = new Stack<>();
    int[] ret = new int[temperatures.length];
        
    for(int i = temperatures.length - 1; i >= 0 ; i--) {
        while(!stack.isEmpty() && temperatures[i] >= temperatures[stack.peek()]) {
           stack.pop();  
        }
        
        if(stack.isEmpty()){
            ret[i] = 0;
        } else {
            ret[i] =stack.peek() - i ;
        }
        stack.push(i);
    }
    return ret;
    }
}                        
                        
                        
                        

2. CELEBRITY PROBLEM
import java.io.*;
import java.util.*;

public class MyClass {

	 public static void main(String[] args) throws Exception {
			     Scanner t = new Scanner(System.in);
			     System.out.println("Enter the value");
			        int n = t.nextInt();
			        int[][] arr = new int[n][n];
			        System.out.println("Enter the number");

			        for (int j = 0; j < n; j++) {
			            for (int k = 0; k < n; k++) {
			                arr[j][k] = t.nextInt();
			            }
			        }

			        findCelebrity(arr);
			    }

			    public static void findCelebrity(int[][] arr){
			        // if a celebrity is there print it's index (not position), if there is not then print "none"
			        Stack<Integer> st = new Stack<>();
			        for(int i = 0; i < arr.length; i++){
			           st.push(i);
			        }

			        while(st.size() >= 2){
			           int i = st.pop();
			           int j = st.pop();

			           if(arr[i][j] == 1){
			        	   // i knows j-> i is not celebrity
			               st.push(j);
			           } else {
			        	   // if i does not know j-> j is not celebrity
			            st.push(i);
			           }
			        }

			        int pot = st.pop();
			        boolean flag = true;
			        for(int i = 0; i < arr.length; i++){
			           if(i != pot){
			              if(arr[i][pot] == 0 || arr[pot][i] == 1){
			                 flag = false;
			                 break;
			              }
			           }
			        }

			        if(flag){
			           System.out.println(pot);
			        } else {
			           System.out.println("none");
			        }
			    }
}


3. DUPLICATE BRACKETS
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner t = new Scanner(System.in);
        System.out.println("Enter the string");
        String str = t.nextLine();
        
        Stack<Character> st = new Stack<>();
        for(int i = 0; i < str.length(); i++){
            char ch = str.charAt(i);
            if(ch == ')'){
                if(st.peek() == '('){
                    System.out.println(true);
                    return;
                } else {
                    while(st.peek() != '('){
                        st.pop();
                    }
                    st.pop();
                }
            } else {
                st.push(ch);
            }
        }

        System.out.println(false);
    }
}


4. BALANCED BRACKET
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();

        Stack<Character> st = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (ch == '(' || ch == '{' || ch == '[') {
                st.push(ch);
            } else if (ch == ')') {
                if (st.size() == 0 || st.peek() != '(') {
                    System.out.println(false);
                    return;
                } else {
                    st.pop();
                }
            } else if (ch == '}') {
                if (st.size() == 0 || st.peek() != '{') {
                    System.out.println(false);
                    return;
                } else {
                    st.pop();
                }
            } else if (ch == ']') {
                if (st.size() == 0 || st.peek() != '[') {
                    System.out.println(false);
                    return;
                } else {
                    st.pop();
                }
            } else {
                // nothing
            }
        }

        if (st.size() == 0) {
            System.out.println(true);
        } else {
            System.out.println(false);
        }
    }
}


5. STOCK SPAN
package automate;

                                                 
import java.io.*;
import java.util.*;

public class MyClass {

	 public static void display(int[] a) {
			    
			    
			            StringBuilder sb = new StringBuilder();

			            for (int val : a) {
			              sb.append(val + "\n");
			            }
			            System.out.println(sb);
			          }

			          public static void main(String[] args) throws Exception {
			        	  Scanner t = new Scanner(System.in);

			        	  System.out.println("Enter the value");
					        int n = t.nextInt();
			            int[] a = new int[n];
			            System.out.println("Enter the value");
			            for (int i = 0; i < n; i++) {
			              a[i] = t.nextInt();
			            }

			            int[] nge = solve(a);
			            display(nge);
			          }

			          public static int[] solve(int[] arr) {
			            int[] span = new int[arr.length];

			            Stack<Integer> st = new Stack<>();
			            st.push(0);
			            span[0] = 1;

			            for (int i = 1; i < arr.length; i++) {
			              while(st.size() > 0 && arr[i] >= arr[st.peek()]){
			                st.pop();
			              }

			              if(st.size() == 0){
			                span[i] = i + 1;
			              } else {
			                span[i] = i - st.peek();
			              }

			              st.push(i);
			            }

			            return span;
			          }
}


6. LARGEST AREA HISTOGRAM


class Solution {
    public int largestRectangleArea(int[] heights) {
         Stack<Integer> st = new Stack<>();
        int max =0;
        
        st.push(-1);
        
        for(int i=0;i<=heights.length;i++){
            int val = i==heights.length? 0:heights[i];
            
            while(st.peek() != -1 && heights[st.peek()] >= val){
                int rm = i;
                int h = heights[st.pop()];
                int lm = st.peek();
                max = Math.max(max, h*(rm- lm-1));
            }
            st.push(i);
        }
        
        return max;
    }
}


8. SLIDING WINDOW

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        
			int n = nums.length;
            int[] r = new int[n-k+1];
            int ri = 0;
        
        //store index
        Deque<Integer> q = new ArrayDeque<>();
        for(int i = 0; i < nums.length; i++){
            // remove numbers out of range k
            if(!q.isEmpty() && q.peek() == i - k){
                q.poll();
            }
            
            //remove smaller numbers in k range as they are useless
            while(!q.isEmpty() && nums[q.peekLast()] < nums[i]){
                q.pollLast();
            }
            
            q.offer(i);
            if(i >= k - 1) {
                r[ri++] = nums[q.peek()];
            }
        }
        return r;
            
}
}            


9. INFIX EVALUATION
package automate;

                                                 
import java.io.*;
import java.util.*;

public class MyClass {

	
	 public static void main(String[] args) throws Exception {
		    Scanner t = new Scanner(System.in);
                    System.out.println("Enter the strings");
		    String exp = t.nextLine();

		    // code
		    Stack<Integer> operands = new Stack<>();
		    Stack<Character> operators = new Stack<>();

		    for (int i = 0; i < exp.length(); i++) {
		      char ch = exp.charAt(i);

		      if (ch == '(') {
		        operators.push(ch);
		      } else if (Character.isDigit(ch)) {
		        operands.push(ch - '0');
		      } else if (ch == ')') {
		        while (operators.size() > 0 && operators.peek() != '(') {
                           char op = operators.pop();
		          int val2 = operands.pop();
		          int val1 = operands.pop();
		          int opval = operation(val1, val2, op);
		          operands.push(opval);
		        }

		        if (operators.size() > 0) {
		          operators.pop();
		        }
		      } else if  (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
		        while (operators.size() > 0 && operators.peek() != '(' && 
		               precedence(ch) <= precedence(operators.peek())) {
		          int val2 = operands.pop();
		          int val1 = operands.pop();
		          char op = operators.pop();

		          int opval = operation(val1, val2, op);
		          operands.push(opval);
		        }

		        operators.push(ch);
		      } 
		    }

		    while (operators.size() > 0) {
		      int val2 = operands.pop();
		      int val1 = operands.pop();
		      char op = operators.pop();

		      int opval = operation(val1, val2, op);
		      operands.push(opval);
		    }

		    int val = operands.pop();
		    System.out.println(val);
		  }

		  public static int precedence(char op){
		    if(op == '+'){
		      return 1;
		    } else if(op == '-'){
		      return 1;
		    } else if(op == '*'){
		      return 2;
		    } else {
		      return 2;
		    }
		  }

		  public static int operation(int val1, int val2, char op){
		    if(op == '+'){
		      return val1 + val2;
		    } else if(op == '-'){
		      return val1 - val2;
		    } else if(op == '*'){
		      return val1 * val2;
		    } else {
		      return val1 / val2;
		    }
		  }
		} 

  
10. INFIX CONVERSION
import java.io.*;
import java.util.*;

public class MyClass {

	 public static void main(String[] arg){
		   Scanner t = new Scanner(System.in);
		   System.out.println("Enter the value");
		   String exp = t.nextLine();
		   
		   Stack<String> postfix = new Stack<>();
		    Stack<String> prefix = new Stack<>();
		    Stack<Character> operators = new Stack<>();

		    for (int i = 0; i < exp.length(); i++) {
		      char ch = exp.charAt(i);

		      if (ch == '(') {
		        operators.push(ch);
		      } else if ((ch >='0' && ch <= '9') || (ch >='a' && ch <= 'z') || (ch >='A' && ch <= 'Z'))  {
		        postfix.push(ch + "");
		        prefix.push(ch + "");
		      } else if (ch == ')') {
			        while (operators.size() > 0 && operators.peek() != '(') {
				          char op = operators.pop();

				          String postval2 = postfix.pop();
				          String postval1 = postfix.pop();
				          postfix.push(postval1 + postval2 + op);

				          String preval2 = prefix.pop();
				          String preval1 = prefix.pop();
				          prefix.push(op + preval1 + preval2);
				        }
				         operators.pop(); 
		      }      else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
		        while (operators.size() > 0 && operators.peek() != '(' && precedence(ch) <= precedence(operators.peek())) {
		          char op = operators.pop();

		          String postval2 = postfix.pop();
		          String postval1 = postfix.pop();
		          postfix.push(postval1 + postval2 + op);

		          String preval2 = prefix.pop();
		          String preval1 = prefix.pop();
		          prefix.push(op + preval1 + preval2);
		        }

		        operators.push(ch);
		      } 
		        }
		    while (operators.size() > 0) {
			      char op = operators.pop();

			      String postval2 = postfix.pop();
			      String postval1 = postfix.pop();
			      postfix.push(postval1 + postval2 + op);

			      String preval2 = prefix.pop();
			      String preval1 = prefix.pop();
			      prefix.push(op + preval1 + preval2);
			    }
		    
		    System.out.println(postfix.peek());
		    System.out.println(prefix.peek());
		  
		      }
	 

		  public static int precedence(char op) {
		    if (op == '+') {
		      return 1;
		    } else if (op == '-') {
		      return 1;
		    } else if (op == '*') {
		      return 2;
		    } else {
		      return 2;
		    }
		  }
		  }

11. POSTFIX EVALUATION AND CONVERSION
package automate;


import java.io.*;
import java.util.*;

public class MyClass {

	 public static void main(String[] arg){
		   Scanner t = new Scanner(System.in);
		   System.out.println("Enter the value");
		   String exp = t.nextLine();
		   

		    Stack<String> prefix = new Stack<>();
		    Stack<Integer> vstack = new Stack<>();
		    Stack<String> infix = new Stack<>();
		 

		    for (int i = 0; i < exp.length(); i++) {
		      char ch = exp.charAt(i);

		      if (ch == '-' || ch == '+' || ch == '*' || ch == '/') {
		        int v2 = vstack.pop();
		        int v1 = vstack.pop();
		        int val = operation(v1, v2, ch);
		        vstack.push(val);

		        String inv2 = infix.pop();
		        String inv1 = infix.pop();
		        String inv = "(" + inv1 + ch + inv2 + ")";
		        infix.push(inv);

		        String prev2 = prefix.pop();
		        String prev1 = prefix.pop();
		        String prev = ch + prev1 + prev2;
		        prefix.push(prev);
		      } else {
		        vstack.push(ch - '0');
		        infix.push(ch + "");
		        prefix.push(ch + "");
		      }
		    }

		    System.out.println(vstack.pop());
		    System.out.println(infix.pop());
		    System.out.println(prefix.pop());
		  }

		  public static int operation(int v1, int v2, char op) {
		    if (op == '+') {
		      return v1 + v2;
		    } else if (op == '-') {
		      return v1 - v2;
		    } else if (op == '*') {
		      return v1 * v2;
		    } else if (op == '/') {
		      return v1 / v2;
		    } else {
		      return 0;
		    }
		  }
}

12. PREFIX EVALUATION AND CONVERSION
package automate;


import java.io.*;
import java.util.*;

public class MyClass {

	 public static void main(String[] arg){
		   Scanner t = new Scanner(System.in);
		   System.out.println("Enter the value");
		   String exp = t.nextLine();
		   

		   Stack<Integer> vstack = new Stack<>();
		    Stack<String> infix = new Stack<>();
		    Stack<String> postfix = new Stack<>();

		    for (int i = exp.length() - 1; i >= 0; i--) {
		      char ch = exp.charAt(i);

		      if (ch == '-' || ch == '+' || ch == '*' || ch == '/') {
		        int v1 = vstack.pop();
		        int v2 = vstack.pop();
		        int val = operation(v1, v2, ch);
		        vstack.push(val);

		        String inv1 = infix.pop();
		        String inv2 = infix.pop();
		        String inv = "(" + inv1 + ch + inv2 + ")";
		        infix.push(inv);

		        String postv1 = postfix.pop();
		        String postv2 = postfix.pop();
		        String postv = postv1 + postv2 + ch;
		        postfix.push(postv);
		      } else {
		        vstack.push(ch - '0');
		        infix.push(ch + "");
		        postfix.push(ch + "");
		      }
		    }

		    System.out.println(vstack.pop());
		    System.out.println(infix.pop());
		    System.out.println(postfix.pop());
		  }

		  public static int operation(int v1, int v2, char op) {
		    if (op == '+') {
		      return v1 + v2;
		    } else if (op == '-') {
		      return v1 - v2;
		    } else if (op == '*') {
		      return v1 * v2;
		    } else if (op == '/') {
		      return v1 / v2;
		    } else {
		      return 0;
		    }
		  }
} 

13. MERGE OVERLAPPING


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.

public class Main{
    public static int[][] mergeIntervals(int Intervals[][]){
        Arrays.sort(Intervals, (a,b) -> Integer.compare(a[0], b[0]));

        ArrayList<int[]> res = new ArrayList<>();

        for(int interval[] : Intervals){
            if(res.size() == 0){
                res.add(interval);
            }else{
                int prevInterval[] = res.get(res.size()-1);
                if(interval[0] < prevInterval[1]){
                    prevInterval[1] = Math.max(prevInterval[1],interval[1]);
                }else{
                    res.add(interval);
                }
            }
        }

        return res.toArray(new int[res.size()][]);
    }
    public static void main(String args[]){
        Scanner scn = new Scanner(System.in);

        // Input Format
        int n = scn.nextInt();
        int input[][] = new int[n][2];

        for(int i = 0 ; i <  n ; i++){
            int sp = scn.nextInt();
            int ep = scn.nextInt();

            input[i][0] = sp;
            input[i][1] = ep;
        }

        // Output Format
        int [][]output = mergeIntervals(input);

        System.out.print("[");
        for(int arr[] : output){
            System.out.print(Arrays.toString(arr));
        }
        System.out.println("]");
    }
}


14. SMALLEST NUMBER FOLLOWING PATTERN

import java.io.*;
import java.util.*;

public class MyClass {

	 public static void main(String[] args) throws Exception{
                  Scanner t = new Scanner(System.in);
		  System.out.println("Enter the value");
	    
		    String str = t.nextLine();

		    // code
		    Stack<Integer> st = new Stack<>();

		    int num = 1;
		    for (int i = 0; i < str.length(); i++) {
		      char ch = str.charAt(i);

		      if (ch == 'd') {
		        st.push(num);
		        num++;
		      } else {
		        st.push(num);
		        num++;
		        
		        while (st.size() > 0) {
		          System.out.print(st.pop());
		        }
		      }
		    }

		    st.push(num);
		    while (st.size() > 0) {
		      System.out.print(st.pop());
		    }
		  }
		}




	                        

15. ONLINE STOCK SPAN

class StockSpanner {
    
    static class Pair {
        int price;
        int index;
    }
    
    Stack<Pair> st;
    int time = 0;

    public StockSpanner() {
        st = new Stack<>();
        Pair base = new Pair();
        base.price = 1000000;
        base.index = -1;
        st.push(base);
    }
    
    public int next(int price) {
        Pair p = new Pair();
        p.price = price;
        p.index = time;
        time++;
        
        while(st.peek().price <= p.price){
            st.pop();
        }
        int ans = p.index - st.peek().index;
        
        st.push(p);
        
        return ans;
    }
}
	                    


	                    


16. REMOVE K DIGITS

class Solution {
    public String removeKdigits(String num, int k) {
        
        if(k >= num.length())
            return "0";
        
        if(k == 0)
            return num;
        
        Stack<Character> st = new Stack<>();
        
        for(int i = 0; i < num.length(); i++){
            char c = num.charAt(i);
            
            while(!st.isEmpty() && (k > 0) && (st.peek() > c)){
                st.pop();
                k--;
            }
            
            if(!st.isEmpty() || (c != '0')){
                st.push(c);
            }
        }
        
        // will also help in strictly ascending order
        while(!st.isEmpty() && (k > 0)){
            k--;
            st.pop();
        }

   char ans[] = new char[st.size()];
        int h = ans.length - 1;
        while(h >= 0) ans[h--] = st.pop();
        
        int d = 0;
        while(d < ans.length && ans[d] == '0') d++;
        
        StringBuilder sb = new StringBuilder();
        
        while(d < ans.length) sb.append(ans[d++]);
        
        if(sb.length() == 0) sb.append('0');
        
        return sb.toString();
		                        


	                    

17. REVERSE SUBSTRING INSIDE PARENTHESIS

class Solution {
    public String reverseParentheses(String s) {
        Stack<Character> st = new Stack<>();
        
        for(int i = 0; i < s.length(); i++){
            
            if(s.charAt(i) == ')'){
                Queue<Character> q = new LinkedList();
                
                while(st.peek() != '('){
                    q.add(st.pop());
                }
                st.pop();
                while(q.size() > 0){
                    st.push(q.remove());
                }
            }else {
                // ( abc
                st.push(s.charAt(i));
            }
        }
        
        char []ans = new char[st.size()];
        int i = ans.length - 1;
        while(i >= 0){
            ans[i] = st.pop();
            i--;
        }
        
        return new String(ans);
    }
}




18. VALIDATE STACK SEQUENCE
Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
Output: true
Explanation: We might do the following sequence:
push(1), push(2), push(3), push(4),
pop() -> 4,
push(5),
pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        
        Stack<Integer> st = new Stack<>();
        
        int j = 0;
        
        for(int e : pushed){
            st.push(e);
            while(st.size() > 0 && st.peek() == popped[j]){
                st.pop();
                j++;
            }
        }
        
        return j == popped.length ? true : false;
    }
}



19. MINIMUM ADD TO MAKE PARENTHESIS VALID

Input: s = "()))(("
Output: 4

class Solution {
    public int minAddToMakeValid(String S) {
        Stack<Character> st = new Stack<>();
        
        for(int i = 0; i < S.length(); i++){
            char ch = S.charAt(i);
            
            if(ch == '('){
                st.push(ch);
            } else {
                if(st.size() > 0 && st.peek() == '('){
                    st.pop();
                } else{
                    st.push(ch);
                }
            }
        }
        return st.size();
    }
}


20. SCORE OF PARENTHESIS

Input: s = "(()(()))"
Output: 6

class Solution {
    public int scoreOfParentheses(String S) {
        Stack<Integer> st = new Stack<>();
        
        // ( -> -1
        for(int i = 0; i < S.length(); i++){
            
            if(S.charAt(i) == '('){
                st.push(-1);
            }else{
                if(st.peek() == -1){
                    st.pop();
                    st.push(1);
                } else{
                    int val = 0;
                    while(st.peek() != -1){
                        val += st.pop();
                    }
                    st.pop();
                    st.push(2*val);
                }
            }
        }
        int val = 0;
         while(st.size() > 0){
                val += st.pop();
        }
        return val;
    }
}
	                    



21 EXCLUSIVE TIME OF FUNCTION

import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
        // use read for taking input

        int n = Integer.parseInt(read.readLine());
        int len = Integer.parseInt(read.readLine());

        Deque<int[]> st = new ArrayDeque<>();
        
        int ans[] = new int[n];
        
        for(int i=0;i<len;i++){       
            String []log = read.readLine().split(":");     
            int id = Integer.parseInt(log[0]);
            int time = Integer.parseInt(log[2]);
            
            if(log[1].equals("start")){
                st.push(new int[]{time, 0});
            }else{
                int[] pre = st.pop();
                ans[id] += time - pre[0] +1 - pre[1];
                if(st.size()>0){
                    st.peek()[1] += time - pre[0] +1;
                }
            }
            
        }

        for(int e: ans){
            System.out.println(e);
        }
    }
}

                        
 22. 132 PATTERN

import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int nums[] = new int[n];
        for(int i=0;i<n;i++)nums[i] = scn.nextInt();

        Stack<Integer> st = new Stack<>();
        
        int min[] = new int[n];
        min[0] = nums[0];
        
        for(int i=1;i<n;i++)min[i] = Math.min(min[i-1], nums[i]);
        
        boolean found = false;
        for(int i=n-1;i>=0;i--){
            while(st.size()>0 && st.peek() <= min[i])st.pop();
            if(st.size() > 0 && st.peek() < nums[i]){
                found = true;
                break;
            }
            st.push(nums[i]);
        }

        System.out.println(found);

    }
}

                        
                        
                        
23. ASTEROID COLLISION

import java.io.*;
import java.util.*;

public class Main {

  public static int[] asteroidCollision(int[] asteroids) {
    Stack<Integer> st = new Stack<>();

    for (int e : asteroids) {
      if (e > 0) {
        st.push(e);
      } else {
        while (st.size() > 0 && st.peek() > 0 && st.peek() < -e)st.pop();
        if (st.size() > 0 && st.peek() == -e) {
          st.pop();
        } else if (st.size() > 0 && st.peek() > -e) {

        } else {
          st.push(e);
        }
      }
    }

    int ans[] = new int[st.size()];
    int i = ans.length - 1;
    while (i >= 0)ans[i--] = st.pop();
    return ans;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());
    int arr[] = new int[n];
    for (int i = 0; i < n; i++)arr[i] = Integer.parseInt(read.readLine());
    int result[] = asteroidCollision(arr);
    System.out.println(result.length);
    for (int e : result) {
      System.out.println(e);
    }

  }
}                       
                                		                        


                        
                        
                        
25. REMOVE DUPLICATE LETTER

import java.io.*;
import java.util.*;

class Solution {
    public String removeDuplicateLetters(String s) {
         int count[] = new int[26];
        boolean added[] = new boolean[26];
        
        for(int i=s.length()-1;i>=0;i--)count[s.charAt(i)-'a']++;
        
        Stack<Character> st = new Stack<>();
        
        for(int i=0;i<s.length();i++){
            char c = s.charAt(i);
            count[c-'a']--;
            if(added[c-'a']){ 
                continue;
            }
            while(st.size() > 0 && st.peek() > c && count[st.peek()-'a'] > 0){
                added[st.pop()-'a'] = false;
            }
            
            st.add(c);
            added[c-'a'] = true;
          
        }
        
        char ch[] = new char[st.size()];
        int i = ch.length-1;
        while(i>=0)ch[i--] = st.pop();
        
        return new String(ch);
    

    
    }
}

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        String result = removeDuplicateLetters(read.readLine());
        System.out.println(result);
        
    }
}

                        
                        
26. NO OF RECENT CALL

import java.io.*;
import java.util.*;

public class Main {
  public static class RecentCounter {

    Queue<Integer> q = new LinkedList<>();
    int size = 3000;
    public RecentCounter() {

    }

    public int ping(int t) {
      q.add(t);
      while (q.peek() < t - size)q.remove();
      return q.size();
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    RecentCounter obj = new RecentCounter();

    while (read.ready()) {
      int val = Integer.parseInt(read.readLine());
      int ans = obj.ping(val);
      System.out.println(ans);
    }

  }
}



27. CHECK IF WORD IS VALID AFTER SUBSTITUTION

import java.io.*;
import java.util.*;

public class Main {
  public static boolean isValid(String S) {
    Stack<Character> st = new Stack<>();

    char[]chars = S.toCharArray();

    for (char c : chars) {
      if (c == 'c') {
        if (st.size() >= 2 && st.pop() == 'b' && st.pop() == 'a') {
          //correct
        } else return false;
      } else st.push(c);
    }

    return st.size() == 0;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    boolean result = isValid(read.readLine());
    System.out.println(result);

  }
}



28. MOVING AVERAGE FROM DATA STREAM

import java.io.*;
import java.util.*;

public class Main {
  public static class MovingAverage {

    Queue<Integer> q;
    int size;
    double sum;

    public MovingAverage(int size) {
      q = new LinkedList<>();
      this.size = size;
      sum = 0;
    }

    public double next(int val) {
      q.add(val);
      sum += val;

      if (q.size() > size) {
        sum = sum - q.poll();
      }
      return (double)sum / q.size();
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int size = Integer.parseInt(read.readLine());
    MovingAverage obj = new MovingAverage(size);
    PrintWriter out = new PrintWriter(System.out);
    while (read.ready()) {
      int val = Integer.parseInt(read.readLine());
      double avg = obj.next(val);

      StringBuilder ans = new StringBuilder(String.format("%.5f", avg));
      while (ans.charAt(ans.length() - 2) != '.' && ans.charAt(ans.length() - 1) == '0') {
        ans.deleteCharAt(ans.length() - 1);
      }
      out.println(ans);
    }
    out.close();
  }
}

                                
                                                                
29. NO. OF VALID SUBARRAYS

import java.io.*;
import java.util.*;

public class Main {

  public static int validSubarrays(int[] nums) {
     Stack<Integer> st = new Stack<>();
    int count = 0;

    for (int i=nums.length-1; i >=0; i--) {
        int val = nums[i];
      while (st.size() > 0 && nums[st.peek()] >= val) {
        st.pop();
      }
      int si = nums.length;
      if(st.size() > 0) si = st.peek();
      count += si - i;
      st.push(i);
      
    }

    return count;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());
    int nums[] = new int[n];
    for (int i = 0; i < n; i++) {
      nums[i] = Integer.parseInt(read.readLine());
    }

    int count = validSubarrays(nums);

    System.out.println(count);

  }
}


30. MINIMUM REMOVE TO MAKE VALID PARENTHESIS

i/p = "lee(t(c)o)de)"  o/p = lee(t(c)o)de
import java.io.*;
import java.util.*;

public class Main {
    public static String reverseParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        char chs[] = s.toCharArray();
        
        for(int i=0;i<chs.length;i++){
            char ch= chs[i];
            
            if(ch==')'){
                if(st.size()>0){
                    st.pop();
                }else{
                    chs[i] = '.';
                }
            }else if(ch=='('){
                st.push(i);
            }
        }
        
        while(st.size() > 0){
            chs[st.pop()] = '.';
        }
        
        StringBuilder sb = new StringBuilder();
        
        for(char c:chs){
            if(c!='.'){
                sb.append(c);
            }
        }
        
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        String result = reverseParentheses(read.readLine());
        System.out.println(result);
        
    }
}

                        
 
31. REMOVE OUTERMOST PARENTHESIS

import java.io.*;
import java.util.*;

public class Main {
  public static String removeOuterParentheses(String s) {

    Stack<Character> st = new Stack<>();
    StringBuilder sb = new StringBuilder();

    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);

      if (ch == '(') {
        if (st.size() > 0) {
          sb.append(ch);
        }
        st.push(ch);
      } else {
        st.pop();
        if (st.size() > 0) {
          sb.append(ch);
        }
      }
    }

    return sb.toString();
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    String result = removeOuterParentheses(read.readLine());
    System.out.println(result);
  }
}
                       
                                                                                                               
                                                                
32. LEXICOGRAPHICALLY SMALLEST SUBSEQUENCE OF LENGTH K

import java.io.*;
import java.util.*;

public class Main {
  public static int[] smallest(int[] nums, int k) {

    Stack<Integer> st = new Stack<>();
    int n = nums.length;
    for (int i = 0; i < n; i++) {

      while (st.size() > 0 && st.peek() > nums[i] && n - i - 1 >= k - st.size() ) {
        st.pop();
      }
      if (st.size() < k)st.push(nums[i]);
    }

    int ans[] = new int[k];
    int i = k - 1;
    while (i >= 0) {
      ans[i--] = st.pop();
    }

    return ans;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());
    int arr[] = new int[n];
    for (int i = 0; i < n; i++)arr[i] = Integer.parseInt(read.readLine());
    int k = Integer.parseInt(read.readLine());
    int ans[] = smallest(arr, k);
    System.out.println(ans.length);

    for (int e : ans) {
      System.out.println(e);
    }

  }
}

                                	                    

33. BASIC CALCULATOR I

import java.io.*;
import java.util.*;

public class Main {

  public static int calculate(String s) {

    int sum = 0;
    int sign = 1;

    Stack<Integer> st = new Stack<>();

    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);

      if (Character.isDigit(ch)) {

        int val = 0;
        while (i < s.length() && Character.isDigit(s.charAt(i))) {
          val = val * 10  + (s.charAt(i) - '0');
          i++;
        }
        i--;
        val = val * sign;
        sign = 1;
        sum += val;
      } else if (ch == '(') {
        st.push(sum);
        st.push(sign);
        sum = 0;
        sign = +1;
      } else if (ch == ')') {
        sum *= st.pop();
        sum += st.pop();
      } else if (ch == '-') {
        sign *= -1;
      }
    }

    return sum;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int result = calculate(read.readLine());
    System.out.println(result);

  }
}


34. BASIC CALCULATOR II

import java.io.*;
import java.util.*;

public class Main {
  public static int calculate(String s) {

    Stack<Integer> st = new Stack<>();

    
    char sign = '+';
    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);

      if (Character.isDigit(ch)) {
         int val = 0;
         while (i < s.length() && Character.isDigit(s.charAt(i))) {
          val = val * 10  + (s.charAt(i) - '0');
          i++;
        }
        i--;
      
     
        if (sign == '+') {
          st.push(val);
        } else if (sign == '-') {
          st.push(-val);
        } else if (sign == '*') {
          st.push(st.pop()*val);
        } else if (sign == '/') {
          st.push(st.pop() / val);
        }
        } else if(ch != ' ') {
        sign = ch;
        
      }
    }

    int sum = 0;
    while (st.size() > 0) {
      sum += st.pop();
    }

    return sum;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int result = calculate(read.readLine());
    System.out.println(result);

  }
}

                                
                                

35. TRAP RAIN WATER

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 
	
	  public static void main(String[] args) {
	        Scanner scn = new Scanner(System.in);
	        System.out.println("Enter the value");
	        int n = scn.nextInt();
	        int[] arr = new int[n];
	        for (int i = 0; i < n; i++) {
	            arr[i] = scn.nextInt();
	        }
	    System.out.println(traprainwater(arr, n));
	      
	    }

	 
		public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public int trap(final int[] A) {
       if(A.length <= 2) return 0;
                        int left = 0;
                        int n = A.length;
			int right = n - 1;
			int res = 0;
			int maxleft = 0;
			int maxright = 0;
			
			while(left < right) {
				maxleft = Math.max(maxleft, A[left]);
				maxright = Math.max(maxright, A[right]);

				if(maxleft < maxright){
					res += maxleft - A[left];
					left++;
				} else {
					res += maxright - A[right];
					right--;
				}
			}
			return res;
    }
}
}



TRAP RAINWATER II

class Solution {
    public class Pair implements Comparable<Pair> {
        int row;
        int col;
        int height;
        
        public Pair(int row, int col, int height){
            this.row = row;
            this.col = col;
            this.height = height;
        }
        
        public int compareTo(Pair o){
            return this.height - o.height;
        }
    }
    public int trapRainWater(int[][] heightMap) {
        int m = heightMap.length;
        int n = heightMap[0].length;
        
        PriorityQueue<Pair> pq = new PriorityQueue<>();
        boolean[][] vis = new boolean[m][n];
        
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0 || j == 0 || i == m - 1 || j == n - 1){
                    pq.add(new Pair(i, j, heightMap[i][j]));
                    vis[i][j] = true;
                }
            }
        }
        
        int[][] dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};
        int water = 0;
        
        while(!pq.isEmpty()){
            Pair rem = pq.remove();
            
            for(int[] dir : dirs){
                int rowdash = rem.row + dir[0];
                int coldash = rem.col + dir[1];
                
                if(rowdash >= 0 && rowdash < m && coldash >= 0 && coldash < n && vis[rowdash][coldash] == false){
                    
                    water += Math.max(0, rem.height - heightMap[rowdash][coldash]);
                    
                    if(heightMap[rowdash][coldash] >= rem.height){
                        pq.add(new Pair(rowdash, coldash, heightMap[rowdash][coldash]));
                    } else {
                         pq.add(new Pair(rowdash, coldash, rem.height));
                  }
                    
                    vis[rowdash][coldash] = true;
                }
            }
        }
        
        return water;
    }
}




		                        
36. MAXIMUM AREA RECTANGLE

package automate;
import java.io.*;
import java.util.*;
public class MyClass { 



	    public static int MaximumRectangularSubmatrixOf1s(int input[][]){
	    	if(input.length == 0) {
	    		return 0;
	    	}
	    	
	        int temp[] = new int[input[0].length];
	        
                for(int i=0; i< input[0].length; i++){
                  temp[i] = input[0][i];
            }
	       int max = Integer.MIN_VALUE;
	        for(int i=1; i < input.length; i++){
	            for(int j=0; j < temp.length; j++){
	                if(input[i][j] == 0){
	                    temp[j] = 0;
	                }else{
	                    temp[j] += input[i][j];
	                }
	            }
	            max = Math.max(max, findtheArea(temp));
	           
	            }
	        return max;
	        }
	    
	    public static int findtheArea(int[] arr) {
	    	   Stack<Integer> st = new Stack<>();
        int max =0;
        
        st.push(-1);
        
        for(int i=0;i<=arr.length;i++){
            int val = i==arr.length? 0:arr[i];
            
            while(st.peek() != -1 && arr[st.peek()] >= val){
                int rm = i;
                int h = arr[st.pop()];
                int lm = st.peek();
                max = Math.max(max, h*(rm- lm-1));
            }
            st.push(i);
        }
        
        return max;
	      
	    }
	    
	    public static void main(String args[]){
	    	 Scanner t = new Scanner(System.in);
		     System.out.println("Enter a number");
		     int n = t.nextInt();
		     int m = t.nextInt();
		      System.out.println("Enter a value");
		      int[][] arr = new int[n][m];

		      for (int i = 0; i < n; i++) {
		          for (int j = 0; j < m; j++) {
		             arr[i][j] = t.nextInt();
		          }
		       }
		     System.out.println(MaximumRectangularSubmatrixOf1s(arr)); 
	    }
	}



	                    





	             


	                        


	                        


	                        


		    
		 
		 


		                        	                        
		                        

